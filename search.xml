<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>CelexMatlabToolbox-1.0发布记录</title>
      <link href="/2018/06/30/CelexMatlabToolbox-1-0%E5%8F%91%E5%B8%83%E8%AE%B0%E5%BD%95/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><code>CelexMatlabToolbox-1.0</code>工具箱说明;</li><li><code>Release</code>发布操作;</li><li>选择并添加<code>Apache</code>开源证书;</li><li>发起pull request向其他仓库做贡献。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>关于我自己的博客，我其实一直觉得没有什么干货，前些天看到本科跟我同一级但是两年前选择工作而非读研的人的博客，发现人家的技术增长速度真是我们无法企及的。想象那种一切都是为了大用户量，高并发，大数据的工作，真的比我们瞎研究有意义多了，而且成就感恐怕也无法比拟，但是好在我现在的工作也不是只有空想和空谈，不是像本科一样只在看书，不做实践。<br>很期待我真的去到实际生产线接触用户需求的日子，希望那天顺利到来。<br><br>总的一句话，<strong>读研需谨慎</strong>。<br>下面正文。</p><h2 id="工具箱说明"><a href="#工具箱说明" class="headerlink" title="工具箱说明"></a>工具箱说明</h2><h3 id="DVS介绍"><a href="#DVS介绍" class="headerlink" title="DVS介绍"></a>DVS介绍</h3><p>DVS是一种与传统全帧成像的传感器(CMOS/CCD)不同的Sensor,它的主要特点是，画面中每一个像素点的强度信息可以被独立读出，只有该像素点的光强变化超过一定阈值时，才向外部电路发出请求，形成一个个package，这些package最终可以被解码为包含<code>x</code>列地址,<code>y</code>行地址,<code>a</code>强度信息,<code>t</code>时间戳格式的事件，从而被我们用来做二维/三维图像的可视化。<br>目前的DVS生产商在世界上有大概十家左右，具体可以参考<a href="https://github.com/uzh-rpg/event-based_vision_resources#devices" target="_blank" rel="noopener">event-based resources仓库的’Devices &amp; Companies Manufacturing them’目录</a>，其中就包含我们用到的<code>CeleX</code>　DVS器件，目前在售的型号是<code>CeleX IV</code>。</p><h3 id="工具箱内容"><a href="#工具箱内容" class="headerlink" title="工具箱内容"></a>工具箱内容</h3><p><code>CelexMatlabToolbox-1.0</code>是我为<code>CeleX IV</code>型号的DVS(Dynamic Vision Sensor，动态视觉传感器)编写的第一版Matlab工具箱。<br><br><br>工具箱的文件结构和功能如下：</p><ul><li><code>createImgFromRawData.m</code>(即上一版发布的文件<code>bin2picByFixedAmountOfEvents.m</code>)<ul><li>针对bin文件实时解码</li><li>二值图像的实时显示及存储；</li><li>灰度图像的实时显示及存储；</li><li>累积式灰度图的实时显示及存储；</li></ul></li><li>函数集合<code>functions</code><ul><li>对bin文件进行批量解码为<code>x,y,adc,t</code>格式(其中<code>t</code>为连续时间)；</li><li>将解码事件转存为mat文件及其读取；</li><li>二值图的显示及存储；</li><li>灰度图的显示及存储；</li><li>累积式灰度图的显示及存储；</li><li>去噪二值图的显示及存储；</li><li>去噪灰度图的显示及存储；</li><li>事件流的三维动态显示。</li></ul></li><li><code>demo.m</code><ul><li>可运行的示例文件，提供对所有工具箱函数的调用示例。</li></ul></li></ul><p><strong>这一版的代码已经发布到<a href="https://github.com/yucicheung/CelexMatlabToolbox" target="_blank" rel="noopener">我的git仓库</a>。</strong></p><p>目前可预见的待更新内容有</p><ul><li>基于时间片段的事件累积方式实现;</li><li>改进去噪效果<ul><li>考虑FPN的影响</li><li>考虑空间域的事件关联性</li></ul></li></ul><h2 id="添加开源协议"><a href="#添加开源协议" class="headerlink" title="添加开源协议"></a>添加开源协议</h2><h3 id="选择合适的开源协议"><a href="#选择合适的开源协议" class="headerlink" title="选择合适的开源协议"></a>选择合适的开源协议</h3><p><img src="/img/HowToChooseOSSL.png" alt="一张很直观的开源协议选择图"><br><br>我对开源协议的要求主要就是以下两点：</p><ol><li>所有引用或者修改自我的代码都必须加上版权说明;</li><li>保留以此代码为基础申请专利的权利。<br>基于这两点，最终选择了<code>Apache-2.0 LICENSE</code>。<h3 id="添加Apache-2-0-LICENSE"><a href="#添加Apache-2-0-LICENSE" class="headerlink" title="添加Apache-2.0 LICENSE"></a>添加Apache-2.0 LICENSE</h3>步骤如下：</li></ol><ul><li>到<a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">官网</a>下载Apache2.0 License源文件;</li><li>修改源文件，将其中<code>[]</code>包围部分替换为自己的信息;</li><li>将该文件保存为<code>LICENSE</code>文件存储在项目文件夹根目录下;</li><li>如果你还有引用到拥有协议保护的其他第三方库，请将其包含在<code>NOTICE</code>文件中并且做出一些说明，同样包含在项目文件夹的根目录下;</li><li>将license源文件最末的<code>copyright</code>开始的部分粘贴在项目的每个文件中(以注释形式)，一般放置在开头，我放在末尾。</li><li>以上都做完之后，就完成了添加协议，上传到github以后，在你的项目主页就会显示你所用的开源协议标签。</li></ul><h2 id="Release-in-github"><a href="#Release-in-github" class="headerlink" title="Release in github"></a>Release in github</h2><ul><li><p><strong>对当前版本打tag</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0 -m 'Comment'# -a选项描述版本名，-m选项描述对版本的基础描述</span><br></pre></td></tr></table></figure></li><li><p><strong>完善release描述</strong></p><ul><li>点击项目主页的<code>release</code>选项条，会显示你打过的所有tags;</li><li>在对应版本号右边点击<code>edit release notes</code>;</li><li>选择你要编辑的tag号并且添加相应的名字和描述，点击<code>Update release</code>即可发布。<br>最后在项目的<code>release</code>选项条下就会得到一个有详细描述的release版本，用户可以选择下载<code>zip</code>或者<code>.tar.gz</code>格式的版本文件，文件名上会自动加上你的标签号。</li></ul></li></ul><h2 id="发起pull-request"><a href="#发起pull-request" class="headerlink" title="发起pull request"></a>发起pull request</h2><p>最后我希望将我自己的这点小成果添加到上述的<a href="https://github.com/uzh-rpg/event-based_vision_resources" target="_blank" rel="noopener">event-based resources仓库</a>中，所以向该仓库发起了pull request，很幸运最后也确实被批准和merge进去了。<br><br><br>步骤是</p><ul><li>从源仓库fork到自己的仓库;</li><li>从远程仓库clone到本地;</li><li>在本地修改之后进行commit;</li><li>在你自己的远程仓库主页点击<code>new pull request</code>，确认修改信息，添加必要描述，就可以向源仓库发起请求了。</li><li>等待源仓库的reviewer对你的请求做出review，同意之后就等待你的commit被merge进去就可以了。当然也可能被要求修改或者是拒绝，此时你要对你的commit做出进一步修改。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>只是一点微小的工作，还有好多活没干完，当然了，活是干不完的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.oschina.net/news/74999/how-to-choose-a-license" target="_blank" rel="noopener">如何为你的开源项目选择一个合适的开源协议？</a></p>]]></content>
      
      <categories>
          
          <category> Documenting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> github </tag>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微信定时自动发送群消息的小工具-python-itchat</title>
      <link href="/2018/06/13/%E5%BE%AE%E4%BF%A1%E5%AE%9A%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8F%91%E9%80%81%E7%BE%A4%E6%B6%88%E6%81%AF%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本程序实现定时向指定微信群发送指定消息的功能。<br>主要工具如下：</excerpt></p><ul><li>python2.7编写;</li><li><code>itchat</code>提供微信API接口，实现进行向群组发送消息;</li><li><code>apscheduler</code>提供定时器功能。<br>代码下载请到<a href="https://github.com/yucicheung/Mini_Tools/blob/master/WechatTools/onTimeMsgSenderToChatroom.py" target="_blank" rel="noopener">我的github仓库</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><p>最开始只是想能不能做一个程序，可以定时在周二，四，六晚上10点半提醒组员们上传日志，所以就开始了搜索。发现<code>itchat</code>这个超级好用的工具，在<code>apscheduler</code>的加持下最终编了这么一个程序。灵感总是来源于生活….</p><p>当然<code>itchat</code>的功能远不止是发送个群消息而已，它提供的微信API接口还可以做很多有意思的东西，比如最常见的机器人自动回复，还可以接入其他应用程序接口用微信号做一些小应用(如自动播放歌曲，返回天气信息等)。</p><h2 id="依赖条件"><a href="#依赖条件" class="headerlink" title="依赖条件"></a>依赖条件</h2><p>Written in <strong>python2.7.12</strong>：</p><ul><li><code>itchat</code> 1.3.10</li><li><code>APScheduler</code> 3.5.1</li></ul><h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><p>定义文件中的发送时间<code>time</code>，发送群组名<code>roomName</code>，发送消息<code>context</code>(消息中含中文字符时应该使用unicode编码)。<br>运行后会在<code>time</code>对应时间，往<code>roomName</code>对应群组，发送<code>context</code>对应的消息。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul><li><p>修改<code>onTimeMsgSenderToChatroom.py</code>文件中的<code>time</code>，<code>roomName</code>，<code>context</code>设置为自己需要的参数。具体参考如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roomName = <span class="string">u'两张王'</span></span><br><span class="line">context=<span class="string">u'该消息由程序自动发送'</span></span><br><span class="line">time = &#123;<span class="string">'day_of_week'</span>:<span class="string">'*'</span>,<span class="string">'hour'</span>:<span class="number">12</span>,<span class="string">'minute'</span>:<span class="number">34</span>,<span class="string">'second'</span>:<span class="number">26</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行<code>python onTimeMsgSenderToChatroom.py</code>;</p></li><li>扫描QR码，自动登陆成功后，等待信息自动发送即可。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下是用按照上述设置运行源代码向微信群发送的消息的截图。</p><p><img src="/img/msgOnTimeSenderTest.png" alt="msgOnTimeSenderTest"></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>需要下载请到<a href="https://github.com/yucicheung/Mini_Tools/blob/master/WechatTools/onTimeMsgSenderToChatroom.py" target="_blank" rel="noopener">我的github</a>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> itchat</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">onTimeSender</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Automatically send message to chatroom on time according to user's predefinition.</span></span><br><span class="line"><span class="string">params:</span></span><br><span class="line"><span class="string">`roomName`: The name of chatroom you want to send message to;</span></span><br><span class="line"><span class="string">`context`: The message you want to send to chatroom;</span></span><br><span class="line"><span class="string">`time`: Time to send out message, in form of a dict.</span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">Please refer to the __main__ function part.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,roomName=<span class="string">''</span>,context=<span class="string">''</span>,time=&#123;&#125;)</span>:</span></span><br><span class="line">self.roomName=roomName</span><br><span class="line">self.context=context</span><br><span class="line">self.time=time</span><br><span class="line">itchat.auto_login(hotReload=<span class="keyword">True</span>,loginCallback=self.loginCallback,exitCallback=self.exitCallback)</span><br><span class="line">self.schedulerForSender()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendChatroomMsg</span><span class="params">(self,roomName,context)</span>:</span></span><br><span class="line">itchat.get_chatrooms(update=<span class="keyword">True</span>)</span><br><span class="line">roomNickName = roomName</span><br><span class="line">candidates = itchat.search_chatrooms(roomNickName)</span><br><span class="line"><span class="keyword">print</span> candidates</span><br><span class="line">username = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> candidate <span class="keyword">in</span> candidates:</span><br><span class="line"><span class="keyword">if</span> candidate[<span class="string">'NickName'</span>] == roomNickName:</span><br><span class="line">username = candidate[<span class="string">'UserName'</span>]</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> username:</span><br><span class="line">sendtime = datetime.now().strftime(<span class="string">'%A %B %d,%Y'</span>)<span class="comment">#Tue June 08,2018</span></span><br><span class="line">sendtime = datetime.now().strftime(<span class="string">'%m-%d-%Y %H:%M:%S,%A'</span>)</span><br><span class="line">msg = context + <span class="string">"Sending in "</span>+sendtime</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Ready to send message to group %s,message as follows : \n%s"</span>%(roomName,msg)</span><br><span class="line">itchat.send_msg(msg=msg,toUserName=username)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loginCallback</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Successfully logged in."</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exitCallback</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Successfully logged out."</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendMsgToChatRoom</span><span class="params">(self)</span>:</span></span><br><span class="line">self.sendChatroomMsg(self.roomName,self.context)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedulerForSender</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="comment"># scheduler setup</span></span><br><span class="line">scheduler = BlockingScheduler()</span><br><span class="line">scheduler.add_job(self.sendMsgToChatRoom,<span class="string">'cron'</span>,day_of_week=self.time[<span class="string">'day_of_week'</span>],hour=self.time[<span class="string">'hour'</span>],minute=self.time[<span class="string">'minute'</span>],second=self.time[<span class="string">'second'</span>])<span class="comment"># sending takes 4 seconds behind</span></span><br><span class="line">scheduler.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">roomName = <span class="string">'DVS_Group'</span></span><br><span class="line">context = <span class="string">u'通知上传日志'</span></span><br><span class="line">time = &#123;<span class="string">'day_of_week'</span>:<span class="string">'tue,thu,sat'</span>,<span class="string">'hour'</span>:<span class="number">22</span>,<span class="string">'minute'</span>:<span class="number">24</span>,<span class="string">'second'</span>:<span class="number">56</span>&#125;</span><br><span class="line"><span class="string">'''for testing</span></span><br><span class="line"><span class="string">roomName = u'两张王'</span></span><br><span class="line"><span class="string">context=u'该消息由程序自动发送'</span></span><br><span class="line"><span class="string">time = &#123;'day_of_week':'*','hour':12,'minute':34,'second':26&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">onTimeSender(roomName,context,time)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Linux </tag>
            
            <tag> 自制小工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>更改Ubuntu的apt源</title>
      <link href="/2018/05/25/%E6%9B%B4%E6%94%B9Ubuntu%E7%9A%84apt%E6%BA%90/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>配置环境：<strong>Ubuntu 16.04</strong>;</li><li>实现目标：替换apt源为163源，以加速<code>apt install</code>速度;</li><li>Bonus：替换apt源为Xidian源，实现免流量下载。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2>嗯，这是一篇应需而生的博文，好像有段时间没来更博了，因为在忙科研。<br>好好忙科研还是很充实的。</the></li></ul><p>你知道吗，我发现如今科研不仅要你会matlab、python、C、C++会算法，会统计数据会画图会做ppt会报告会话术会word，还要会excel会PS会Premiere。<br>其实也蛮有趣的。</p><h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><p>apt源就是一个文件(Linux下一切都是文件)，位置是<code>\etc\apt\sources.list</code>，打开就可以看到你本机的apt源。</p><p>一般在没有更换apt源的时候(此时官方软件源<code>archive.canonical.com</code>的服务器在国外)，所以你要用<code>sudo apt install</code>安装软件，或者甚至是<code>sudo apt update</code>速度都会很慢，甚至可能由于实在速度过慢，系统认为你没有网络连接而直接导致操作失败。</p><p>所以为了提升我们下载的速度，一般需要把apt源更换成国内的镜像源，这样当你用<code>apt install</code>时系统就会从国内的服务器上去搜索和获取你所查找的资源，下载也就能快很多。</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol><li><code>sudo gedit /etc/apt/sources.list</code>打开文件，原来的软件源可以不用删除，我们只需要在原有内容前面添加我们需要的软件源就行了;</li><li><p>添加163镜像源。在<strong>文件最开头添加</strong>以下内容，因为apt命令选择源的顺序就是按照<code>sources.list</code>中从前到后的顺序，即排在前面的软件源会优先被选择。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.163.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#测试版源</span></span></span><br><span class="line">deb http://mirrors.163.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> 源码</span></span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#测试版源</span></span></span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure></li><li><p>添加Xidian镜像源。如果你这么巧跟我一样是西电学生，那将以下内容添加到源文件的最开始处就能成功省下很多流量(再加上hosts一个月10G的流量限制完全可以无视)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial main multiverse restricted universe</span><br><span class="line"></span><br><span class="line">deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-backports main multiverse restricted universe</span><br><span class="line"></span><br><span class="line">deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-proposed main multiverse restricted universe</span><br><span class="line"></span><br><span class="line">deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-security main multiverse restricted universe</span><br><span class="line"></span><br><span class="line">deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-updates main multiverse restricted universe</span><br><span class="line"></span><br><span class="line">deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial main multiverse restricted universe</span><br><span class="line"></span><br><span class="line">deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-backports main multiverse restricted universe</span><br><span class="line"></span><br><span class="line">deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-proposed main multiverse restricted universe</span><br><span class="line"></span><br><span class="line">deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-security main multiverse restricted universe</span><br><span class="line"></span><br><span class="line">deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-updates main multiverse restricted universe</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> Documenting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>tmux的安装和使用</title>
      <link href="/2018/05/25/tmux-Usage/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>配置环境：<strong>Ubuntu 16.04</strong>;</li><li>安装tmux;</li><li>tmux基本使用命令。<br>tmux是一款分屏工具，可以将你的终端切分成几块利用。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2></the></li></ul><ol><li>安装tmux,<code>sudo apt install tmux</code>。</li><li>开启tmux窗口<code>tmux</code>，会自动进入tmux窗口，此时只分一个窗口。</li><li>tmux命令一般由prefix key+command key触发，使用方式是按住prefix key，松开后按下command key。prefix key默认是<code>Ctrl-b</code>，即同时按住<code>ctrl</code>和<code>b</code>键。而command key列表如下：<ol><li>对窗格的操作：<ol><li><code>%</code>:左右分窗格;</li><li><code>&quot;</code>:上下分窗格;</li><li><code>&lt;arrow key&gt;</code>:窗格导航，如配合使用left方向键时会导航到当前窗格的左端;</li></ol></li><li>对窗口的操作：<ol><li><code>c</code>:创建新窗口;</li><li><code>p</code>:切换到前一个窗口;</li><li><code>n</code>:切换到下一个窗口;</li><li><code>&lt;number&gt;</code>:切换到<number>号窗口，窗口号在窗口下端的status bar上显示。</number></li></ol></li><li>对会话的操作：<ol><li><code>d</code>:脱离当前tmux会话，回到bash下，会话会运行在后台;</li><li><code>D</code>:从tmux选择一个会话进行脱离;</li><li>bash敲入<code>tmux ls</code>可以查看到当前在运行的所有tmux sessions;</li><li>bash敲入<code>tmux attach -t &lt;number&gt;</code>用于连接到<number>对应的会话;</number></li><li>bash敲入<code>tmux new -s aMeaningfulName</code>创建一个会话并赋予名字;    </li><li>bash敲入<code>tmux rename-session -t &lt;number&gt; aMeaningfulName</code>为第<number>号的session赋予一个新的名字。</number></li><li>bash敲入<code>tmux attach -t sessionName</code>重新连接名字对应的session。</li></ol></li></ol></li><li>关闭窗格：用<code>ctrl-d</code>或者是输入<code>exit</code>来关闭。</li><li>查看相关的帮助:<code>ctrl-b</code>+<code>?</code>查看相关命令。</li><li>更多常用命令，prefix key+以下command key:<ol><li><code>z</code>:将一个窗格放大到全窗口/缩回原窗格大小;</li><li><code>Ctrl-&lt;arrow-key&gt;</code>:将窗格按照箭头方向放大/缩小;</li><li><code>,</code>:重命名当前窗口。<h2 id="更多配置"><a href="#更多配置" class="headerlink" title="更多配置"></a>更多配置</h2></li></ol></li><li>配置文件为<code>~/.tmux.conf</code>，每次开启新会话时，Tmux都会先读取该配置文件。</li><li><p>如果希望新的配置能够立即生效，在配置文件中加入以下语句，并按下<code>C-b</code> <code>r</code>就可以使新配置生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind R source-file ~/.tmux.conf; display-message &quot;Config reloaded..&quot;</span><br></pre></td></tr></table></figure></li><li><p>变更快捷键为<code>ctrl-a</code>，在<code>~/.tmux.conf</code>中添加以下语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unbind C-b</span><br><span class="line">set -g prefix C-a</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> Documenting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>建库时帮助筛选图片的GUI小工具(python+tkinter)</title>
      <link href="/2018/04/11/%E5%BB%BA%E5%BA%93%E6%97%B6%E5%B8%AE%E5%8A%A9%E7%AD%9B%E9%80%89%E5%9B%BE%E7%89%87%E7%9A%84GUI%E5%B0%8F%E5%B7%A5%E5%85%B7-python-tkinter/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>一个帮助筛选图片自制GUI程序，方便建立图片数据库时使用。</excerpt></p><ul><li>python2.7编写;</li><li>使用tkinter+Pillow;<br>代码下载请到<a href="https://github.com/yucicheung/Mini_Tools/tree/master/ClassifyGUI" target="_blank" rel="noopener">我的github仓库</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2>建立数据库过程中，需要对收集到的图片进行筛选，查看每一张图片，将合适的图片移动到最终的<code>category</code>目录中，而不合适的图片移动到<code>categoryDump</code>目录下。<br>这样一来方便建立数据库，二来不需要的图片也可以整理好(以便日后使用,如做负目标等)。<br>对于这个需求，就需要一边能实现查看图片，针对查看图片即使做出移动的动作，因此设计了一个GUI程序实现功能。<h2 id="依赖条件"><a href="#依赖条件" class="headerlink" title="依赖条件"></a>依赖条件</h2>Written in <strong>python2.7.12</strong>：</the></li><li>python-tk 2.7.12-1~16.04</li><li>PILLOW_VERSION = ‘5.0.0’</li></ul><h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><p>程序实现如下功能：</p><ol><li>当点击单选按钮时(请保证源数据目录都已正确设置)，程序会检查目录中的图片数量：<ul><li>如果图片总数是0,告知用户目录为空(即图片已处理完成);</li><li>如果大于0,显示其中一副图片，并且程序会确保源目录下有<code>category</code>目录及<code>categoryDump</code>目录存在。</li></ul></li><li>当点击<code>category</code>按钮时，将图片移动到<code>category</code>目录下;</li><li>当点击<code>categoryDump</code>钮时,将图片移动到<code>categoryDump</code>目录下。</li></ol><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>如果要测试程序,运行 <code>main.py</code>。</p><p>否则,在运行 <code>main.py</code>前你需要:</p><ul><li>根据自己的需求修改<code>main.py</code>中的参数;</li><li><strong>如果有多于4类要分</strong>，请修改<code>ClassifyGUI.py</code>中相关参数.</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>GUI的实际大小是<em>900x750</em>,以下展示图片按照0.5倍率缩放。</p><ul><li>程序初始化</li></ul><p><img src="/img/initialization.png" alt="Initialization"></p><ul><li>当点击单选按钮</li></ul><p><img src="/img/clickRadioButton.png" alt="clickRadioButton"></p><ul><li>当处理完当前类别的所有图片</li></ul><p><img src="/img/doneProcessing.png" alt="doneProcessing"></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>需要下载请到<a href="https://github.com/yucicheung/Mini_Tools/tree/master/ClassifyGUI" target="_blank" rel="noopener">我的github</a>。</p><ul><li><p><code>main.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> ClassifyGUI <span class="keyword">import</span> ClassifyGUI</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># config vars</span></span><br><span class="line">config = &#123;&#125;</span><br><span class="line">config[<span class="string">"destinationDir"</span>] = <span class="string">'./dataset'</span></span><br><span class="line">config[<span class="string">"searchPathList"</span>] = [<span class="string">'./dataset/hm'</span>,<span class="string">'./dataset/hz'</span>,<span class="string">'./dataset/ys'</span>,<span class="string">'./dataset/jq'</span>]</span><br><span class="line">config[<span class="string">"types"</span>] = [<span class="string">"AircraftCarrier"</span>,<span class="string">'Bomber'</span>,<span class="string">'TransportAircraft'</span>,<span class="string">'DestroyerAndFrigate'</span>]</span><br><span class="line">config[<span class="string">"dumpPath"</span>] = [os.path.join(config[<span class="string">"destinationDir"</span>], config[<span class="string">"types"</span>][i] + <span class="string">'Dump'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">4</span>)]</span><br><span class="line">config[<span class="string">"picSize"</span>] = (<span class="number">500</span>, <span class="number">500</span>)</span><br><span class="line">config[<span class="string">"windowTitle"</span>] = <span class="string">'Classify pics'</span></span><br><span class="line">config[<span class="string">"windowGeometry"</span>] = <span class="string">'900x750'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    ClassifyGUI(config)</span><br></pre></td></tr></table></figure></li><li><p><code>utils.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">import</span> tkinter.messagebox</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkdir</span><span class="params">(pathToCheck)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(pathToCheck):</span><br><span class="line">        os.mkdir(pathToCheck)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> len(os.listdir(pathToCheck))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkSourceEmpty</span><span class="params">(picList)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(picList)==<span class="number">0</span>:</span><br><span class="line">        tk.messagebox.showwarning(title=<span class="string">'Finish'</span>, message=<span class="string">'Finish processing all images of this type!'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></li><li><p><code>ClassifyGUI.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageTk</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassifyGUI</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, config)</span>:</span></span><br><span class="line">        self.config = config</span><br><span class="line">        self.radioButtonPos = (<span class="number">100</span>,<span class="number">150</span>)</span><br><span class="line">        self.imgBoxPos = (<span class="number">200</span>,<span class="number">200</span>)</span><br><span class="line">        self.radioPad = <span class="number">220</span></span><br><span class="line">        self.gridPad = (<span class="number">30</span>,<span class="number">10</span>)</span><br><span class="line">        self.setUpWindow()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUpWindow</span><span class="params">(self)</span>:</span></span><br><span class="line">        searchPathLists = self.config[<span class="string">"searchPathList"</span>]</span><br><span class="line">        picLists = [[p <span class="keyword">for</span> p <span class="keyword">in</span> os.listdir(searchPathLists[i]) <span class="keyword">if</span> p.endswith(<span class="string">'.png'</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">4</span>)]</span><br><span class="line">        destinationDir = self.config[<span class="string">"destinationDir"</span>]</span><br><span class="line">        types = self.config[<span class="string">"types"</span>]</span><br><span class="line">        dumpPaths = self.config[<span class="string">"dumpPath"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">radioButtonTrigger</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">            Index = pathIndex.get()</span><br><span class="line">            processPath = searchPathLists[Index]</span><br><span class="line">            picList = picLists[Index]</span><br><span class="line">            <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                destinationPath = os.path.join(destinationDir, types[Index])</span><br><span class="line">                checkdir(destinationPath)</span><br><span class="line">                checkdir(dumpPaths[Index])</span><br><span class="line">                picpath = os.path.join(processPath, picList[<span class="number">-1</span>])</span><br><span class="line">                changeImg(picpath)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">buttonTrigger0</span><span class="params">()</span>:</span></span><br><span class="line">            typeIndex = <span class="number">0</span></span><br><span class="line">            picList = picLists[typeIndex]</span><br><span class="line">            <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                processImg = picList.pop()</span><br><span class="line">                type = types[typeIndex]</span><br><span class="line">                searchPathList = searchPathLists[typeIndex]</span><br><span class="line">                srcImg = os.path.join(searchPathList, processImg)</span><br><span class="line">                desImg = os.path.join(destinationDir, type, processImg)</span><br><span class="line">                os.system(<span class="string">'mv &#123;&#125; &#123;&#125;'</span>.format(srcImg, desImg))</span><br><span class="line">                <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                    picpath = os.path.join(searchPathList, picList[<span class="number">-1</span>])</span><br><span class="line">                    changeImg(picpath)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dumpTrigger0</span><span class="params">()</span>:</span></span><br><span class="line">            typeIndex = <span class="number">0</span></span><br><span class="line">            picList = picLists[typeIndex]</span><br><span class="line">            <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                processImg = picList.pop()</span><br><span class="line">                searchPathList = searchPathLists[typeIndex]</span><br><span class="line">                dumpPath = dumpPaths[typeIndex]</span><br><span class="line">                srcImg = os.path.join(searchPathList, processImg)</span><br><span class="line">                desImg = os.path.join(dumpPath, processImg)</span><br><span class="line">                os.system(<span class="string">'mv &#123;&#125; &#123;&#125;'</span>.format(srcImg, desImg))</span><br><span class="line">                <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                    picpath = os.path.join(searchPathList, picList[<span class="number">-1</span>])</span><br><span class="line">                    changeImg(picpath)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">buttonTrigger1</span><span class="params">()</span>:</span></span><br><span class="line">            typeIndex = <span class="number">1</span></span><br><span class="line">            picList = picLists[typeIndex]</span><br><span class="line">            <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                processImg = picList.pop()</span><br><span class="line">                type = types[typeIndex]</span><br><span class="line">                searchPathList = searchPathLists[typeIndex]</span><br><span class="line">                srcImg = os.path.join(searchPathList, processImg)</span><br><span class="line">                desImg = os.path.join(destinationDir, type, processImg)</span><br><span class="line">                os.system(<span class="string">'mv &#123;&#125; &#123;&#125;'</span>.format(srcImg, desImg))</span><br><span class="line">                <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                    picpath = os.path.join(searchPathList, picList[<span class="number">-1</span>])</span><br><span class="line">                    changeImg(picpath)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dumpTrigger1</span><span class="params">()</span>:</span></span><br><span class="line">            typeIndex = <span class="number">1</span></span><br><span class="line">            picList = picLists[typeIndex]</span><br><span class="line">            <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                processImg = picList.pop()</span><br><span class="line">                searchPathList = searchPathLists[typeIndex]</span><br><span class="line">                dumpPath = dumpPaths[typeIndex]</span><br><span class="line">                srcImg = os.path.join(searchPathList, processImg)</span><br><span class="line">                desImg = os.path.join(dumpPath, processImg)</span><br><span class="line">                os.system(<span class="string">'mv &#123;&#125; &#123;&#125;'</span>.format(srcImg, desImg))</span><br><span class="line">                <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                    picpath = os.path.join(searchPathList, picList[<span class="number">-1</span>])</span><br><span class="line">                    changeImg(picpath)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">buttonTrigger2</span><span class="params">()</span>:</span></span><br><span class="line">            typeIndex = <span class="number">2</span></span><br><span class="line">            picList = picLists[typeIndex]</span><br><span class="line">            <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                processImg = picList.pop()</span><br><span class="line">                type = types[typeIndex]</span><br><span class="line">                searchPathList = searchPathLists[typeIndex]</span><br><span class="line">                srcImg = os.path.join(searchPathList, processImg)</span><br><span class="line">                desImg = os.path.join(destinationDir, type, processImg)</span><br><span class="line">                os.system(<span class="string">'mv &#123;&#125; &#123;&#125;'</span>.format(srcImg, desImg))</span><br><span class="line">                <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                    picpath = os.path.join(searchPathList, picList[<span class="number">-1</span>])</span><br><span class="line">                    changeImg(picpath)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dumpTrigger2</span><span class="params">()</span>:</span></span><br><span class="line">            typeIndex = <span class="number">2</span></span><br><span class="line">            picList = picLists[typeIndex]</span><br><span class="line">            <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                processImg = picList.pop()</span><br><span class="line">                searchPathList = searchPathLists[typeIndex]</span><br><span class="line">                dumpPath = dumpPaths[typeIndex]</span><br><span class="line">                srcImg = os.path.join(searchPathList, processImg)</span><br><span class="line">                desImg = os.path.join(dumpPath, processImg)</span><br><span class="line">                os.system(<span class="string">'mv &#123;&#125; &#123;&#125;'</span>.format(srcImg, desImg))</span><br><span class="line">                <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                    picpath = os.path.join(searchPathList, picList[<span class="number">-1</span>])</span><br><span class="line">                    changeImg(picpath)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">buttonTrigger3</span><span class="params">()</span>:</span></span><br><span class="line">            typeIndex = <span class="number">3</span></span><br><span class="line">            picList = picLists[typeIndex]</span><br><span class="line">            <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                processImg = picList.pop()</span><br><span class="line">                type = types[typeIndex]</span><br><span class="line">                searchPathList = searchPathLists[typeIndex]</span><br><span class="line">                srcImg = os.path.join(searchPathList, processImg)</span><br><span class="line">                desImg = os.path.join(destinationDir, type, processImg)</span><br><span class="line">                os.system(<span class="string">'mv &#123;&#125; &#123;&#125;'</span>.format(srcImg, desImg))</span><br><span class="line">                <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                    picpath = os.path.join(searchPathList, picList[<span class="number">-1</span>])</span><br><span class="line">                    changeImg(picpath)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dumpTrigger3</span><span class="params">()</span>:</span></span><br><span class="line">            typeIndex = <span class="number">3</span></span><br><span class="line">            picList = picLists[typeIndex]</span><br><span class="line">            <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                processImg = picList.pop()</span><br><span class="line">                searchPathList = searchPathLists[typeIndex]</span><br><span class="line">                dumpPath = dumpPaths[typeIndex]</span><br><span class="line">                srcImg = os.path.join(searchPathList, processImg)</span><br><span class="line">                desImg = os.path.join(dumpPath, processImg)</span><br><span class="line">                os.system(<span class="string">'mv &#123;&#125; &#123;&#125;'</span>.format(srcImg, desImg))</span><br><span class="line">                <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                    picpath = os.path.join(searchPathList, picList[<span class="number">-1</span>])</span><br><span class="line">                    changeImg(picpath)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">changeImg</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">            <span class="keyword">print</span> imgPath</span><br><span class="line">            im = Image.open(imgPath)</span><br><span class="line">            processImage = ImageTk.PhotoImage(im)</span><br><span class="line">            lbPic[<span class="string">'image'</span>] = processImage</span><br><span class="line">            lbPic.image = processImage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        window = tk.Tk()</span><br><span class="line">        window.title(self.config[<span class="string">"windowTitle"</span>])</span><br><span class="line">        window.geometry(self.config[<span class="string">"windowGeometry"</span>])</span><br><span class="line">        lbPic = tk.Label(window, text=<span class="string">'image'</span>, width=<span class="number">500</span>, height=<span class="number">500</span>)</span><br><span class="line">        lbPic.place(x=self.imgBoxPos[<span class="number">0</span>], y=self.imgBoxPos[<span class="number">1</span>], width=<span class="number">500</span>, height=<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># set up radio buttons</span></span><br><span class="line">        pathIndex = tk.IntVar()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">4</span>):</span><br><span class="line">            tk.Radiobutton(window, text=self.config[<span class="string">"searchPathList"</span>][i], variable=pathIndex,</span><br><span class="line">                           value=i, command=radioButtonTrigger).\</span><br><span class="line">                place(x=self.radioButtonPos[<span class="number">0</span>]+self.radioPad*i,y=self.radioButtonPos[<span class="number">1</span>],anchor=<span class="string">'nw'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">4</span>):</span><br><span class="line">                <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    tk.Button(window, text=self.config[<span class="string">"types"</span>][j], width=<span class="number">20</span>, height=<span class="number">1</span>,</span><br><span class="line">                            command=eval(<span class="string">'buttonTrigger'</span>+str(j))).\</span><br><span class="line">                        grid(row=i, column=j, padx=self.gridPad[<span class="number">0</span>], pady=self.gridPad[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">elif</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                    tk.Button(window, text=<span class="string">'dump '</span>+self.config[<span class="string">"types"</span>][j], width=<span class="number">20</span>, height=<span class="number">1</span>,</span><br><span class="line">                              command=eval(<span class="string">'dumpTrigger'</span>+str(j))). \</span><br><span class="line">                        grid(row=i, column=j, padx=self.gridPad[<span class="number">0</span>], pady=self.gridPad[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        window.mainloop()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Linux </tag>
            
            <tag> 自制小工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列11-Shell编程</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%9711-Shell%E7%BC%96%E7%A8%8B/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>正则表达式</li><li>Shell编程</li><li>Shell定制<br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2></the></li><li>正则表达式广泛应用在各种脚本语言中(解释型语言)包括Perl、PHP、Ruby和Python等，Linux的各种编程工具中也大量采用了正则表达式(Shell脚本编程)。</li><li>“正则表达式”(regexps)又被称作“模式”(至少在Linux中是这样)，是被用来字符处理的一套规则;<ul><li>简而言之，正则表达式是一组对正在查找的文本的描述。</li></ul></li><li>目前在GNU/Linux中有两套库可用于正则表达式编程：<ul><li>POSIX库：是Linux自带的正则表达式库(Python中也使用这套标准);</li><li>PCRE库：是Perl的正则表达式库。</li></ul></li><li><p>举个例子：匹配<code>/usr/share/dict/words</code>中“a开头、t结尾”的单词，采用命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ egrep <span class="string">"^a.*t$"</span> /usr/share/dict/words <span class="comment"># egrep比grep支持更多正则表达式规则，此处grep也可以</span></span><br><span class="line"><span class="comment"># 如果我们要统计总的单词数</span></span><br><span class="line">$ egrep <span class="string">'^a.*t$'</span> /usr/share/dict/words | wc -c</span><br></pre></td></tr></table></figure></li><li><p>正则表达式字符集：</p><ul><li><code>.</code>：匹配换行符之外的任意一个字符，<code>.</code>能匹配的字符范围是最大的;</li><li><code>[]</code>：指定一个字符集，要求只能匹配其中的一个字符，如<code>[abc]</code>表示三选一;</li><li><code>-</code>：连字符，和<code>[]</code>配合使用，如<code>[a-zA-Z]</code>表示匹配一个字母;</li><li><code>\&lt;</code>和<code>\&gt;</code>：一对分隔符，表示匹配一个单词，注意<strong>正则表达式中对单词的定义</strong>指的是两侧由非单词字符分隔的字符串（非单词字符指的是字母、数字、下划线以外的任何字符）;</li></ul></li><li>字符类：POSIX风格的正则表达式还提供预定义字符类来匹配某些特定的字符(但是很多类都可以用简单的正则表达式表示);</li></ul><table><thead><tr><th>类</th><th>匹配字符</th></tr></thead><tbody><tr><td>[[:alnum:]]</td><td>字母、数字字符</td></tr><tr><td>[[:alpha:]]</td><td>字母字符</td></tr><tr><td>[[:lower:]]</td><td>小写字母</td></tr><tr><td>[[:upper:]]</td><td>大写字母</td></tr><tr><td>[[:digit:]]</td><td>小数</td></tr><tr><td>[[:xdigit:]]</td><td>十六进制数字</td></tr><tr><td>[[:punct:]]</td><td>标点符号</td></tr><tr><td>[[:blank:]]</td><td>制表符和空格</td></tr><tr><td>[[:space:]]</td><td>空格</td></tr><tr><td>[[:cntrl:]]</td><td>所有控制符</td></tr><tr><td>[[:print:]]</td><td>所有可打印字符</td></tr><tr><td>[[:graph:]]</td><td>除空格外所有可打印字符</td></tr></tbody></table><ul><li>位置匹配：<ul><li><code>^</code>:用于匹配行首;</li><li><code>$</code>:用于匹配行尾。</li><li>所以如果要匹配一个空行就用<code>^$</code>，两者不必非要一起使用。</li></ul></li><li>字符转义：<ul><li><code>\</code>：当要匹配特殊字符本身时，就在前加上转义字符，取消元字符本身的特殊含义。</li></ul></li><li>重复：<ul><li><code>*</code>：表示在<code>*</code>前面的模式应该重复<strong>0次或多次</strong>;</li><li><code>+</code>:表示模式重复<strong>1次或多次</strong>;</li><li><code>?</code>:重复<strong>0次或1次</strong>;</li><li><code>{n}</code>:模式重复n次;</li><li><code>{n,}</code>:模式重复n次或更多;</li><li><code>{n,m}</code>:模式不少于n次，不多于m次。</li><li>一个例子，匹配不少于8位的数<code>\&lt;[1-9][0-9]{7,}\&gt;</code> 。</li></ul></li><li>子表达式，i.e.”分组”：<ul><li><code>()</code>:将部分字符组成一个字符组作为一个子模式，如”(or){2,}”表示整个子字符组重复2次以上，否则只重复紧挨的字符r。</li></ul></li><li>反义(<code>^</code>在行首表示位置匹配，放括号内表示反义)：<ul><li><code>^</code>:除了此字符以外，全部都可以，和<code>[]</code>配合使用，表示除括号内字符的任意一个其他字符。如<code>[^ya]</code>表示除y和a以外的任一字符。</li></ul></li><li>分支，或者叫“或”逻辑(一般正则表达式总是执行“与”逻辑，指同时满足给出的若干条件)：<ul><li><code>|</code>:如<code>^h|h$</code>表示h开头”或”h结尾，而<code>^hh$</code>表示h开头”且”h结尾(即’hh’)，一个表达式中可以出现多个或逻辑<code>Jan(uary| |\.)</code>。</li></ul></li><li>逆向引用：子表达式中捕获的内容可以在正则表达式的其他地方再次使用;<ul><li><code>\n</code>:’反斜杠+编号n’表示第n组子表示匹配到的内容，如<code>(\&lt;*.\&gt;).?( )*\1</code>可以匹配如’cart cart’,’ha!ha’这些字符组;</li><li>从左到右，第i个出现的子表达式编号为i。</li></ul></li></ul><h2 id="Shell脚本编程"><a href="#Shell脚本编程" class="headerlink" title="Shell脚本编程"></a>Shell脚本编程</h2><ul><li>Shell本身就是一个命令解释器(而不是一门编程语言)，所以可以在shell中运行命令(执行程序，命令就是语句的组合);</li><li>Shell本身都是同一个程序<code>/bin/bash</code>，子/父shell是指他们之间的调用关系。<h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3></li><li>Shell因为分许多种类，严格说这里学习的应该BASH编程。</li><li>Shell脚本语言不需要编译(并不能说’脚本语言一定不需要编译/解释型语言不需要编译’)。</li><li>下面一个例子，告诉我们：<ul><li>第一行总是以<code>#!</code>开头，指定脚本的运行环境，<code>#! /bin/bash</code>告诉shell运行此脚本应该使用的shell(可以省略但不是一个好习惯);</li><li><code>#</code>表示注释;</li><li><code>echo</code>执行时会自动加上一个换行符;</li><li>文本加上可执行权限之后才能变成脚本执行，<code>chmod a+x hello</code>/<code>chmod +x hello</code>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line">#Display a line</span><br><span class="line"></span><br><span class="line">echo &apos;Hello world!&apos; #echo会在最后自动加上一个换行符</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="变量和运算符"><a href="#变量和运算符" class="headerlink" title="变量和运算符"></a>变量和运算符</h3><ul><li>变量从诞生、消亡和作用范围：<ul><li>Shell中变量使用之前不用事先声明(脚本语言貌似都如此);</li><li><code>=</code>：赋值符号，如<code>var=1</code>就是给var赋值，<strong>注意’=’两边不能有空格</strong>;</li><li><code>$</code>:shell编程中用于对一个变量进行解析，表示取得变量的值;</li><li><code>source</code>/<code>.</code>：一般变量只在其所在的”脚本”中有效，shell中不可见其值，但<code>source</code>命令可以<strong>让一个脚本影响其父Shell环境</strong>(当前执行脚本的shell及其父shell)，使值在shell中可见;</li><li><code>export</code>：可以让脚本影响其子shell环境(子shell是在执行脚本中<code>sh</code>命令调用的shell);</li><li>在配置脚本(父shell)中命令要影响shell用<code>export</code>，在shell中要影响配置脚本用<code>source</code>;</li><li><code>unset</code>:手动注销一个变量。</li></ul></li><li><p>变量替换：</p><ul><li><code>\</code>：转义字符，如果要输出特殊字符时使用(类所有编程语言)，如<code>\$</code>输出美元符号;</li><li><code>{}</code>：限定变量的开始和结束(类python)，如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">word=<span class="string">"big"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The apple is <span class="variable">$&#123;word&#125;</span>."</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>位置变量：依次序获取各命令行参数;</p><ul><li><code>$0</code>：表示第一个<strong>命令行参数</strong>，这个参数总是脚本的名字;</li><li><code>$n</code>：表示第n个<strong>参数</strong>(不包括脚本名);</li><li><code>${n}</code>:当n为一位数以上时，需要用大括号将位置序号括起来;</li><li><code>$*</code>/<code>$@</code>:<strong>参数</strong>列表(不包括脚本名);</li><li><code>$#</code>：包含参数个数(参数列表长度)。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 是$@最常见的用法</span></span><br><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$#</span> files to list:"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="variable">$@</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">ls -l <span class="variable">$file</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>BASH引号规则</strong>：</p><ul><li><code>&quot;&quot;</code>：双引号，阻止Shell对大多特殊字符(如#)进行解释，但$/`/“仍保持其特殊含义;</li><li><code>&#39;&#39;</code>：单引号，阻止shell对所有字符进行解释;</li><li><code>\`</code>：倒引号，当倒引号括起一个shell命令时，该命令将被执行，执行后的输出结果将作为表达式的值，倒引号中的特殊字符一般都被解释。</li></ul></li><li>运算符：shell完全复制了C语言中的运算符和优先级规则。日常只使用其中部分即可，数学运算并不是shell的强项。所有可用的运算符如下，优先级从高到低：<ul><li>-，+：[<a href="单目负取反，单目正没有意义">单目[负 正]</a>[减 加]];</li><li>!，||,&amp;&amp;：逻辑[非 或 与];</li><li>~，&amp;，^，|,&gt;&gt;，&lt;&lt;：按位[取反 与 异或 或 右移 左移];</li><li>&lt;=，&gt;=,&lt;,&gt;,==,!=：[小于等于 大于等于 小于 大于 等于 不等于];</li><li>*,/,%：[乘 除 取模];</li><li>=,[+-*/%&amp;^|(&lt;&lt;)(&gt;&gt;)]=：赋值，运算并赋值。</li><li>同样可用<code>()</code>改变优先级;</li></ul></li><li>shell中相等可以用<code>=</code>和<code>==</code>表示，因为<code>=</code>赋值时两边无空格(因为变量不是命令不能分开，而整个语句才能算是一个命令)，而表示比较时两边有空格。<h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3></li><li><p><code>$[]</code>：求值后整体赋值。</p><ul><li><code>[base#]n</code>可以表示从2到36进制的任何一个n值（默认十进制），如2#10表示二进制数10;</li><li><code>$[]</code>可以接受不同基数的数字求值；</li><li>举个例子，如下第一段输出结果是<code>1+2</code>，因为shell是一种<strong>弱类型</strong>的语言，换言之shell不知道num的类型，因此只能简单取得$num将整个表达式赋值。如果按第二段就能计算后再输出结果。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">num=1</span><br><span class="line"><span class="comment"># ouput 1+2</span></span><br><span class="line">num=<span class="variable">$num</span>+2</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$num</span></span><br><span class="line"><span class="comment"># output 3</span></span><br><span class="line">num=$[num]</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>expr</code>命令也对表达式执行求值操作，可以允许更复杂的表达式。</p></li><li><code>let</code>：此命令也指导shell进行表达式求值，功能类似<code>$[]</code>，命令右边的表达式不能有空格，如<code>let num=$num+1</code>会输出值而非表达式。<h3 id="脚本执行命令和控制语句"><a href="#脚本执行命令和控制语句" class="headerlink" title="脚本执行命令和控制语句"></a>脚本执行命令和控制语句</h3></li><li><p>if条件语句格式(<strong>每个if语句都必须用fi结尾</strong>)：</p><ul><li><p>格式1:<code>if-then-fi</code>;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">test</span>-commands</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><p>格式2：<code>if-then-elif-then-else-fi</code>,当然各条件语句之间必须互斥;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">test</span>-command-1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands-1</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">test</span>-command-2</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands-2</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">test</span>-command-3</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands-3</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">commands-4</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">- **注意**(由例子):</span><br><span class="line">- (1)条件判断语句中`[`/`]`与表达式之间必须有空格，`=`两边必须有空格;</span><br><span class="line">- (2)条件语句后可以跟`;`也可以不跟，只是用于分隔语句;</span><br><span class="line">- (3)字符串可以用`<span class="string">""</span>`包围，也可以不用，等号左边的表达式/前面有`$`的是变量，否则可以自动认为是字符串。</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># if例子</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Enter password:"</span></span><br><span class="line"><span class="built_in">read</span> password</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$password</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$password</span>"</span> = john ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello John"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">"<span class="variable">$password</span>"</span> = mike ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello Mike"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">"<span class="variable">$password</span>"</span> = lewis ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello Lewis"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"I don't know you,go away"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li><p>case多选结构：用于在一系列模式中匹配某个变量的值;</p><ul><li><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> word <span class="keyword">in</span></span><br><span class="line">pattern1)</span><br><span class="line">commands1</span><br><span class="line">;;</span><br><span class="line">pattern2)</span><br><span class="line">commands2</span><br><span class="line">;;</span><br><span class="line">...</span><br><span class="line">patternN)</span><br><span class="line">commandsN</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>(将if例子用case重写)：</p></li><li>(1) <code>;;</code>相当于C语言中的<code>break</code>，shell遇见时会跳转到case结构的最后，但是Shell中<code>;;</code>是不能省略的;</li><li>(2)case语句是逐条检索匹配的;</li><li>(3)case结构最后一个模式通常用<code>*)</code>，因<code>*</code>用于匹配所有的字符串;<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># an example of case</span></span><br><span class="line"><span class="comment"># note $n means nth input params</span></span><br><span class="line"><span class="comment"># 重写if例子</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">john)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello John!"</span></span><br><span class="line">;;</span><br><span class="line">mike)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello Mike!"</span></span><br><span class="line">;;</span><br><span class="line">lewis)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello Lewis!"</span></span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Go away!!"</span></span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h3><ul><li><code>if</code>判断的依据是程序的返回值(0为真/正常，非0为假/出错序号)：<ul><li><code>if</code>接受一个程序名作为参数，根据执行程序的返回值判断是否执行：</li><li>(1)如果返回值为0，表示True;</li><li>(2)如果返回值为1，表示False。</li></ul></li><li><p>例子如下，只有返回值为0的第2条if语句成功执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ./testscript -1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"testscript exit -1"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ./testscript 0</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"testscript exit 0"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ./testscript 1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"testscript exit 1"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#----------testscript--------</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#表示退出并返回输入所有参数</span></span><br><span class="line"><span class="built_in">exit</span> <span class="variable">$@</span></span><br></pre></td></tr></table></figure></li><li><p><code>test</code>命令和空格的使用：</p><ul><li><code>test</code>:if语句既然只接受程序名为参数，所以if的条件判断需要引入一个特定的命令即<code>test</code>，也是<code>[</code>方括号的同义词;</li><li>关于空格：</li><li>(1)<code>test</code>和<code>[</code>都是<code>/usr/bin</code>下的命令，而判断的字符串(…)和<code>=</code>及<code>]</code>都是要求输入的参数，参数之间必须要空格分开(<strong>!!在赋值语句中<code>=</code>两边一定没有空格</strong>);</li><li>(2)总的来说，空格在shell这个命令解释器中的作用就是分隔命令与参数/参数与参数。</li></ul></li><li><code>test</code>/<code>[</code>命令可以对以下3类表达式进行测试(可以在<code>man test</code>中看到详细内容)：<ul><li>字符串比较(字符串相等/字符串是否为空)：<ul><li><strong>引号的使用</strong>：Bash中给字符串两边加<code>&quot;&quot;</code>不是必要的，因为Bash会自动给没有值的变量加上引号（但是有些shell不如此）,为保证清晰性和可移植性应为字符串变量加上引号。</li></ul></li></ul></li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-z str</td><td>当字符串str长度为0时返回真</td></tr><tr><td>-n str</td><td>当字符串长度不为0时返回真</td></tr><tr><td>str1 = str2</td><td>相等时返回真</td></tr><tr><td>str1 != str2</td><td>不等时返回真</td></tr></tbody></table><ul><li>文件测试：用于判断一个文件是否满足特定的条件;</li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-d pathname</td><td>是目录时返回真</td></tr><tr><td>-e pathname</td><td>指定文件或目录存在时为真</td></tr><tr><td>-f file</td><td>是常规文件(非符号链接、管道、目录等)时为真</td></tr><tr><td>-h file</td><td>是符号链接文件时返回真</td></tr><tr><td>-[rwx] pathname</td><td>当指定的文件或目录设置了可[读 写 执行]</td><td>权限时为真</td></tr></tbody></table><ul><li>数字比较：只能用于比较正/负整数<code>test int1 option int2</code>/<code>[ int1 option int2 ]</code>;</li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-eq</td><td>int1 == int2</td></tr><tr><td>-ne</td><td>int1 != int2</td></tr><tr><td>-lt</td><td>int1 &lt; int2</td></tr><tr><td>-gt</td><td>int1 &gt; int2</td></tr><tr><td>-le</td><td>int1 &lt;= int2</td></tr><tr><td>-ge</td><td>int1 &gt;= int2</td></tr></tbody></table><ul><li>复合表达式：用逻辑(与或非)串起的多个表达式；<ul><li><strong>注意</strong>：Shell的内建条件操作符<code>&amp;&amp;</code>或<code>||</code>可以代替下面的<code>-a</code>和<code>-o</code>；前者连接两条<code>[</code>或<code>test</code>语句，逻辑清晰;后者只用一条<code>[</code>/<code>test</code>语句，执行效率相对更高；如｀[ -f $@ -a -x /usr/bin/vim ]｀等于<code>[ -f $@ ] &amp;&amp; [ -x /usr/bin/vim ]</code>．</li></ul></li></ul><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>!expr</td><td>“非”运算</td></tr><tr><td>expr1 -a expr2</td><td>“与”运算</td></tr><tr><td>expr1 -o expr2</td><td>“或”运算</td></tr></tbody></table><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><ul><li>Shell中的循环结构有3种:(1)while;(2)until;(3)for;</li><li>条件测试时比较变量值时不能忘记<code>$</code>符号;</li><li><p><code>while</code>语句：</p><ul><li><p>基本结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">test</span>-commands</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p><code>while</code>语句的测试条件除了使用<code>test</code>,<code>[</code>函数，还可以利用函数<code>read</code>等的返回值。</p></li></ul></li><li><p><code>until</code>语句：和<code>while</code>功能完全一样，但是测试条件相反。</p><ul><li>基本语法，直到条件成立才停下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until <span class="built_in">test</span>-commands</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>for</code>语句：从列表/值表中逐一读取值进行操作，直到取完所有的值;</p><ul><li><strong>值表</strong>：一系列以空格分隔的值;</li><li><code>seq</code>:此命令自动接受一个参数n，产生1到n(均包含)的值表;</li><li>基本用法：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> variable [<span class="keyword">in</span> list]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>read</code>:读取用户输入;</p><ul><li>三种模式：<ul><li>(1)接受一个变量名作为参数，从标准输入中接收到的信息存放在该变量中;</li><li>(2)不提供变量名，读取的信息将放在变量<code>REPLY</code>中;</li><li>(3)提供多个变量名作为参数，Bash默认空格、制表符和换行符为分隔符，将输入拆开分别赋值给各变量;</li></ul></li><li><code>read</code>常用来在输出一段内容后暂停，等待用户的下一步指令(如“继续”)。<h3 id="脚本执行命令"><a href="#脚本执行命令" class="headerlink" title="脚本执行命令"></a>脚本执行命令</h3></li></ul></li><li><code>exit</code>：强行退出一个脚本，并向调用脚本的<strong>父进程</strong>返回一个整数值;<ul><li>进程成功运行，返回值是0，非0值表示发生某种异常;</li><li>简要用法是<code>exit n</code>。</li></ul></li><li><code>trap</code>：用于捕捉一个信号，如进程通信中，<em>用于捕捉且忽视一个信号</em>;<ul><li><code>trap</code>要<strong>置于文件首</strong>才能捕获信号;</li><li>常见信号类型用<code>kill -l</code>获取(INT为’Ctrl+c’，EXIT为’Ctrl+D’);</li><li>基本语法<code>trap &#39;commands&#39; SIGNAL</code>。</li></ul></li><li><p><code>&amp;&amp;</code>和<code>||</code>用于创建命令表：命令表利用前一个命令的退出值来控制是否执行另一条命令，命令会被自动识别寻找参数输入。</p><ul><li>3种形式命令表(<code>;</code>顺序命令表已经在<code>if</code>等语句中出现过)：<br>| 表现形式 | 说明 |<br>| — | — |<br>| a&amp;&amp;b | “与”命令表。当且仅当a执行成功，才执行b |<br>| a||b | “或”命令表。当且仅当a执行失败，才执行b |<br>| a;b | 顺序命令表。先执行a，再执行b |</li><li>关于命令的生效范围(见例子)：在脚本中的程序通常是调用子shell完成功能，如果要在执行脚本时对当前shell(即父shell)完成，用<code>source</code>命令。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">dirname=~/LearningNotes/git</span><br><span class="line"><span class="comment">#echo $dirname</span></span><br><span class="line"><span class="built_in">test</span> -d <span class="variable">$dirname</span> &amp;&amp; <span class="built_in">cd</span> <span class="variable">$dirname</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>其他Shell编程工具：</p><ul><li>以下命令均<strong>不改变源文件</strong>;</li><li><code>cut</code>：从输入行中提取指定部分;<ul><li><code>-c</code>:提取一行中指定范围的字符，如<code>cut -c3-6 file_name</code>;</li><li><code>-f</code>:提取指定行中指定的字段，分隔符用<code>-d</code>指定(否则默认使用TAB)，如<code>cut -d&quot; &quot; -f2 file_name</code>截取第2个字段。</li></ul></li><li><code>diff</code>：用于确定两个版本的源文件存在哪些修改;<ul><li>用法:<code>diff file1 file2</code>。</li></ul></li><li><code>sort</code>：以行为输入单位，对其按照字母顺序进行排列;<ul><li><code>-r</code>:默认按字母升序排列，<code>-r</code>使按降序排列;</li><li><code>-k&lt;num&gt;</code>:默认按照第1个字段执行排序，<code>-k</code>可以指定按第<num>字段排序。</num></li></ul></li><li><code>uniq</code>：从<strong>已排好序</strong>的输入行中删除重复的行，通常和<code>sort</code>命令结合管道工作。</li><li><code>tr</code>：按照用户指定方式对字符执行替换，结果输送到标准输出;<ul><li><code>tr &quot;ABH&quot; &quot;HCA&quot; &lt; file</code>：ABH分别替换为HCA;</li><li><code>tr &quot;ABC&quot; &quot;[Z*]&quot; &lt; file</code>/<code>tr &quot;A-C&quot; &quot;[Z*]&quot; &lt; file</code>：替换成”Z”;</li><li><code>tr --delete &quot; &quot; &lt; file</code>:删除空格。</li></ul></li><li><code>wc</code>：用来统计文件中字节、单词和行的数量;<ul><li>常用选项：</li></ul></li></ul></li></ul><table><thead><tr><th>选 项</th><th>描 述</th></tr></thead><tbody><tr><td><code>-c</code>/<code>--bytes</code></td><td>显示字节数</td></tr><tr><td><code>-l</code>/<code>--lines</code></td><td>显示行数</td></tr><tr><td><code>-L</code>/<code>--max-line-length</code></td><td>显示最长一行的长度</td></tr><tr><td><code>-w</code>/<code>--words</code></td><td>显示单词个数</td></tr><tr><td><code>--help</code></td><td>显示帮助</td></tr></tbody></table><ul><li><code>substr</code>：从字符串提取一部分，是shell内建的运算符，<strong>必须使用<code>expr</code>进行表达式求值</strong>;<ul><li>依次接受3个参数：(1)字符串/存放字符串的变量;(2)提取开始的位置(从1开始计数);(3)需要提取的字符数。</li><li>用法：<code>expr substr &quot;Hello World&quot; 1 5</code>。</li></ul></li><li><code>seq</code>：用于产生一个整数数列;<ul><li>只指定结束值：<code>seq &lt;end&gt;</code>产生从1到<num>的数列;</num></li><li>指定开始和结束：<code>seq &lt;start&gt; &lt;end&gt;</code>产生从<start>到<num>的数列;</num></start></li><li>指定开始结束和步长：<code>seq &lt;start&gt; &lt;step&gt; &lt;end&gt;</code>。<h2 id="Shell定制"><a href="#Shell定制" class="headerlink" title="Shell定制"></a>Shell定制</h2></li><li>设置环境变量</li><li>设置别名<h3 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h3></li><li>“环境变量”是一些和当前Shell有关的变量，用于定义特定的Shell行为;</li><li><code>printenv</code>查看当前Shell的所有环境变量。</li><li><code>PATH</code>:搜索路径，是最常用的环境变量之一，这个变量告诉Shell在什么地方查找用户要求执行的程序;\</li></ul></li><li><code>PATH</code>变量用一系列冒号分隔各目录，用户如果没有命令完整路径，Shell会依次在PATH变量指定的目录中查找;</li><li>追加路径：<code>PATH=$PATH:/usr/local/bin</code>;</li><li>shell中修改的变量只在当前shell中有效(所以有配置文件的存在);</li><li>执行本地程序用<code>./program</code>一是为了安全，在安全性要求更高的场合应该输入完全路径;二是因为命令通常在PATH中搜索，所以要加上<code>./</code>目录才能运行。<ul><li><code>alias</code>：设置命令(即程序)别名;</li></ul></li><li>用法:<code>alias ll=&#39;ls -l&#39;</code>。<ul><li>配置文件：shell中运行的命令只是临时有效，要保持长久有效需要将命令输入到配置文件中。</li></ul></li><li><code>~/.bashrc</code>：Shell为每个用户维护了一个配置文件，对当前用户有效，<strong>推荐</strong>;</li><li><code>/etc/bash.bashrc</code>：全局shell配置文件，对所有用户有效。</li><li>用<code>source</code>命令生效。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><em>Linux从入门到精通 刘忆智 著</em></p>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列10-Linux编程</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%9710-VIM/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>Linux下编辑器VIM的操作<ul><li>保存和编辑</li><li>字符串的搜索和替换</li><li>针对程序员的配置</li></ul></li><li>C/C++的编译、运行和调试</li><li>版本管理系统简介<br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="Vim编辑器"><a href="#Vim编辑器" class="headerlink" title="Vim编辑器"></a>Vim编辑器</h2></the></li><li>Vim是Vi的增强版本，在不正式的情况下，两者是一回事。</li><li>Vim是所有UNIX和Linux系统下的标准软件。<h3 id="两种模式-编辑和保存"><a href="#两种模式-编辑和保存" class="headerlink" title="两种模式/编辑和保存"></a>两种模式/编辑和保存</h3></li><li><code>vim file</code>:对文件用vim编辑器进行编辑。如果文件不存在，Vim将自动创建文件。<ul><li><code>vim</code> : 不带参数的vim自动打开编辑器。</li></ul></li><li>vim分为<em>插入</em>和<em>命令</em>两种模式。Vim启动时自动处于命令模式。<ul><li>按’I’键进入插入模式，此模式下可以输入字符;</li><li>按’Esc’键进入命令模式，此模式下执行除了字符操作以外的所有操作，包括保存、搜索、移动光标等。</li></ul></li><li>命令模式下，输入“：”在底部打开一个命令行，此时光标闪烁输入，等待用户输入。</li><li>H、J、K、L分别代表向左、上、下、右移动。当然使用方向键也是可以的。</li><li>O在当前行下插入一行空白行。</li><li><code>w</code>保存，<code>q</code>退出，<code>wq</code>保存且退出，<code>q!</code>强制退出。<h3 id="搜索字符串"><a href="#搜索字符串" class="headerlink" title="搜索字符串"></a>搜索字符串</h3></li><li><code>/string</code>用于搜索一个字符串，输入<code>/</code>后，vim底部也会出现一个命令行。</li><li>vim的搜索可以循环进行，<code>/</code>命令向前(文件尾)查找，<code>？</code>命令向后(向文件头)查找。</li><li>对大小写是否敏感：<ul><li><code>:set ignorecase</code>命令vim忽略大小写;</li><li><code>:set noignorecase</code>命令vim重新开启大小写敏感。<h3 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h3></li></ul></li><li><code>:[range]s/pattern/string/[c,e,g,i]</code>:替换命令的完整语法，将匹配pattern(正则表达式)的字符串替换为string。<ul><li>range规定替换范围，<code>1,4</code>表示1到4行，<code>1,$</code>表示1行到最后一行(全文)，<code>%</code>也表示全文。</li><li>最后方括号内的字符是可选选项，选项含义如下：</li></ul></li></ul><table><thead><tr><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>c</td><td>每次替换前询问</td></tr><tr><td>e</td><td>不显示错误信息</td></tr><tr><td>g</td><td>替换一行中的所有匹配项（通常需要使用,否则替换第一项）</td></tr><tr><td>i</td><td>不区分大小写</td></tr></tbody></table><ul><li>*清除文本文件中的<code>^M</code>字符：由于来自windows环境的源代码对换行符的表述和Linux不一致，因此文末常出现<code>^M</code>符号——虽然对程序编译器和解释器没有影响，但在shell编程时会产生问题，此时用<code>%s/^M$//g</code>删除行末的<code>^M</code>字符。<h3 id="针对程序员的配置"><a href="#针对程序员的配置" class="headerlink" title="针对程序员的配置"></a>针对程序员的配置</h3></li><li>一些常用的配置命令：<ul><li><code>:syntax on</code>打开语法高亮，vim会根据文件扩展名决定哪些为关键字。</li><li><code>:set autoindent</code>设置自动缩进;</li><li><code>:set shiftwidth=4</code>设置自动缩进的空白长度;</li><li><code>:set tabstop=4</code>将tab键缩进设置为4个空格。</li></ul></li><li>为避免每次启动vim都要手动输入命令，可以将命令写入vim的配置文件中(文件中不要包含<code>:</code>)，vim的配置文件为<code>/etc/vim/vimrc</code>(/etc中的文件对系统中所有用户生效)，推荐用户可以新建一个<code>~/.vimrc</code>文件在其中写入配置信息，只对当前用户生效。<ul><li><strong>通常用户个性化的设置文件都是隐藏文件(<code>.</code>开头的文件)，且保存在用户主目录下</strong>。<h3 id="Vim的常用命令总结"><a href="#Vim的常用命令总结" class="headerlink" title="Vim的常用命令总结"></a>Vim的常用命令总结</h3></li></ul></li><li>模式切换：<ul><li><code>a</code>:在光标后插入;</li><li><code>i</code>:在光标所在位置插入;</li><li><code>o</code>：在光标所在位置下一行插入;</li><li><code>Esc</code>:进入命令模式;</li><li><code>:</code>进入行命令模式。</li></ul></li><li>光标移动(名列前加上数字，可以重复多次移动，如<code>5w</code>)：<ul><li><code>h</code>/<code>l</code>/<code>j</code>/<code>k</code>：光标向左/右/上/下移动;</li><li><code>^</code>/<code>$</code>：移动光标到行首/尾;</li><li><code>gg</code>/<code>shift+g</code>:移动光标到文件首/尾;</li><li><code>w</code>/<code>b</code>:移动到下一个/上一个单词;</li><li><code>ctrl+f</code>/<code>ctrl+b</code>:向前(文件尾)/后(文件头)翻动一页。</li></ul></li><li>删除、复制和粘贴：<ul><li><code>x</code>:删除光标所在位置的字符;</li><li><code>dd</code>：删除光标所在行;</li><li><code>shift+d</code>:删除光标所在位置到行尾的所有字符;</li><li><code>d</code>:和移动命令配合使用的删除命令，如<code>dw</code>表示删除光标所在位置到下一个单词之间的所有字符;</li><li><code>yy</code>:复制光标所在行;</li><li><code>y</code>:和移动命令配合使用的复制命令;</li><li><code>shift+p</code>:在光标所在位置粘贴最近复制/删除的内容。</li></ul></li><li>撤销和重做：<ul><li><code>u</code>：撤销一次操作;</li><li><code>ctrl+r</code>:重做被撤销的操作。</li></ul></li><li>搜索和替换：<ul><li><code>:/string</code>：向前搜索字符串string;</li><li><code>:?string</code>：向后搜索字符串string;</li><li><code>:s/pattern/string</code>：将pattern代表的字符串替换成string。</li></ul></li><li>保存和退出：<ul><li><code>:w</code>：保存文件;</li><li><code>:w filename</code>：另存为filename;</li><li><code>:q</code>：退出vim;</li><li><code>:!q</code>：强制退出，放弃保存修改。<h2 id="C-C-的编译-gcc-g"><a href="#C-C-的编译-gcc-g" class="headerlink" title="C/C++的编译(gcc/g++)"></a>C/C++的编译(gcc/g++)</h2></li></ul></li><li>gcc最初是C编译器(GNU C Compiler)，如今支持多种语言编译(GNU Compiler Collection)。</li><li><code>gcc *.c</code>:编译C源文件，默认产生一个可执行文件为<code>a.out</code>;<ul><li><code>gcc -o &lt;outname&gt; *.c</code>:指定产生的可执行文件名字为<code>outname</code>。</li></ul></li><li>*和编译有关的选项：<ul><li><code>-c</code>：只激活预处理、编译和汇编，生成扩展名为.o的目标代码文件(在编写大型程序时必须，存在依赖关系的源代码应首先编译成目标代码，最后连接成可执行文件，超过3个源文件考虑用<code>make</code>);</li><li><code>-S</code>：只激活预处理和编译，并生成扩展名为.s的汇编代码文件;</li><li><code>-E</code>：只激活预处理，并将结果输出至标准输出;</li><li><code>-g</code>：为调试程序(gdb)生成相关信息。</li></ul></li><li>优化选项：gcc提供了从低到高3个级别的优化选项，依次为<code>-O1</code>、<code>-O2</code>、<code>-O3</code>。<ul><li>优化程序越高，效率越高，相应风险越大;</li><li>通常<code>-O2</code>选项可以满足绝大多数优化需求;</li><li>这三个优化级别其实就是对多个优化选项的“打包”。</li></ul></li><li><code>-march=</code>生成只适合特定CPU的二进制代码(一般不使用)。</li><li><code>g++ *.cpp</code>：用g++完成C++程序的编译和连接(<code>gcc</code>可以编译C++源文件，但不能和C++程序使用的库连接)，会自动调用<code>gcc</code>完成对文件的编译;<ul><li><code>-o</code>：同<code>gcc</code>，此选项指定可执行文件名。<h2 id="C程序的调试-gdb"><a href="#C程序的调试-gdb" class="headerlink" title="C程序的调试(gdb)"></a>C程序的调试(gdb)</h2></li></ul></li><li>使用<code>gdb</code>调试C/C++程序之前，要先使用<code>gcc -g</code>生成带有调试信息的可执行程序，否则只有汇编代码存在。</li><li><code>gdb a.out</code>：gdb以可执行二进制文件为参数，对其进行调试，运行后显示提示符(gdb)等待接受用户指令;一些常用指令如下：<ul><li><code>help</code>/<code>help &lt;command&gt;</code>：获取(和特定命令)有关的帮助信息;</li><li>支持<tab>命令补全，当不足以确定唯一命令时，连按两次tab获得所有符合要求的命令;</tab></li><li>支持命令缩写，如<code>h</code>就可以替代<code>help</code>;</li><li><code>list</code>/<code>l</code>:用于查看程序源代码(会自动在源代码前加上行号，每次显示10行，可指定中间行);</li><li><code>search &lt;content&gt;</code>：搜索特定内容，只能向前搜索，不能循环，支持正则表达式;</li><li><code>reverse-search &lt;content&gt;</code>：反向搜索特定内容，向后搜索，支持正则表达式。</li></ul></li><li>断点指令：<ul><li><code>break</code>/<code>b</code>：在指定位置设置断点，可以用行号或函数名做参数;</li><li><code>info break</code>：查看已设置断点信息;</li><li><code>clear</code>：清除当前行断点。</li></ul></li><li>运行程序和单步执行：<ul><li><code>run</code>/<code>r</code>：运行程序至断点;</li><li><code>next</code>/<code>n</code>：单步执行程序，可在后面添加数字n，表<strong>连续执行n行</strong>;</li><li><code>step</code>/<code>s</code>：单步执行，会在遇见函数时进入函数内部，而<code>n</code>只执行调用函数不进入内部;</li><li><code>continue</code>/<code>c</code>：继续运行程序直至遇见下一个断点;</li></ul></li><li>监视变量：<ul><li><code>print</code>/<code>p</code>：打印指定变量的值;</li><li><code>watch</code>/<code>w</code>：设置观察点(可以看作是变量的一种)，以变量名/表达式为参数，一旦参数值发生变化，就停下程序。</li></ul></li><li>临时修改变量：<ul><li><code>set var</code>实现，如<code>set var i=1</code></li></ul></li><li>查看堆栈情况(每次程序调用一个函数，其地址、参数、函数内的局部变量都会被压入栈中)：<ul><li><code>bt</code>实现。</li></ul></li><li>退出gdb：<ul><li><code>quit</code>/<code>q</code>。<h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2></li></ul></li><li>不论是与他人协作还是管理自己的密码，版本控制系统(git和SVN)都是非常好的工具。</li><li>版本控制系统是一套在开发程序时存储源代码所有修改的工具。满足这些需求：<ul><li>集中化管理，自动跟踪单个文件的修改历史;</li><li>完善的日志机制，便于掌握某次修改的原因;</li><li>快速还原到指定的版本;</li><li>协调不同开发者之间的活动，保证对源代码同一部分的改动步互相覆盖。</li></ul></li><li>Subversion相比git，管理人员对开发人员的权利可以作出规范，但git是最好用的版本管理工具。</li><li>git的使用，可以参考我的其他笔记。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><em>Linux从入门到精通 刘忆智 著</em></li></ul>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列9-网络配置和远程访问</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%979-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>连网方式的介绍</li><li><code>ifconfig</code>用于命令行下配置网络</li><li><code>route</code>配置静态路由</li><li>简单计算机网络概念</li><li><code>ftp</code>命令</li><li>基于SSH的文件传输<code>sftp</code>和<code>scp</code></li><li>关于Linux系统的远程登录<br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="连网方式"><a href="#连网方式" class="headerlink" title="连网方式"></a>连网方式</h2></the></li><li>连网方式：<ul><li>局域网(以太网技术，基于载波侦听、多路访问和冲突检测的连网协议);</li><li>无线连接(WPA加密);</li><li>有线宽带连接;<ul><li>DSL(Digital Subscriber Line)指数字用户线路，目前主要使用ADSL，A(asymmetric)表示非对称，即上传和下载速度不同。</li></ul></li><li>拨号上网(Modem)。</li></ul></li><li>局域网：<ul><li>DHCP(动态主机配置协议)：自动获取IP地址、网络掩码、默认网关和域名服务器;</li><li>静态IP：需要手动输入上述内容(<strong>服务器</strong>一般需要设置静态IP)。</li></ul></li><li>ADSL：<ul><li>使用以太网PPPoE(Point to Point Protocol over Ethernet)调制解调器设置实现连接，是一种称作”点到点”的拨号方式;</li><li>连接方式1：network manager,推荐，方便配合IPV6使用;</li><li>连接方式2：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置</span></span><br><span class="line">sudo pppoeconf</span><br><span class="line"><span class="comment"># 开启</span></span><br><span class="line">sudo pon dsl-provider</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">sudo poff dsl-provider</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="命令行下配置网络"><a href="#命令行下配置网络" class="headerlink" title="命令行下配置网络"></a>命令行下配置网络</h2><h3 id="ifconfig配置接口"><a href="#ifconfig配置接口" class="headerlink" title="ifconfig配置接口"></a><code>ifconfig</code>配置接口</h3><ul><li><code>ifconfig</code>：用于启动或禁用一个网络接口，同时设置其IP地址、子网掩码及其他网络选项。</li><li><code>sudo ifconfig eth0 192.168.1.14 netmask 255.255.255.0 up</code>，表示设置网络硬件接口的IP地址(无线网络接口往往以<code>wlan</code>开头),掩码设置，同时启动该网络接口。</li><li><code>sudo eth0 down</code>关闭网络接口。</li><li>网络基础：<ul><li>IP地址：一个长4个字节的二进制数，每个字节用10进制数表示就成了常见的IP地址形式;</li><li>IP地址分为网络部分和主机部分(如N.N.N.H)：<ul><li>网络部分：表示地址所指的逻辑网络;</li><li>主机部分：表示网络中的一台计算机。</li><li>通过对IP地址和子网掩码实施“与”运算，可以将网络号分离出来。</li></ul></li></ul></li><li><code>lo</code>网络接口是“环回网络”，是一个没有实际硬件接口的虚拟网络，<code>127.0.0.1</code>这个环回网络始终指向当前主机，也可以用<code>localhost</code>表示当前主机。<h3 id="用route配置静态路由"><a href="#用route配置静态路由" class="headerlink" title="用route配置静态路由"></a>用<code>route</code>配置静态路由</h3></li><li>路由是定义网络中两台主机间如何通信的一种机制。</li><li>Linux内核中维护着一张路由表，需要发送数据包时，Linux将这个包的目标IP地址和路由表中的路由信息比较。<ul><li>找到匹配项时，该数据包就会发送到这条路由对应的网关，网关负责将数据包转发到目的地;</li><li>找不到匹配项时，数据包会被发送到默认路由指定的网关上;</li><li>总的路线是”数据包–&gt;网关–&gt;目的地”;</li><li><strong>网关就是负责转发的主机，必须处在当前可以直接连接到的网络上(不需要转发)</strong>。</li></ul></li><li><code>netstat -r</code>查看当前系统的路由信息。<ul><li>路由表中网关<code>*</code>表示不需要网关,意味处于同一网络(一般是网络地址，末字节为0);</li></ul></li><li><code>route</code>：用于增加/删除一条路由;<ul><li><code>sudo route add default gw 10.71.84.2</code>表示增加路由表项，一条默认路由;</li><li><code>sudo route add -net 10.62.74.0/24 gw 10.71.84.51</code>增加一条目的网络路由：<ul><li><code>-net</code>表示增加的是网络地址，目的网络;</li><li><code>10.62.74.0/24</code>前部分是网络地址，24表示IP的网络地址占据24位，对应子网掩码是255.255.255.0;</li></ul></li><li><code>-host</code>：用此选项增加一条发往主机地址的路由表项。</li></ul></li><li>一般一个IP代表一台主机。全0主机地址保存为网络地址(整个网络)，全1的主机地址是广播地址(网络中的所有主机)。</li><li><code>del</code>用于删除路由，如<code>sudo route del default</code>。<h3 id="主机和IP间的映射"><a href="#主机和IP间的映射" class="headerlink" title="主机和IP间的映射"></a>主机和IP间的映射</h3></li><li>主机名是为了方便记忆，而数据传送时需要的是IP地址，映射的方法主要有：<ul><li>DNS:网络中存在DNS服务器，当用户发起查询时提供IP地址;</li><li>hosts:文件中指定本地映射关系(<code>localhost</code>和本地主机名对应的IP地址，均为<code>127.0.0.1</code>)。<h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3></li></ul></li><li>PPP协议(Point-to-Point Protocol,点到点协议)是目前应用最广泛的数据传输协议之一。</li><li>PPP建立网络连接的步骤：<ul><li>使用串行调制解调器拨号;</li><li>登录远程主机(通常是运营商的接入服务器);</li><li>启动远程PPP协议引擎;</li><li>将串行端口配置为网络接口。</li></ul></li><li>ADSL使用的PPPoE(PPP over Ethernet)就是PPP的衍生物。</li></ul><h1 id="浏览网页"><a href="#浏览网页" class="headerlink" title="浏览网页"></a>浏览网页</h1><ul><li><code>cookie</code>：<ul><li>在用户浏览网页时，一些服务器会在用户机器的特定目录(由浏览器指定)下存储一些信息用于确定用户的身份(因此用户在不同页面之间切换时，不用重复输入验证信息)，这些信息非常短小，因此被形象地称为<code>cookie</code>;</li><li>cookie由浏览器管理，可以设置失效期限;</li><li>一些恶意程序会窃取保存在cookie中的个人信息，因此定期清理是个好习惯。</li></ul></li><li>RSS(聚合内容，Really Simple Syndication)提供了一种订阅信息的途径：<ul><li>RSS是在线共享内容的一种简易方式，网站通过RSS输出，让用户获取网站内容的最新更新;</li><li>实时书签，自动显示最近更新的文章标题。</li></ul></li><li>Lynx：一款基于文本的浏览器，工作在Shell下。<ul><li>Lynx可以工作在多个操作系统平台上，是GNU/Linux中很流行的console浏览器;</li><li>当图形界面无法使用时，Lynx是个很好的选择;</li><li>访问网站：<code>lynx www.csdn.net</code>直接用lynx打开网址;</li><li>查找字符串：<code>/</code>命令可以打开命令行查找网页中的字符串;</li><li>退出浏览器：<code>q</code>退出;</li><li>下载和保存文件：移动光标使链接高亮显示，按<code>d</code>指示Lynx下载该链接对应文件;<h1 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h1></li></ul></li><li>NFS是Linux间的网络硬盘。<ul><li>NFS目前只用于在Linux和UNIX主机间共享文件系统;</li><li>“推荐”用<code>sudo mount -o rw</code>可读写方式安装文件系统;</li><li>如果要在启动时自动安装文件系统<code>nfs</code>，应配置<code>/etc/fstab</code>文件加上<code>nfs</code>项，运行<code>sudo mount -a -t nfs</code>使配置生效;</li><li>卸载文件系统前应确保没有其他进程在使用该文件系统;</li><li>如果发现进程被占用，用<code>lsof</code>命令查询哪些进程在使用该文件系统;</li><li>如果所有办法都不奏效，用<code>umount -f</code>强制卸载文件系统。</li></ul></li><li>CIFS(Common Internet File System，公共Internet文件系统)是Windows用来”共享”文件的协议机制。</li><li>Samba能够将Windows包含到Linux网络中：<ul><li>Samba提供了对CIFS的实现，用于Linux和Windows主机之间的文件共享;</li><li>安装在Linux主机上的Samba服务器端程序向Windows机器提供Linux共享，Windows主机则不需要安装其他特殊工具。</li></ul></li><li><code>nautilus</code>命令打开Linux下的“文本浏览器”。</li><li>用<code>FTP</code>在Linux系统下载文件：<ul><li>可以用Web浏览器/文件浏览器查看FTP服务器上的文件，只要在地址中加上”ftp://“前缀告诉浏览器要使用FTP协议，但是还是用FTP客户端最方便下载和上传;</li><li><code>FileZilla</code>是对中文编码支持最好的FTP客户端;<ul><li><code>FileZilla</code>在Ubuntu安装源也提供了下载;<ul><li>用户名必须提供主机名、用户名、口令和服务器端口(除主机名外，其他都是可选的);</li><li>服务器端口默认是21;</li><li>如果“用户名”和“口令”两个文本框中留白，则以“匿名用户”登录;</li><li>如果是中文站点，将该站点使用的字符编码填入“站点管理器”——&gt;”字符集”——&gt;“使用自定义的字符集”——&gt;“编码”框内(通常是gbk)。</li></ul></li></ul></li><li><code>ftp</code>命令：是Linux自带的一个命令行的FTP工具，基本可以完成所有基本的FTP操作;<ul><li>登录：<code>ftp [host [port]]</code>;</li><li>匿名连接：用户名应输入<code>anonymous</code>;</li><li>连接服务器：<code>open</code>;</li><li>关闭连接但不退出服务器：<code>close</code>/<code>disconnect</code>;</li><li>删除远程服务器文件：<code>delete &lt;file&gt;</code>;</li><li>远程浏览文件/换路径：与shell命令一致;</li><li>下载一个文件：<code>get &lt;filename&gt;</code>下载文件当前路径;</li><li>下载多个文件：<code>mget &lt;file...&gt;</code>下载多个文件，也可以用通配符指定多个文件;</li><li>上传一个文件/多个文件：<code>put &lt;filename...&gt;</code>;</li><li>关闭交互模式：<code>prompt off</code>;</li><li>改变本地目录：<code>lcd</code>;</li><li>本地执行命令：<code>!</code>在命令前表示本地执行;</li><li>列出所有命令/特定命令：<code>?</code>/<code>? &lt;command&gt;</code>;</li><li>退出：<code>quit</code>/<code>bye</code>。<h3 id="基于SSH的文件传输：sftp和scp"><a href="#基于SSH的文件传输：sftp和scp" class="headerlink" title="基于SSH的文件传输：sftp和scp"></a>基于SSH的文件传输：<code>sftp</code>和<code>scp</code></h3></li></ul></li></ul></li><li><code>sftp</code>：基于<code>SSH</code>的文件传输，和传统FTP沾不上什么关系，<strong>同样支持多用户登录</strong>;<ul><li>用<code>sftp</code>传输有助于保护用户账户和传输安全;</li><li><code>sftp</code>建立连接和上传/下载文件的流程：<ul><li>首先要确保远程主机开启了SSH守护进程，用命令<code>sftp user@&lt;ipaddress&gt;</code>建立连接;</li><li><code>sftp</code>的常见命令与<code>ftp</code>的基本命令大部分一致。</li></ul></li></ul></li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>cd</code></td><td>切换远程所在的目录</td></tr><tr><td><code>ls</code>或<code>dir</code></td><td>显示当前目录下的文件列表</td></tr><tr><td><code>mkdir</code></td><td>建立目录</td></tr><tr><td><code>rmdir</code></td><td>删除目录</td></tr><tr><td><code>pwd</code></td><td>显示当前远程目录</td></tr><tr><td><code>chgrp</code></td><td>修改文件(目录)的属组</td></tr><tr><td><code>chown</code></td><td>修改文件(目录)的属主</td></tr><tr><td><code>chmod</code></td><td>修改文件(目录)的权限</td></tr><tr><td><code>rm</code></td><td>删除文件/目录</td></tr><tr><td><code>rename &lt;oldname&gt; &lt;newname&gt;</code></td><td>修改文件名</td></tr><tr><td><code>exit</code>或<code>bye</code>或<code>quit</code></td><td>关闭sftp客户端程序</td></tr><tr><td><code>lcd</code></td><td>切换本地所在目录</td></tr><tr><td><code>lls</code></td><td>显示本地所在目录下的文件列表</td></tr><tr><td><code>lmkdir</code></td><td>当地新建目录</td></tr><tr><td><code>lpwd</code></td><td>显示当地所在的文件目录</td></tr><tr><td><code>put</code></td><td>上传文件</td></tr><tr><td><code>get</code></td><td>下载文件</td></tr></tbody></table><h3 id="利用SSH通道复制文件-scp"><a href="#利用SSH通道复制文件-scp" class="headerlink" title="利用SSH通道复制文件:scp"></a>利用SSH通道复制文件:<code>scp</code></h3><ul><li>使用<code>scp</code>前应先断开<code>SSH</code>连接。</li><li>从服务器复制文件到本地：<code>scp username@&lt;ip_address&gt;:&lt;remote_file_path&gt; &lt;local_file_path&gt;</code>;</li><li>从本地复制文件到服务器：<code>scp &lt;local_file_path&gt; username@&lt;ip_address&gt;:&lt;remote_file_path&gt;</code>。</li></ul><h1 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h1><h2 id="登录另一台Linux服务器"><a href="#登录另一台Linux服务器" class="headerlink" title="登录另一台Linux服务器"></a>登录另一台Linux服务器</h2><h3 id="SSH登录：命令行登录"><a href="#SSH登录：命令行登录" class="headerlink" title="SSH登录：命令行登录"></a>SSH登录：命令行登录</h3><ul><li><code>OpenSSH</code>：是Linux下最常用的SSH服务器/客户端;所有的Linux发行版都附带此软件(client)，可以直接通过安装源安装;<ul><li>安装OpenSSH：<code>sudo apt install ssh</code>;<ul><li>完成安装后系统会自动启动SSH服务器，同时设置为随系统启动;</li><li>如果服务器没有运行，手工执行带有<code>start</code>参数的<code>ssh</code>脚本，启动SSH服务器程序，<code>sudo /etc/init.d/ssh start</code>(守护进程)。</li></ul></li></ul></li><li>SSH(Secure SHell)：<ul><li>支持多用户同时登录;</li><li>会对用户身份验证，并加密两台主机之间的通信;</li><li>SSH商业化版本为SSH2，开源版本为OpenSSH。</li></ul></li><li>SSH远程登录：<ul><li>仅访问命令行：<code>ssh username@ip_address</code>/<code>ssh -l username ip_address</code>;</li><li>需运行X应用程序：<code>ssh -X</code>启动X转发功能，将远程的X应用程序界面完整传输到本地;</li><li>需指定端口：<code>ssh -p port</code>;</li><li>退出:<code>exit</code>;</li><li>登录后一切操作都发生在远程服务器。</li></ul></li><li>SSH密钥登录：避免每次登录时都需要输入口令;<ul><li>基本原理：<ul><li>产生一对互相匹配的密钥文件(公钥和私钥);</li><li>管理员的PC上保存私钥文件的副本;</li><li>与私钥文件匹配的公钥文件存放在服务器上;</li><li>建立SSH时检查密钥对的匹配性。</li></ul></li><li>操作过程：<ul><li>生成密钥对：<code>ssh-keygen -t rsa</code>在用户主目录下<code>.ssh</code>目录中生成密钥对，<code>id_rsa</code>是私钥文件，<code>id_rsa_pub</code>是公钥文件;</li><li>复制公钥至远程主机：<code>scp &lt;local-ssh&gt;/id_rsa.pub user@ip:&lt;remote-ssh&gt;/authorized_keys</code>。<h3 id="登录X窗口系统：图形化的VNC"><a href="#登录X窗口系统：图形化的VNC" class="headerlink" title="登录X窗口系统：图形化的VNC"></a>登录X窗口系统：图形化的VNC</h3></li></ul></li></ul></li><li><code>VNC</code>用于图形化的远程登录：<ul><li>大部分LInux发行版都附带这个软件的服务器端;</li><li>Ubuntu下，用命令<code>sudo apt install vnc4-common vnc4server</code>安装服务器端程序。</li></ul></li><li>VNC(Virtual Network Computing，虚拟网络计算)：如果要直接从X窗口登录服务器，用VNC登录。<ul><li>服务器端的配置：<ul><li><code>vncserver</code>：运行命令，设置命令，自动在主机用户目录下生成VNC配置文件。</li></ul></li><li>客户端的配置：<ul><li>需要下载特定的客户端的程序如<code>vncviewer</code>;</li><li><code>vncviewer 127.0.0.1:1</code>：登录命令，冒号后数字代表桌面号。<h2 id="从Windows登录Linux"><a href="#从Windows登录Linux" class="headerlink" title="从Windows登录Linux"></a>从Windows登录Linux</h2></li></ul></li></ul></li><li>开源代码的PuTTY使用最为广泛。</li><li>VNC也有Windows版本。<h3 id="登录Windows服务器"><a href="#登录Windows服务器" class="headerlink" title="登录Windows服务器"></a>登录Windows服务器</h3></li><li>Windows上安装<code>VNC Server</code>。</li><li>直接通过RDP协议连接Windows服务器：<ul><li>要确保Windows主机已开启“远程登录”(允许用户远程连接到此计算机)功能;</li><li>登录：<code>rdesktop -u username ip-address</code>在Linux上会显示windows桌面窗口;</li><li>修改端口：RDP协议默认端口是3389，要修改端口在IP地址+冒号<code>:</code>+端口号。</li></ul></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><em>Linux从入门到精通 刘忆智 著</em></p>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列8-进程管理</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%978-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>对进程及其属性的介绍</li><li><code>ps</code>进程监视命令</li><li><code>top</code>命令即时跟踪进程</li><li><code>lsof</code>命令查看占用文件进程</li><li><code>kill</code>命令向进程发送信号</li><li>/PROC文件系统<br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2></the></li><li>下列是一个自动创建进程的badpro程序,会自动打开程序并且创建目录和文件。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line">while echo &quot;I&apos;m making files!!&quot;</span><br><span class="line">do</span><br><span class="line">mkdir adir</span><br><span class="line">cd adir</span><br><span class="line">touch afile</span><br><span class="line"></span><br><span class="line">sleep 2s</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x badpro</span><br><span class="line">$ ./badpro &amp;</span><br></pre></td></tr></table></figure><ul><li><code>ps</code>：查看程序的PID号(PID号用于唯一表示一个进程)。<ul><li><code>ps aux | grep badpro</code>(是将前一个命令的输出作为后一个命令的输入)。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> PID</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ol><li>Linux是一种多用户、多进程的操作系统。</li><li>在Linux的内核中维护着一张表，这张表记录了当前系统中运行的所有进程的各种信息。内核会自动完成对进程的控制和调度。</li><li>进程，是正在运行的程序。<h2 id="进程的属性"><a href="#进程的属性" class="headerlink" title="进程的属性"></a>进程的属性</h2></li></ol><ul><li><code>PID</code>:进程的ID号;<ul><li>Linux自己使用PID确定进程，也要求用户在管理进程时提供相应的PID号;</li><li>几乎所有进程管理工具都使用PID而不是进程名。</li></ul></li><li><code>PPID</code>:父进程的PID;<ul><li>Linux中，所有的进程都必须由另一个进程创建——除了在系统引导时，直接由内核主动创建并安装的几个进程。当一个进程被创建时，创建它的那个进程被称为<strong>父进程</strong>，而这个进程就叫做<strong>子进程</strong>。子进程应该是其父进程的克隆体。</li></ul></li><li><code>UID</code>:真实用户ID;<ul><li>只有进程的创建者和root用户才有权利对该进程进行操作,于是记录一个进程的创建者(也就是属主)就显得非常必要，进程的UID就是其创建者的用户ID号，用于标识进程的属主。</li></ul></li><li><code>EUID</code>:有效的用户ID<br>-Linux还为进程保存一个”有效用户ID号”，被称作EUID，用来确定进程对某些资源和文件的访问权限。绝大部分情况下，进程的UID和EUID是一致的——除了著名的<code>SETUID</code>程序。</li><li>允许用户修改密码的命令<code>passwd</code>命令就是一个典型的<code>SETUID</code>程序，其UID是当前执行这个命令的用户ID，而EUID是root用户的ID(也就是0)。</li><li>GID和EGID：真实和有效的组ID;<ul><li>EGID可能在确定访问权限方面还发挥了一定作用</li></ul></li><li>谦让度和优先级;<ul><li>进程的优先级决定了其受到CPU优待的程度，优先级高的进程可以更早地被处理，并获得更多的处理器时间;</li><li>决定进程何时被处理是内核的事情，不用用户插手，但用户可以设置进程的谦让度来影响内核的想法。<h2 id="监视进程-ps命令"><a href="#监视进程-ps命令" class="headerlink" title="监视进程: ps命令"></a>监视进程: ps命令</h2></li></ul></li><li><code>ps</code>是最常用的监视进程的命令。</li><li><code>ps aux</code>命令用于现实当前系统上运行的所有进程的信息。其中部分行代表的信息是</li></ul><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>USER</td><td>进程创建者的用户名</td></tr><tr><td>PID</td><td>进程的ID号</td></tr><tr><td>%CPU</td><td>进程占用CPU的百分比</td></tr><tr><td>%MEM</td><td>进程占用内存的百分比</td></tr><tr><td>VSZ</td><td>进程占用的虚拟内存大小</td></tr><tr><td>RSS</td><td>内存中页的数量(页是管理内存的单位，在PC上通常为4K)</td></tr><tr><td>TTY</td><td>进程所在终端的ID号</td></tr><tr><td>STAT</td><td>进程状态，常用字母代表含义如下：<br><code>R</code> 正在运行/可运行  <code>D</code> 睡眠中(不可被唤醒，通常是在等待I/O设备)<br> <code>S</code> 睡眠中（可以被唤醒） <code>T</code> 停止（由于受到信号或被跟踪）<br> <code>Z</code> 僵进程（已经结束而没有释放系统资源的进程）<br>————<br>常用的附加标志有：<br> <code>&lt;</code> 进程拥有比普通优先级高的优先级<br><code>N</code> 进程拥有比普通优先级低的优先级<br><code>L</code> 有些页面被锁在内存中<br><code>s</code> 会话的先导进程</td></tr><tr><td>START</td><td>进程启动时间</td></tr><tr><td>TIME</td><td>进程已经占用的CPU时间</td></tr><tr><td>COMMAND</td><td>命令和参数</td></tr></tbody></table><ul><li><code>ps</code>的另一组选项<code>lax</code>可以提供PPID和谦让度(NI)。<ul><li>另<code>ps lax</code>不显示进程属主的用户名，因此可以提供更快的运行速度(<code>ps aux</code>需要把UID转化为用户名之后才输出)。<h2 id="即时跟踪进程信息：top命令"><a href="#即时跟踪进程信息：top命令" class="headerlink" title="即时跟踪进程信息：top命令"></a>即时跟踪进程信息：top命令</h2><code>ps</code>命令可以一次性给出当前系统中进程信息的快照，但如果管理员需要实时监视进程运行情况，就可以运行<code>top</code>命令即时跟踪当前系统中进程的情况。<br><code>top</code>命令显示的信息会占满一页，且在默认情况下每10s更新一次。使用CPU最多的程序会排在前面，用<code>h</code>查看帮助，<code>q</code>推出。<h2 id="查看占用文件的命令：lsof"><a href="#查看占用文件的命令：lsof" class="headerlink" title="查看占用文件的命令：lsof"></a>查看占用文件的命令：lsof</h2></li></ul></li><li>不带任何参数的<code>lsof</code>命令会列出当前系统中所有打开文件的进程信息。</li><li>用文件名作为参数，可以查看占用该文件的进程。<h2 id="向进程发送信号：kill"><a href="#向进程发送信号：kill" class="headerlink" title="向进程发送信号：kill"></a>向进程发送信号：kill</h2><code>kill</code>命令用来向进程发送一个信号，这个信号是什么由用户指定。默认发送的是<code>TERM</code>信号，这个信号表示请求终止某项操作。</li><li><p>标准用法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [-signal] pid</span><br></pre></td></tr></table></figure></li><li><p>信号及其编号用<code>kill -l</code>查看(INT为’ctrl+c’)。</p></li></ul><table><thead><tr><th>信号编号</th><th>信号名</th><th>描 述</th><th>默认情况下执行的操作</th></tr></thead><tbody><tr><td>0</td><td>EXIT</td><td>程序退出时收到该信号</td><td>终止</td></tr><tr><td>1</td><td>HUP</td><td>挂起</td><td>终止</td></tr><tr><td>2</td><td>INT</td><td>中断</td><td>终止</td></tr><tr><td>3</td><td>QUIT</td><td>退出</td><td>终止</td></tr><tr><td>9</td><td>KILL</td><td>杀死</td><td>终止</td></tr><tr><td>11</td><td>SEGV</td><td>段错误</td><td>终止</td></tr><tr><td>15</td><td>TERM</td><td>软件终止</td><td>终止</td></tr></tbody></table><p><em>hints</em>:信号名前缀<code>SIG</code>是可以省略，即 <code>kill -SIGTERM pid</code>和<code>kill -TERM pid</code>都是一样的。</p><ul><li><strong>注意</strong>：<code>kill</code>命令<em>不一定</em>可以终止一个进程，既然<code>kill</code>命令向进程发送一个信号，这个信号就能被程序捕捉，程序可以“封锁”或者“忽略”捕捉到的信号。只有在信号没有被程序捕捉的情况下，系统才会执行默认操作。比如可以加入<code>trap &quot;&quot; TERM</code>来忽略TERM信号。</li><li><strong><code>KILL</code>信号永远不能被程序所捕捉</strong>，<code>KILL</code>信号可以在内核级别杀死进程。<code>kill -SIGTERM pid</code>或<code>kill -TERM pid</code>或<code>kill -9 pid</code>。<br>也有<code>KILL</code>信号都不能影响的进程，常常是由一些退化的I/O（输入/输出）虚假锁定造成的。此时，重新启动系统是唯一的解决办法。<h2 id="调整进程的谦让度：nice和renice"><a href="#调整进程的谦让度：nice和renice" class="headerlink" title="调整进程的谦让度：nice和renice"></a>调整进程的谦让度：nice和renice</h2></li><li><code>nice</code>命令可以在启动程序时设置其谦让度,调整的是“相对”谦让度值。<ul><li>用不带参数的<code>nice</code>的命令查看默认谦让度值，一般是0。</li></ul></li><li><code>renice</code>命令在程序运行时调整其谦让度值，调整的是“绝对”谦让度值。</li><li>高谦让度表示低优先级，低谦让度(尤其是负数)的程序会占用更多的CPU时间，拥有更高的优先级。</li><li>新进程一般将从其父进程那里继承谦让度。为保证低优先级的进程不会派生出高优先级的进程，允许进程的属主提高其谦让度（降低优先级），但不能降低谦让度。<strong>但是root用户可以任意设置进程的优先级</strong>。<h2 id="PROC文件系统"><a href="#PROC文件系统" class="headerlink" title="/PROC文件系统"></a>/PROC文件系统</h2></li><li><code>/proc</code>目录下存放了内核有关系统状态的各种有意义的信息。<ul><li>在系统运行时，内核会随时向这个目录写入数据。<code>ps</code>和<code>top</code>命令就是从此目录中读取数据的。</li><li>实际上，这是操作系统向用户提供的一条通往内核的通道，用户甚至可以通过向/PROC目录下的文件写入数据来修改操作系统参数。</li><li>内容说明：<ul><li>以数字命名的目录存放着对应进程的信息。/proc/1包含进程init的信息，由内核在系统启动时创建，是除了那个时候同时创建的几个内核进程之外所有进程的父进程。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><em>Linux从入门到精通 刘忆智 著</em></li></ul></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列7-用户与用户组管理</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%977-%E7%94%A8%E6%88%B7%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>用户的管理(增加、删除、修改和切换)</li><li>用户组的管理</li><li>用户和组的配置文件<code>/etc/shadow</code>、<code>/etc/passwd</code>、<code>/etc/group</code></li><li>记录用户历史操作命令<code>history</code><br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li><li>Linux作为一种多用户的操作系统(服务器系统)，允许多个用户同时登陆到系统上，并响应每个用户的请求;</li><li>系统管理员的非常重要的工作之一是管理用户，包括：<ul><li>添加和删除用户;</li><li>分配用户主目录;</li><li>限制用户权限。<h2 id="用户与用户组基础"><a href="#用户与用户组基础" class="headerlink" title="用户与用户组基础"></a>用户与用户组基础</h2></li></ul></li><li>Linux识别多用户的流程：<ul><li>用户提供用户和密码，经过验证后登录到系统;</li><li>Linux为每一个用户启动一个进程，然后由这个进程接受用户的各种请求;</li><li>建立用户时，需要限定其权限(root用户拥有所有权限<code>sudo -s</code>)，如不能修改配置文件，不能查看其他用户目录等;</li><li>被划分为一个用户组的用户默认拥有用户组权限。</li></ul></li></ul><h2 id="用户和组的添加useradd、groupadd"><a href="#用户和组的添加useradd、groupadd" class="headerlink" title="用户和组的添加useradd、groupadd"></a>用户和组的添加<code>useradd</code>、<code>groupadd</code></h2><ul><li><code>useradd</code>：创建新用户;<ul><li>默认情况下，不带<code>-m</code>参数的<code>useradd</code>命令不为新用户建立主目录，此时用户可以登录到系统Shell，但不能登录到图形界面;</li><li><code>-g</code>：参数用于指定用户所属的组，不带<code>-g</code>参数时默认为新用户创建同名用户组，然后将新用户归入该组;</li><li><code>-s</code>：指定用户登录后使用的Shell(目录)，否则默认使用<code>sh</code>;</li><li>创建流程:(1)先创建用户名<code>useradd username</code>;(2)创建密码<code>passwd username</code>。</li></ul></li><li><code>groupadd</code>：增加用户组，<code>groupadd groupname</code>。<h3 id="记录用户操作history"><a href="#记录用户操作history" class="headerlink" title="记录用户操作history"></a>记录用户操作<code>history</code></h3></li><li>Shell会记录用户的每一条命令。</li><li><code>history</code>：列出所有使用过的命令并加以编号;<ul><li><code>history</code>命令只在bash中适用;</li><li>历史命令记录被存在用户主目录下的<code>.bash_history</code>中，该文件默认可以存储1000条命令记录;</li><li><code>history &lt;num&gt;</code>:列出最近<num>次输入的命令;</num></li><li><code>history</code>列出当前用户的命令历史，查看其他用户命令应到其主目录的<code>.bash_history</code>查看。<h3 id="passwd和shadow文件"><a href="#passwd和shadow文件" class="headerlink" title="passwd和shadow文件"></a>passwd和shadow文件</h3></li></ul></li><li>Linux中做的一切基本配置最终都会反映到配置文件，包括用户管理。</li><li><code>/etc/passwd</code>:登记所有用户信息;</li><li><code>/etc/shadow</code>:保存用户的登录密码(加密);</li><li>直接修改配置文件也可以实现用户管理。<h2 id="删除用户userdel"><a href="#删除用户userdel" class="headerlink" title="删除用户userdel"></a>删除用户<code>userdel</code></h2></li><li><code>userdel</code>:用于删除用户帐号;<ul><li>默认情况下，不删除用户主目录;</li><li><code>-r</code>:删除用户帐号，同时删除用户主目录;<h2 id="管理用户帐号usermod"><a href="#管理用户帐号usermod" class="headerlink" title="管理用户帐号usermod"></a>管理用户帐号<code>usermod</code></h2></li></ul></li><li><code>usermod</code>常用选项及含义：</li></ul><table><thead><tr><th>选 项</th><th>含 义</th></tr></thead><tbody><tr><td><code>-d</code></td><td>修改用户主目录</td></tr><tr><td><code>-e</code></td><td>修改帐号的有效期限(MM/DD/YY)</td></tr><tr><td><code>-g</code></td><td>修改用户所属的组</td></tr><tr><td><code>-l</code></td><td>修改用户帐号名称</td></tr><tr><td><code>-s</code></td><td>修改用户登录后所使用的shell</td></tr></tbody></table><ul><li>同样可以通过修改配置文件<code>/etc/passwd</code>、<code>/etc/shadow</code>和<code>/etc/group</code>来修改用户信息。<h2 id="查看用户信息id"><a href="#查看用户信息id" class="headerlink" title="查看用户信息id"></a>查看用户信息<code>id</code></h2></li><li><code>id</code>：查看用户信息;<ul><li>以用户名作参数，查看用户的UID、GID及所属组;</li><li>不带参数，则显示当前登录用户的信息。<h2 id="用户间切换su"><a href="#用户间切换su" class="headerlink" title="用户间切换su"></a>用户间切换<code>su</code></h2></li></ul></li><li>ubuntu使用<code>sudo -s</code>或<code>/bin/su</code>(绝对路径更为安全)来获得root权限。</li><li><code>su username</code>：用于切换用户。<h2 id="受限的特权sudo"><a href="#受限的特权sudo" class="headerlink" title="受限的特权sudo"></a>受限的特权<code>sudo</code></h2></li><li>root权限是不可分隔的，<strong>其他用户</strong>要获取某个特权时采用<code>sudo</code>命令;</li><li>使用流程：<ul><li><code>sudo</code>会首先要求用户输入用户自己的口令;</li><li>用户在在一段时间内(5分钟)没有再次使用<code>sudo</code>，就必须再次输入口令。</li></ul></li><li><code>/etc/sudoers</code>指定用户可以执行的特权命令;<ul><li><code>root ALL=(ALL) ALL</code>指定root用户可以使用<code>sudo</code>在任何机器上(1st ALL)以任何用户身份(2nd ALL)执行任何命令(3rd)，无括号时以root身份执行;</li><li><code>%admin</code>:替代所有属于admin组的用户，Ubuntu安装时创建的用户自动加入<code>admin</code>组。</li></ul></li><li><code>sudoer</code>的每行包含下面内容：<ul><li>该权限适合的用户;</li><li>这一行配置在哪些主机上适用;</li><li>该用户可以运行的命令;</li><li>该命令以那个用户身份执行。</li></ul></li><li><code>sudo -u</code>可以以其他用户身份执行命令。</li><li><code>visudo</code>：修改sudoers文件时使用的命令。<h2 id="etc-passwd文件"><a href="#etc-passwd文件" class="headerlink" title="/etc/passwd文件"></a>/etc/passwd文件</h2></li><li>早期所有信息都在<code>/etc/passwd</code>中，后来出于安全考虑，加密口令转移到<code>/etc/shadow</code>。</li><li><code>/etc/passwd</code>中每一行代表一个用户，每一行由7个字段组成，使用冒号分隔;<ul><li>登录名;</li><li>口令占位符;</li><li>用户ID(UID);</li><li>默认组ID号(GID);</li><li>用户私人信息;</li><li>用户主目录;</li><li>登录shell。</li></ul></li><li>口令占位符代表算法加密，且口令放置在<code>/etc/shadow</code>中。</li><li>Linux上使用最广泛的算法是MD5，MD5加密后长度是一个固定值(34个字符)。加密过程中，MD5算法会随机加入称作”salt”的数据，使一个口令可以对应多个不同的加密后形式。</li><li>常用加密算法通过前缀识别;<ul><li>MD5算法以”$1$”开头;</li><li>Blowfish算法以“$2a$”开头。</li></ul></li><li>UID号：用于唯一标识系统中的用户。<ul><li>是一个32位无符号整数;</li><li>root用户的UID为0。</li><li>虚拟用户(bin/daemon)被分配到比较小的UID号，通常安排在<code>passwd</code>文件的开头;</li><li>真实用户的UID号一般从比较大的数开始，这样可以为虚拟用户提供足够的余地(本机从1000开始)。</li></ul></li><li>GID号：指定用户登录时默认所在的组;<ul><li>一个32位整数;</li><li>root组的GID号为0;</li><li>在<code>/etc/group</code>中定义。<h2 id="etc-shadow文件"><a href="#etc-shadow文件" class="headerlink" title="/etc/shadow文件"></a>/etc/shadow文件</h2></li></ul></li><li><code>/etc/shadow</code>存放加密后的用户口令。</li><li><code>/etc/shadow</code>文件的每一行代表一个用户，并以冒号分隔每一个字段，每个字段的含义如下;<ul><li>登录名;</li><li>加密后口令； </li><li>上次修改口令日期;</li><li>两次修改口令之间的天数(最少);</li><li>两次修改口令之间的天数(最多);</li><li>提前多少天提醒用户修改口令;</li><li>在口令过期多少天后禁用该用户;</li><li>帐号过期的日期(<code>usermod</code>);</li><li>保留，为空。</li><li><strong>绝对日期</strong>是从1970.1.1至今的天数。<h2 id="etc-group文件"><a href="#etc-group文件" class="headerlink" title="/etc/group文件"></a><code>/etc/group</code>文件</h2></li></ul></li><li><code>/etc/group</code>文件中保存系统所有组的名称，及每个组的成员列表;</li><li>文件每一行表示一个组，由4个冒号分隔的字段组成，含义分别是：<ul><li>组名;</li><li>组口令占位符(如果口令字段是一个<code>x</code>，表示还有一个<code>/etc/gshadow</code>文件用于存放口令);</li><li>GID号;</li><li>成员列表，逗号分开，不能有空格。</li></ul></li><li>应该保证GID的唯一性。</li><li>实际上用户所属组是<code>/etc/group</code>和<code>/etc/passwd</code>中相应组的并集。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><em>Linux从入门到精通 刘忆智 著</em></li></ul>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列6-磁盘管理</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%976-%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>Linux文件系统简介</li><li>文件系统挂载/卸载(含命令)</li><li>磁盘管理命令</li><li>打包和压缩工具<code>gzip`</code>tar`等</li><li>安装硬盘和分区的操作<br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li><li>目前的电脑几乎都是SATA硬盘，即串口硬盘，在Linux被标识为sd[a-z]，分区从1开始，Grub中被表示为hd[0-…]，分区从0开始标识。<h2 id="Linux文件系统简介"><a href="#Linux文件系统简介" class="headerlink" title="Linux文件系统简介"></a>Linux文件系统简介</h2></li><li><strong>文件系统</strong>：是一种对物理空间的组织方式，通常在<em>格式化硬盘时创建</em>。<ul><li>Windows下，有NTFS和FAT两种文件系统;</li><li>Linux下：<br>| 文件系统 | 简 介 |<br>| ext3fs(2nd Extended File System) | 过去很长一段时间是Linux的主流文件系统<br>目前已被ext4取代 |<br>| ext4fs(3rd Extended File System) | 是对ext3的扩展和改善，应灾难恢复的需求增加了<em>日志功能</em><br>ext4专门预留一块区域保存日志文件<br>当对文件进行写操作时，修改首先写入日志文件，再写入记录标志日志项的结束<br>完成以上操作时，才会对文件系统作实际的修改。<br>因此可以在系统崩溃后用日志恢复文件系统 |</li></ul></li><li><strong>Swap并不是一种文件系统</strong>。swap交换分区是一种特殊的硬盘空间，当实际内存不够用时，会将内存中暂时不用的数据放在交换空间中，从而为当前运行的程序腾出足够的内存空间。<em>Windows中这个概念叫“虚拟内存”</em>。<ul><li>操作系统的这种调度使程序可以使用的内存远大于物理内存;</li><li>硬盘空间价格比RAM低廉;</li><li>但频繁读取硬盘会显著降低系统运行速度。</li><li>swap分区大小主要取决于物理内存大小（理论上要大于物理内存大小），一般设置为2GB即可。<h2 id="文件系统挂载-含命令"><a href="#文件系统挂载-含命令" class="headerlink" title="文件系统挂载(含命令)"></a>文件系统挂载(含命令)</h2></li></ul></li><li><p>对于某些外接设备，还有当你想在Linux下查看Windows分区中的时候，需要手动挂载设备。我以挂载windows中分区为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l /dev/sda <span class="comment"># 查看所有分区，在此查找win的引导分区位置,显示为/dev/sda1</span></span><br><span class="line">sudo mkdir /mnt/win</span><br><span class="line">sudo mount /dev/sda1 /mnt/win</span><br><span class="line"><span class="built_in">cd</span> /mnt/win</span><br><span class="line">ls <span class="comment"># 就可以看到已经能访问win分区中的内容了</span></span><br><span class="line"><span class="built_in">cd</span> ~ <span class="comment"># 先退出目录才能进行卸载，否则提示设备忙并拒绝卸载</span></span><br><span class="line">sudo umount /mnt/win</span><br></pre></td></tr></table></figure></li><li><p>Linux中每个设备都被映射为一个特殊文件(Linux中一切都是文件)，称为“设备文件”，对设备的操作通过读写文件实现。</p></li><li>Linux把所有的设备文件都放在/dev目录下。</li><li>因此文件系统挂载可以这么理解：/dev下记录了所有存在的物理设备，但是只有挂载到Linux目录下，这些文件才能被访问。</li><li><code>mount</code>:文件系统挂载命令，常用格式<code>mount &lt;source&gt; &lt;directory&gt;</code>,<ul><li><code>mount -r</code>:以只读模式挂载文件系统;</li><li><code>mount -w</code>:以可读写模式挂载设备。</li></ul></li><li>系统启动时要挂载的文件系统信息在<code>/etc/fstab</code>文件中规定，依次包括这些项：<ul><li>用于挂载每个文件系统的UUID(Universally Unique Identifier,通用唯一标志符，一个128bits数字，用于唯一确定互联网上的一件东西)，此处用于指代设备名/分区;</li><li>挂载点; </li><li>文件系统类型;</li><li>各种挂载参数;</li><li>备份频度;</li><li>重启动过程中文件系统的检查顺序。</li></ul></li><li><code>umount</code>:卸载文件系统，Linux规定文件系统只有在<em>没被使用时才可以被卸载</em>。<ul><li><code>umount -r</code>：指导umount在无法卸载文件系统的情况下，采用只读方式重新载入。 </li></ul></li><li><code>df</code>:收集和整理当前已挂载文件系统的重要统计数据。<ul><li><code>df -t</code>:用于显示特定文件系统，如<code>df -t ext4</code>。</li></ul></li><li><code>fsck</code>:检查和修复文件系统。对于小的损坏可以很好地解决问题，可以快速执行检查并将日志回滚到上一次正常状态中，但是<strong>存在风险</strong>。<ul><li><code>fsck -p</code>：根据fstab文件确定检查哪些文件系统，按其中指定的顺序升序检查。<em>通常会在硬盘启动时自动执行</em>。</li></ul></li><li><code>mkfs</code>：在目标盘上建立文件系统(即格式化)。常用格式mkfs [-t <type>] [fs-options] <device>。<ul><li><code>mkfs -c</code>：用于检查制定设备上损坏的块，如<code>sudo mkfs -t ext4 -c /dev/sdb1</code></li><li>硬盘分区在格式化之前必须先卸载。</li></ul></device></type></li><li>Linux会将USB设备识别为第一个没有被硬盘占用的SCSI设备，因此可以从<code>/dev/sd[a-z][1-...]</code>挂载。<ul><li><code>lsusb</code>：可以列出当前内核已经发现的USB设备。<h2 id="打包和压缩工具"><a href="#打包和压缩工具" class="headerlink" title="打包和压缩工具"></a>打包和压缩工具</h2></li></ul></li><li><code>gzip</code>:Linux下使用最广泛的压缩/解压缩工具，gzip会给文件加上<code>gz</code>扩展名;<code>.tar.gz</code>是Linux世界最流行的压缩文件格式，即首先用tar打包，再用gzip压缩的文件格式。<strong>压缩后会删除原来的文件。</strong><ul><li><code>gzip filename.tar</code>就完成了对文件的压缩;</li><li><code>gzip -d</code>：压缩文件解压;</li><li><code>gzip -l</code>：查看压缩效果;</li><li><code>gzip -t</code>：测试压缩文件的完整性。</li><li><code>gunzip</code>:也是解压缩工具。</li></ul></li><li><code>bzip2</code>：以压缩速度为代价，提供比gzip更高的压缩率。<code>bzip2</code>的使用方法基本和<code>gzip</code>一致，压缩后文件带<code>.bz2</code>后缀。<ul><li><code>bzip2 -d</code>/<code>bunzip2</code>：用于解压缩文件;</li><li><code>bzip2 -tv</code>：检查文件完整性并返回信息。<br><br></li></ul></li><li><code>tar</code>：Linux中最著名的文件打包工具，读取多个文件和目录，并将它们打包成一个文件。<strong>并不删除原来的文件</strong>。<ul><li><code>tar -cvf &lt;target&gt; &lt;source&gt;</code>:<code>c</code>指导创建归档文件,<code>v</code>用于现实命令执行过程，<code>f</code>制定归档文件名，余下参数指定要打包的文件和目录;</li><li><code>tar -xvf</code>：<code>x</code>表示提取文件;</li><li><code>tar -xzvf</code>：<code>z</code>选项让tar自动调用gzip程序完成相关操作，先gzip解压缩，再用tar解包;</li><li><code>tar -czvf</code>：先tar打包，再gzip压缩;</li><li><code>-j</code>：此参数调用bzip2程序;</li><li>tar命令选项前的<code>-</code>可以省略。</li></ul></li><li><code>dd</code>：转化和复制文件。<ul><li><code>dd if=/dev/cdrom of=CD.iso</code>:if规定输入端，of指定输出端，将CD内容转化为镜像文件。<h2 id="安装硬盘和分区-进阶"><a href="#安装硬盘和分区-进阶" class="headerlink" title="安装硬盘和分区(进阶)"></a>安装硬盘和分区(进阶)</h2></li></ul></li></ul><ol><li><code>fdisk</code>：Linux用于建立/查看分区表的工具，请不要在当前硬盘上实验导致删除整个系统;<ul><li><code>fdisk -l</code>查看分区表;</li><li><code>fdisk /dev/sdb</code>：在指定硬盘上建立分区;</li><li>此交互式工具中常用的命令如下：</li></ul></li></ol><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>new/n</td><td>创建新分区</td></tr><tr><td>print/p</td><td>显示当前分区设置</td></tr><tr><td>type/t</td><td>设置分区类型(建立swap时使用)</td></tr><tr><td>write/w</td><td>把分区表写入硬盘</td></tr></tbody></table><ul><li><code>fdisk</code>在分区完全确定之后，用<code>write</code>才会将设置写入分区表中，否则还可以<code>delete</code>删除分区。<ol><li>分区表建立完成后用<code>mkfs</code>在各分区上建立文件系统。</li><li>用<code>fsck</code>检查文件系统。</li><li>将硬盘挂载到目录下，用<code>df</code>测试分区。</li><li>对交换空间分区执行<code>mkswp &lt;par&gt;</code>和<code>swapon &lt;par&gt;</code>分别进行初始化和激活。</li></ol></li><li><code>swapon -s</code>:可以查看当前交换空间分区的信息。、<ol><li>配置/etc/fstab文件，加入新分区，使开机自动加载文件系统。</li><li>如果文件系统出问题，系统将不能正常启动，而会引导进入救援模式，依次进行下述手段：</li></ol></li><li><code>fsck</code>检查并修复受损文件系统;</li><li>如果问题仍在，<code>mkfs</code>重建文件系统;</li><li>最后尝试<code>fdisk</code>重建分区表。</li><li>但是，总是可以通过注释掉fstab中对应行解决新建分区后不能正常启动的问题。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><em>Linux从入门到精通 刘忆智 著</em></li></ul>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列5-软件包管理</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%975-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>什么是软件包</li><li>介绍<code>dpkg</code>软件包管理工具</li><li>介绍<code>apt</code>高级软件包管理工具和相关命令</li><li>从源码编译安装的基本流程<br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2></the></li><li>软件包是将应用程序、配置文件和管理数据打包的产物，常用的软件包格式有两种：<ul><li>rpm(Red Hat Package Manager)：适用SUSE、Red Hat、Fedora等;</li><li>deb：适合Debian和Ubuntu。</li></ul></li><li>使用软件包系统安装软件同样需要考虑依赖性问题，只有依赖的所有库和支持都已经正确安装好了，软件才能被正确安装。</li><li>高级软件包管理工具可以简化软件包的安装过程，常见的通用版本有<strong>APT</strong>和<strong>yum</strong>(其中yum只能用于RPM)。职责：<ul><li>简化定位和下载软件包的过程; </li><li>自动进行系统更新和升级;</li><li>方便管理软件包的依赖关系。</li></ul></li><li><code>dpkg</code>:管理.deb软件包。<code>dpkg --force</code>忽略依赖问题强制安装，一般应避免这种做法。<ul><li><code>dpkg -i</code>：安装且卸载旧版本;</li><li><code>dpkg -l</code>：列出符合模式的安装包;</li><li><code>dpkg -r</code>：删除，可能包含其他软件依赖的库和数据文件导致严重后果;</li><li><code>dpkg -S</code>：搜索所安装的文件向系统复制了哪些内容;</li></ul></li><li>rpm和dpkg软件管理包的出现大大减少了安装软件的工作量，但是不能有效解决依赖性问题。<h2 id="高级软件包工具：APT"><a href="#高级软件包工具：APT" class="headerlink" title="高级软件包工具：APT"></a>高级软件包工具：APT</h2></li><li>APT,Advanced Package Tool，高级软件包工具。适合rpm格式和deb格式。</li><li>以前APT工具最常用命令：<ul><li><code>apt-get</code>:用于执行和软件包安装有关的所有操作;</li><li><code>apt-cache</code>:主要用于查找软件包的相关信息。</li><li><code>apt</code>：用于软件包管理和查询等，<strong>可以执行上述两条命令的所有功能</strong>,但更适合交互。用<code>apt -h</code>查看<code>apt</code>的简要用法。</li></ul></li><li>安装软件：<ul><li>系统第一次启动时，需要运行<code>apt update</code>更新当前<code>apt</code>缓存中的软件包信息;</li><li>建议每一次安装前都运行<code>apt update</code>以确保获得的软件包是最新的;</li><li>[optional]用<code>apt search</code>或<code>apt list</code>搜索需要的软件包名字，用<code>apt depends</code>查看需要依赖的包;</li><li><code>sudo apt install</code>安装软件包，需要root的原因是安装过程需要将文件复制到某些系统文件夹中。</li></ul></li><li><em>安装源</em>是所有apt用于下载软件的地址，被放在/etc/apt/sources.list中，其中内容包括:<ul><li>deb和deb-src：表示软件包的类型，src表示源码。如果是RPM的软件包，应是rpm和rpm-src;</li><li>URL:HTTP、FTP服务器或CD-ROM的地址，表示从哪获得软件包;</li><li>其他：表示软件包的发行版本和分类，用于帮助<code>apt</code>遍历软件库。</li></ul></li><li>暂时禁止一个安装源时，应考虑先注释掉。<h2 id="进阶：从源代码编译软件"><a href="#进阶：从源代码编译软件" class="headerlink" title="进阶：从源代码编译软件"></a>进阶：从源代码编译软件</h2></li><li>某些情况下，编译源码安装软件是唯一的选择：<ul><li>某些厂商没有提供为此发行版提供二进制软件包;</li><li>软件的源代码经过修过，必须重新编译;</li><li>从源代码编译软件通常能让编译者获得更多控制，例如软件安装位置，开启和禁用功能。<br>编译流程：</li></ul><ol><li>源代码安装软件前的配置：<ul><li>首先要仔细阅读安装文档如README或INSTALL;</li><li>Linux上所有的软件都使用<code>configure</code>这个脚本来配置以源代码形式发布的软件;</li><li>configure依据设置参数生成相应的makefile，指导make命令编译源代码;</li><li>一般configure脚本提供一个–prefix选项，用于指定软件安装位置，如<code>./configure --prefix=</code>;</li><li>将软件安装在/usr/local下是一个好习惯，可以同安装在/usr下的系统工具区分开来。</li></ul></li><li>执行<code>make</code>，make是一个高级编译工具，依据makefile文件中的规则调用合适的编译器编译源码;</li><li><code>make install</code>安装软件。<ul><li>出错时应多参考论坛。</li></ul></li></ol></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><em>Linux从入门到精通 刘忆智 著</em></p>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列4-文件目录管理</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%974-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>Linux的文件系统架构</li><li>文件和目录管理的基本操作</li><li>更改文件和目录权限</li><li>文件类型</li><li>重定向和管道<br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="Linux文件系统架构"><a href="#Linux文件系统架构" class="headerlink" title="Linux文件系统架构"></a>Linux文件系统架构</h2></the></li><li>Linux没有盘符，有的是目录(挂载点)。</li><li>Linux标识目录使用的是正斜杠<code>/</code>。</li><li>Linux需要先建立一个根’/‘文件系统（即“分区”），并且在这个文件系统中建立一系列空目录，然后将其他硬盘分区中的文件系统（如果有的话）挂载到这些目录中，比如在安装系统时，我们先划分一个单独的分区，再将其挂载到/home目录下。</li><li>理论上可以为根目录下的每一个目录都划分一个单独的硬盘分区，这样根分区就可以设置的很小(因为子目录都“映射”到了其他分区上，不占据根分区的容量)。</li><li>如果子目录没有划分自己的分区，那么其文件内容就自动存储在<code>/</code>根分区下。</li><li>Linux系统主要目录及内容表格</li></ul><table><thead><tr><th>目 录</th><th>内 容</th></tr></thead><tbody><tr><td><code>/bin</code></td><td>构建最小系统所需要的命令（最常用的命令）</td></tr><tr><td><code>/boot</code></td><td>内核与启动文件</td></tr><tr><td><code>/dev</code></td><td>各种设备文件</td></tr><tr><td><code>/etc</code></td><td>系统软件的启动和配置文件</td></tr><tr><td><code>/home</code></td><td>用户的主目录</td></tr><tr><td><code>/lib</code></td><td>C编译器的库</td></tr><tr><td><code>/media</code></td><td>可移动介质的安装点</td></tr><tr><td><code>/opt</code></td><td>可选的应用程序包</td></tr><tr><td><code>/proc</code></td><td>进程的映像</td></tr><tr><td><code>/root</code></td><td>超级用户root的主目录</td></tr><tr><td><code>/sbin</code></td><td>和系统操作有关的命令</td></tr><tr><td><code>/tmp</code></td><td>临时文件存放点</td></tr><tr><td><code>/usr</code></td><td>非文件的程序和命令</td></tr><tr><td><code>/var</code></td><td>系统专用的数据和配置文件</td></tr></tbody></table><h2 id="工作组共享文件"><a href="#工作组共享文件" class="headerlink" title="工作组共享文件"></a>工作组共享文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd workgroup</span><br><span class="line">sudo useradd -G workgroup lucy</span><br><span class="line">sudo passwd lucy</span><br><span class="line">sudo chgrp workgroup work/ <span class="comment">#将组拥有权交给workgroup</span></span><br><span class="line">sudo chmod g+rwx work/ <span class="comment"># 用户组对目录有读写和执行权限</span></span><br><span class="line">sudo chmod o-rwx work/ <span class="comment"># 其他用户对目录无上述权限</span></span><br><span class="line">sudo chown lewis work/ <span class="comment"># 将目录所有权移交给lewis</span></span><br><span class="line">su lewis <span class="comment"># 切换用户ID</span></span><br></pre></td></tr></table></figure><h2 id="文件和目录管理"><a href="#文件和目录管理" class="headerlink" title="文件和目录管理"></a>文件和目录管理</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><code>mkdir</code>:一次性建立一个或几个目录。<ul><li><code>mkdir -p dirname</code>:如果父目录不存在会自动创建。</li></ul></li><li><code>touch</code>：建立新的空文件。</li><li><code>mv</code>:重命名是移动同时修改名字（可选择不修改），一般同名时直接覆盖。<ul><li><code>mv -i</code>:如果同名，询问;</li><li><code>mv -b</code>:如果同名，在文件名后面添加<code>~</code>符号。</li></ul></li><li><code>cp</code>:复制文件和目录。<ul><li><code>cp -i</code>:覆盖前询问;</li><li><code>cp -b</code>：同名文件重命名;</li><li><code>cp -r</code>：递归式复制（目录及子目录）。</li></ul></li><li><code>rm</code>:永久删除文件和目录。<ul><li><code>rm -i</code>:删除前询问;</li><li><code>rm -f</code>：强制删除，即对所有询问自动yes;</li><li><code>rm -r</code>：递归删除所有目录。<h3 id="更改文件和目录权限"><a href="#更改文件和目录权限" class="headerlink" title="更改文件和目录权限"></a>更改文件和目录权限</h3></li></ul></li><li><code>chmod</code>：使用格式[ugoa…][[-+=][perms…]…]。<ol><li>Linux为3种人准备了权限——文件所有者(u)，文件所属组(g)和其他人(o)，其他人指非前两者也非root用户(因为root拥有完整权限)，其他人总是享有最低权限。</li><li>所有人(a)指代上述所有3个用户组;</li><li><code>+</code>表示增加权限，<code>-</code>表示删除权限，<code>=</code>表直接设置权限;</li><li>一般来说，文件创建者自动成为所有者，但是所有权可以转让，手续由root用户实施。</li><li>权限分为3种：读取(r)，写入(w)和执行(x)。</li></ol><ul><li>对于<strong>文件</strong>，能否删除和重命名一个文件是由其父目录的权限设置所控制的，要让一个文件可执行，必须设置其执行权限;可执行文件分为两类:<ul><li>(1)可由CPU执行的二进制代码;</li><li>(2)shell脚本程序;</li></ul></li><li>对于<strong>目录</strong>，<ul><li>(1)执行权限:控制用户能否进入该目录;</li><li>(2)读取权限：负责确定能否列出该目录的内容;</li><li>(3)写入权限：在目录中创建、删除和重命名文件。</li><li>所以<strong>目录和文件的执行权限是最基本的权限</strong>。</li></ul></li></ul><ol><li><strong>权限的八进制表示</strong>：每组权限rwx用3位二进制数表示(有为1无为0)，即可以用1位八进制数表示。所以完整的9位权限位就可以用3个八进制数表示，如<code>chmod 711 prog</code>就可以规定各用户组权限。</li></ol></li><li><code>chown</code>:格式chown [OPTION]… [OWNER][:[GROUP]] FILE将file的[属主]和[属组]改变为owner和group。<ul><li><code>chown -R</code>:递归式改变所有子目录所有者和组;</li><li><code>chgrp</code>:只改变所属组。</li></ul></li><li><code>ls -l</code>和<code>ls -ld</code>:分别查看文件和目录的属性，属性项依次为:文件类型-3组权限位+链接数目+文件属主+文件属组+文件大小+最后修改日期+最后修改时间+完整路径。 <h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3></li><li>Linux中一切都表示为文件的形式（包括进程、硬件设备、通信通道等），文件类型(ls -l的显示)包括：</li></ul><table><thead><tr><th>文件类型</th><th>符号</th></tr></thead><tbody><tr><td>普通文件</td><td>-</td></tr><tr><td>目录</td><td>d</td></tr><tr><td>字符设备(顺序访问设备)文件</td><td>c</td></tr><tr><td>块设备(随机访问设备)文件</td><td>b</td></tr><tr><td>本地域套接口(进程间通信)</td><td>s</td></tr><tr><td>有名管道(进程间通信)</td><td>p</td></tr><tr><td>符号链接(快捷方式)</td><td>l</td></tr></tbody></table><ul><li>链接分为两种：<ul><li>(1)软连接/符号链接:用<code>ln -s TARGET LINK_NAME</code>创建，通过名称进行引用，删除链接也不影响原文件;</li><li>(2)硬连接：用<code>ln</code>直接创建，直接引用，对其中一者的修改会影响另一者。已<strong>很少使用</strong>。<h3 id="重定向和管道"><a href="#重定向和管道" class="headerlink" title="重定向和管道"></a>重定向和管道</h3></li></ul></li><li>输入输出重定向：改变程序获取输入或产生输出的位置。标准输出指向屏幕，标准输入指向键盘。<ul><li>输入重定向：<code>&lt;</code>;</li><li>两种常用输出重定向：<ul><li><code>&gt;</code>:相当于覆盖。</li><li><code>&gt;&gt;</code>:相当于添加。</li></ul></li></ul></li><li>管道：<code>|</code>将一条命令的输出连接到另一条命令的输入，举例：<ul><li><code>ls | grep ay</code>:ls的输出送给grep做最后一个输入。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><em>Linux从入门到精通 刘忆智 著</em></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列3-shell基本命令</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%973-shell%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>对Shell的介绍(和命令行的关系)</li><li>常用Shell命令</li><li>/etc存放大部分系统和程序的配置文件<br>如要下载笔记请到<a href="https://github.com/yucicheung/LearningNotes" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h2></the></li><li><strong>命令行</strong>指供用户输入命令的界面，其本身只是接受输入，然后把命令行传递给<strong>命令解释器</strong>(即<em>shell</em>)。</li><li><strong>shell</strong>本质上是一个程序，在用户和os之间提供了一个面向行的可交互接口。shell将用户输入的命令转换成指令代码发送给操作系统。</li><li>Linux环境下BASH (Bourne Again Shell) shell是默认安装和使用的shell。</li><li>图形界面下的终端实际上是一个终端模拟器。</li><li>Linux默认有7个控制台，可以通过按快捷键Ctrl+alt+F1~F7进入。默认情况下，前6个是命令行控制台，第7个则留给X服务器。</li><li>BASH中，”$”是命令行提示符，表示可以输入命令;如果以root身份运行，提示符为”#”。(命令和文件名都区分大小写)。</li><li>不带参数的<code>cd</code>命令表示进入主目录。</li><li>/etc目录下存放了系统和绝大部分应用软件的配置文件。Linux使用纯文本文件来配置文件。</li><li>/etc/fstab文件定义了个硬盘分区所挂载到的目录路径。<h2 id="命令行使用-含常用命令"><a href="#命令行使用-含常用命令" class="headerlink" title="命令行使用(含常用命令)"></a>命令行使用(含常用命令)</h2></li><li>命令行/文件名补全：输入开头，按tab键，shell会自动将文件名补全。如果文件名/命令不止一个，连按tab键两次列出所有符合的文件名。<ul><li><em>hints</em>：系统命令本质上就是一些<strong>可执行文件</strong>，在<code>/usr/bin/</code>目录下找到。</li></ul></li><li><strong>通配符</strong>(不同于正则表达式)：<ul><li><code>*</code>:用于匹配文件名中任意长度的字符串，如<code>ls *.md</code>;</li><li><code>?</code>:只匹配一个字符，如<code>ls text?</code>;</li><li><code>[]</code>:用于匹配出现在方括号内的字符，如<code>ls text[1A]</code>;</li><li><code>-</code>:指定字符集范围（上下界包含）。与<code>[]</code>搭配使用，如<code>ls text[1-9]</code>。</li></ul></li><li><code>pwd</code>: print working directory，打印当前目录。</li><li><code>ls</code> : 列出文件。<ul><li><code>ls</code>:目录为蓝色；普通文件为白色;可执行文件为草绿色;连接文件为淡蓝色。</li><li><code>ls -F</code>:在无法显示颜色的终端上使用，目录后加/，在可执行文件后加*，在链接文件加上@。</li><li><code>ls -a</code>：显示所有文件，包括<code>.</code>开头的隐含文件。</li><li><code>ls -l</code>:用于查看文件的各种属性(包括最后一次被修改的时间);</li><li><code>ls -ld</code>:查看目录的各种属性。</li></ul></li><li><code>cat</code>：一次性显示文件内容，后可跟多个文件名做参数，也可使用通配符。<ul><li><code>cat -n 文件名</code>：显示行号。</li></ul></li><li><code>more</code>：逐页显示文件内容，空格翻页，Enter滚动一行。</li><li><code>less</code>：功能更强大。比more更像是一个文本编辑器(有检索、高亮操作)。</li><li><code>head</code>和<code>tail</code>：查看文件的头和尾，可接多个文件。用<code>-n</code>指定显示的行数。如<code>head -n 2 shell.md</code>。</li><li><code>grep</code>:查找文件中的文本内容，用法<code>grep [OPTIONS] PATTERN [FILE...]</code>。其中的PATTERN是”基础正则表达式”。<code>egrep</code>使用扩展的正则表达式。</li><li><code>find</code>：find会深入到指定路径(绝对路径)的每一个子目录中去查找文件，<code>-name</code>指定文件名（可以使用通配符），如<code>find /usr/bin/ -name zip</code>。</li><li><code>locate</code>:更快速地定位文件。通过搜索文件名数据库来确定文件的位置（<code>locate</code>命令会自动建立整个文件名数据库）。</li><li><code>&amp;</code>：<code>firefox</code>执行时，当前终端会被挂起。如果要在后台运行，后面加上<code>&amp;</code>。</li><li><code>whereis</code>：用于查找程序文件。提供该文件的二进制可执行文件、源代码文件和使用手册页存放的位置。<strong>whereis</strong>搜索的子目录是固定的，包括<code>/usr/bin</code>、<code>usr/sbin</code>和<code>/usr/share/man</code>。</li><li><code>who</code>:查看当前系统中有哪些人登录，以及工作在哪个控制台上。</li><li><code>whoami</code>:查看当前以什么身份登陆。</li><li><code>uname</code>:显示当前系统的版本信息。<code>uname -a</code>给出所有有用信息，<code>uname -r</code>给出内核信息。</li><li><code>man</code>:显示程序使用手册（实际调用了less程序显示）。</li><li><code>whatis</code>:一句话说明一个程序大概可以做什么。</li><li><code>apropos</code>:查找简介中含有关键词的命令，输出。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><em>Linux从入门到精通 刘忆智 著</em></li></ul>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列2-基本配置</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%972-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>关于超级用户root的说明</li><li>Grub的介绍和配置</li><li>X系统的介绍和组成<br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="关于超级用户root"><a href="#关于超级用户root" class="headerlink" title="关于超级用户root"></a>关于超级用户root</h2><ul><li>所有的系统设置都需要root用户来完成，即超级用户，也叫做根用户。<ul><li>权限：是整个系统中拥有最高权限的用户，root用户可以做任何事情。root可以访问、修改、删除系统中的任何文件和目录;</li><li>Linux系统上的每个文件和目录都属于某个特定的用户(在多人协作的服务器上)，没有得到许可，其他用户就不能访问，但是root用户可以访问所有用户的文件;</li><li>用户可以执行不带参数的<code>su</code>命令将自己提升为root权限（当然需要提供root口令）;而<code>sudo</code> 可以临时使用root身份运行程序，并在执行完毕后返回至普通用户状态;</li><li>对绝大多数Linux发行版，安装最后一步会设置root和普通用户。而对于Debian和Ubuntu系统，只有一个普通用户+sudo来执行root权限。但是，sudo是通过读取<code>etc/sudoers</code>来确定什么用户可以在什么机器上执行什么命令;</li><li><code>sudo -s</code>可以将自己提升为root用户，相当于<code>su</code>命令，用<code>exit</code>退出。<h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2></li></ul></li><li>图形化管理界面只在系统正常时可以使用，命令行往往更可靠和灵活。<h2 id="进阶：配置Grub"><a href="#进阶：配置Grub" class="headerlink" title="进阶：配置Grub"></a>进阶：配置Grub</h2></li><li>Grub(多重引导程序)启动时通常从<code>/boot/grub/grub.cfg</code>读取引导配置，并且严格地依此行事。查看该文件，开头会提示<em>不要编辑该文件</em>，因为该文件是以<code>/etc/default/grub</code>作为配置自动生成的。<ul><li>但是<code>/boot/grub/grub.cfg</code>并不是不可以更改的，也可以直接移动引导项的代码来改动引导项(如windows)。</li></ul></li><li><code>/etc/default/grub</code>(修改后需执行’update-grub’生效)中的参数：<ul><li>GRUB_DEFAULT:引导项列表的<em>默认选择项序号</em>(从0开始);</li><li>GRUB_TIMEOUT:引导项列表自动选择超过时间(超过则默认选中);</li></ul></li><li>还可以在Grub启动画面出现时按下C键可以进入Grub的命令行模式。</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>help</td><td>显示帮助信息</td></tr><tr><td>reboot</td><td>重新引导系统</td></tr><tr><td>root</td><td>指定根分区</td></tr><tr><td>kernel</td><td>指定内核所在位置</td></tr><tr><td>find</td><td>在所有可以安装的分区上寻找一个文件</td></tr><tr><td>boot</td><td>依照配置引导系统</td></tr></tbody></table><h2 id="桌面"><a href="#桌面" class="headerlink" title="桌面"></a>桌面</h2><ul><li>Linux不是一种基于图形环境的操作系统，在内核眼里，图形环境只是一个普通的应用程序。</li><li>X窗口系统(X Window System)是Linux图形用户环境的基础。如今绝大多数Linux使用的是由X.org基金会维护的X.Org。</li><li>X系统基于一种独特的服务器/客户机架构：<ul><li>意味着一台主机上的X应用程序可以在另一台主机的屏幕上显示出来，X服务器接受来自多个应用程序请求，然后在本地显示。</li></ul></li><li>X窗口系统的基本组成：<ul><li><strong>X服务器</strong>:<ul><li>X服务器用于实际控制输入设备(如鼠标和键盘)和位图式输出设备(如显示器)，X服务器定义了给X客户机使用这些设备的抽象接口，X服务器没有定义高级实体的编程接口(语法上还是比较低级);</li><li>X服务器要做到最大程度上的与平台无关，用户可以选择窗口管理器和widget库来定制自己的桌面，而不需要改变底层配置。</li></ul></li><li><strong>X客户端程序</strong>:<ul><li>需要向X服务器请求服务的程序就是X客户端程序;</li><li>它们运行时需要把自己的长相描述给X服务器，由X服务器负责在显示器上绘制这些应用程序的界面。</li></ul></li><li><strong>窗口管理器(Window Manager)</strong>:<ul><li>窗口管理器负责控制应用程序窗口的各种行为(如缩放等);</li><li>是一种特殊的X客户端程序。</li></ul></li><li><strong>显示管理器(Display Manager)</strong>:<ul><li>显示管理器提供了一个登录界面，用于验证用户身份，让用户登录到系统;</li><li>图形界面的一切(除了它自己)都是由这个显示管理器启动的，包括X服务器;</li><li>从命令行启动X服务器<code>startx</code>。</li></ul></li><li><strong>widget库</strong>:<ul><li>定义了一套图形用户界面的编程接口;</li><li>通过调用widget库来实现具体的用户界面;</li><li>wiidget库会自动把高级语言翻译成X服务器可以理解的语言。</li></ul></li><li><strong>桌面环境</strong>:<ul><li>桌面环境是把各种与X有关的东西(除了X服务器);</li><li>处理图形输出的始终是X服务器。</li></ul></li></ul></li><li>X系统的启动过程：<ul><li>X系统的启动过程是由显示管理器(Display Manager)完成的，显示管理器启动后依次完成以下工作：<ul><li>启动X服务器;</li><li>提供一个界面友好的屏幕，等待和验证用户身份;</li><li>执行用户的<strong>引导脚本</strong>，该脚本用于建立用户的桌面环境。<ul><li>桌面环境的引导脚本是一段用Linux命令组成的脚本程序，叫Xsession;    </li><li>Xsession通过启动窗口管理器、任务栏，设定应用的默认值、安装标准键绑定来启动整个桌面环境;</li><li>Xsession会一直运行，直到用户退出(也Xsession运行结束时，用户就退出了);</li><li>窗口管理器是Xsession启动的唯一前台程序，如果没有这个前台程序，用户会在登录后又退出系统。</li></ul></li></ul></li></ul></li><li>KDE：<ul><li>KDE是基于C++编写的，基于Qt库;</li><li>KDE编写的程序总是带着一个字母K。</li></ul></li><li>Gnome：<ul><li>Gnome使用C语言写成，基于GTK+widget库;</li><li>Gnome程序大多带着一个字母G。</li></ul></li><li><code>/etc/X11/xorg.conf</code>：X服务器的配置文件;<ul><li>如果显卡出现问题，可以通过修改xorg.conf禁用已有的显卡驱动程序。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><em>Linux从入门到精通 刘忆智 著</em></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Grub </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列1-概述</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%971-%E6%A6%82%E8%BF%B0/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>Linux起源和发行版本介绍</li><li>GNU和GPL概念介绍</li><li>硬盘和分区描述</li><li>修复受损Grub<br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="Linux和Unix"><a href="#Linux和Unix" class="headerlink" title="Linux和Unix"></a>Linux和Unix</h2><ul><li>Linux是对Unix的重新实现。</li><li>Linux开发人员最初是借鉴了UNIX的技术和用户界面，并且融入了很多独创的技术改进，从这方面可以说Linux是UNIX的一个变体。但是从开发形式(社区支持)和最终产生的源代码来看，Linux不属于BSD和AT&amp;T风格中的任一种，因此严格说来，Linux是有别于UNIX的操作系统。</li><li>Linux实际上<strong>只定义一个操作系统内核</strong>，以同一个基础开始，却衍生了不同的发行版本。以下表格列出著名的Linux发行版本(按<strong>源版本</strong>和衍生版本划分)</li></ul><table><thead><tr><th>发行版本</th><th>官方网站</th><th>说 明</th></tr></thead><tbody><tr><td><strong>Red Hat Enterprise</strong></td><td><a href="http://www.redhat.com" target="_blank" rel="noopener">www.redhat.com</a></td><td>Red Hat公司的企业级商业化发行版本</td></tr><tr><td>Fedora</td><td>fedoraproject.org</td><td>Red Hat公司赞助的社区项目免费发行版本</td></tr><tr><td>CentOS</td><td><a href="http://www.centos.org" target="_blank" rel="noopener">www.centos.org</a></td><td>模仿Red Hat Enterprise Linux的非商业发行版本</td></tr><tr><td><strong>Debian</strong></td><td><a href="http://www.debian.org" target="_blank" rel="noopener">www.debian.org</a></td><td>免费的非商业发行版本</td></tr><tr><td>Ubuntu</td><td><a href="http://www.ubuntu.com" target="_blank" rel="noopener">www.ubuntu.com</a></td><td>类似Debian的免费发行版本</td></tr><tr><td><strong>SUSE Linux Enterprise</strong></td><td><a href="http://www.suse.com/linux" target="_blank" rel="noopener">www.suse.com/linux</a></td><td>Novell公司的企业级商业化Linux发行版本</td></tr><tr><td>openSUSE</td><td><a href="http://www.opensuse.org" target="_blank" rel="noopener">www.opensuse.org</a></td><td>SUSE Linux的免费发行版本</td></tr></tbody></table><h2 id="GNU-amp-GPL"><a href="#GNU-amp-GPL" class="headerlink" title="GNU&amp;GPL"></a>GNU&amp;GPL</h2><ul><li><code>GNU</code>(GNU’s not UNIX)是使软件自由的计划;</li><li>它的开源协议是<code>GPL</code>(GNU Public License)，是包括Linux在内的一批开源软件遵循的许可证协议。<h2 id="Linux对硬盘及分区的表述"><a href="#Linux对硬盘及分区的表述" class="headerlink" title="Linux对硬盘及分区的表述"></a>Linux对硬盘及分区的表述</h2></li><li>硬盘一般分为IDE硬盘、SCSI硬盘和SATA硬盘<ul><li>Linux中，IDE的接口被称为hd，SCSI和SATA接口的设备则被称为sd。第1块硬盘称为sda,第2块称为sdb，以此类推。</li><li>Linux规定，<strong>一块硬盘上只能存在4块主分区</strong>，分别命名为sda1、sda2、sda3、sda4。<strong>逻辑分区则从5开始标识</strong>，每多一个逻辑分区，就在末尾的分区号加1。逻辑分区没有数量限制。</li></ul></li><li>一般来说，每个系统都需要一个主分区来<strong>引导</strong>。这个分区中存放着<strong>引导</strong>整个系统所必需的程序和参数。<ul><li>操作系统可以按照光在主分区也可以安装在逻辑分区，但<strong>引导程序必须安装在主分区内</strong>。</li></ul></li><li><strong>安装提示</strong>:“安装类型”界面允许用户进行分区，创建两个分区就可以，一个主分区挂载点为’/‘(‘/boot’等挂载点会自动安装在其中)，另一个交换空间(相当于虚拟内存，用于缓冲数据)。<h2 id="进阶：修复受损的Grub"><a href="#进阶：修复受损的Grub" class="headerlink" title="进阶：修复受损的Grub"></a>进阶：修复受损的Grub</h2></li><li>Linux默认使用的默认操作系统引导加载器Grub，可以引导包括Linux、Windows、FreeBSD等多种操作系统。</li><li>Linux安装程序会在一切准备稳妥之后安装Grub，并加入对硬盘中原有操作系统的支持。这一切都是自动完成的。但是后安装Windows的话，win的引导程序却会自动将Grub覆盖。导致Linux无法启动。</li><li>万一Grub失效，需要用修复盘（即安装盘）以LiveCD模式修复，即“Try Ubuntu without installing”以命令行重新安装Grub。依次用以下命令安装Grub:</li></ul><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>grub</td><td>启动光盘上的grub程序</td></tr><tr><td>find /boot/grub/stage1</td><td>查找硬盘上的Linux系统将/boot目录存放在哪个硬盘分区中，grub安装时需要读取这个目录中的相关配置文件</td></tr><tr><td>root (hdx,y)</td><td>指示Linux内核文件所在的硬盘分区（/boot所在分区），<br>将这里的(hdx,y)替换为上一行中查找到的那个分区。<br>注意括号中不能存在空格。</td></tr><tr><td>setup (hd0)</td><td>在地一块硬盘上安装引导程序Grub</td></tr><tr><td>quit</td><td>退出Grub程序</td></tr></tbody></table><p><strong>提示</strong>:Grub对磁盘分区的表示方式和Linux有所不同。Grub将所有硬盘都表示为(hd#)的形式，<code>#</code>从0开始编号。对任一块硬盘，(hd#,0)~(hd#,3)依次表示它的主分区，随后的(hd#,4)….则是逻辑分区。(sd[a-z]从1开始编号)</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><em>Linux从入门到精通 刘忆智 著</em></p>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dijkstras算法和实现(python)</title>
      <link href="/2018/03/24/Dijkstras%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>Dijkstras算法的基本原理和求解步骤</li><li>Dijkstras算法用python实现的思路和源代码</li><li>Dijkstras算法的适用范围<br>代码和笔记记录下载请到<a href="https://github.com/yucicheung/grokking_algorithms_practice/tree/master/07_dijkstras_algorithm" target="_blank" rel="noopener">我的github仓库</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2></the></li></ul><ol><li>广度优先搜索，适用于<em>非加权图</em>(unweighted graph)，找到的<em>最短路径</em>是段数最少的路径。<strong>迪克斯特拉</strong>(Dijkstras)算法，适用于<em>加权图</em>(weighted graph)，找出的是总权重最小的路径。</li><li>Dijsktra算法包含四个步骤：<ol><li>找出当前离起点最近的节点；</li><li>对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销，并更新邻居的父节点；</li><li>重复这个过程，直到对所有节点都这样做了；</li><li>计算最终路径(路线和开销)。</li></ol></li><li>Dijstras的基本思想：对于处理的节点，已经找到到它们的最短路径(或没有到达它们的更短路径)。</li><li><p>以下图题目为例:<br><img src="/img/dijkstras_init.jpg" alt="dijkstras_init"></p><p>利用算法求最短路径的求解过程如下：</p><p><img src="/img/dijkstras_solve.jpg" alt="dijkstras_solve"></p><p>于是最终得到的最短路径<code>start--&gt; B--&gt; A--&gt; fin</code>,开销为6。</p></li></ol><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><ol><li>节点的开销应初始化为无穷大,保证只要有路线可达，其开销一定能被更新。Python中是<code>float(&#39;inf&#39;)</code>。</li><li>加权有向图仍然是散列表实现。</li><li>求解全过程要用到：<ul><li>有向图散列表；</li><li>开销散列表;</li><li>父节点散列表;</li><li>待处理节点列表(或已处理节点列表)。</li></ul></li><li>对<code>fin</code>终点不需要进行Dijkstras算法。</li></ol><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><ol><li>首先，Dijkstras算法适用于有向加权图。</li><li>对于<em>有向无环图</em>(directed acyclic graph, DAG)也是适用的，因为Dijkstras算法会自动淘汰含有环的边。</li><li><strong>不适用</strong>含负权边的有向图，负权边会在节点检查过之后仍然更新其开销，不符合Dijkstras算法的基本思想。在包含负权边的图中找最短路径要用另一种算法——Bellman-Ford算法。</li></ol><h2 id="代码实现-python"><a href="#代码实现-python" class="headerlink" title="代码实现(python)"></a>代码实现(python)</h2><p>针对上面的有向图求解。<br>代码实现和笔记都在<a href="https://github.com/yucicheung/grokking_algorithms_practice/tree/master/07_dijkstras_algorithm" target="_blank" rel="noopener">我的github仓库</a>可以下载到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_lowest_cost</span><span class="params">(costs,to_process)</span>:</span></span><br><span class="line">lowest_cost_node = to_process[<span class="number">0</span>]</span><br><span class="line">lowest_cost = costs[lowest_cost_node]</span><br><span class="line"><span class="keyword">if</span> len(to_process)&gt;<span class="number">1</span>:</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> to_process[<span class="number">1</span>:]:</span><br><span class="line">new_cost = costs[node]</span><br><span class="line"><span class="keyword">if</span> new_cost &lt; lowest_cost:</span><br><span class="line">lowest_cost = new_cost</span><br><span class="line">lowest_cost_node = node</span><br><span class="line"><span class="keyword">return</span> lowest_cost_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_up_graph</span><span class="params">()</span>:</span></span><br><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">'start'</span>] = &#123;<span class="string">"A"</span>:<span class="number">6</span>,<span class="string">"B"</span>:<span class="number">2</span>&#125;</span><br><span class="line">graph[<span class="string">"A"</span>] = &#123;<span class="string">'fin'</span>:<span class="number">1</span>&#125;</span><br><span class="line">graph[<span class="string">"B"</span>] = &#123;<span class="string">"A"</span>:<span class="number">3</span>,<span class="string">"fin"</span>:<span class="number">5</span>&#125;</span><br><span class="line">graph[<span class="string">'fin'</span>] = &#123;&#125;</span><br><span class="line"><span class="keyword">return</span> graph</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_costs_n_fathers</span><span class="params">(graph)</span>:</span></span><br><span class="line">costs, fathers =&#123;&#125;,&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line"><span class="keyword">if</span> node <span class="keyword">is</span> <span class="string">"start"</span>:</span><br><span class="line">costs[node] = <span class="number">0</span></span><br><span class="line">fathers[node] = <span class="keyword">None</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">costs[node] = float(<span class="string">'inf'</span>)</span><br><span class="line"><span class="keyword">return</span> costs,fathers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shortest_path</span><span class="params">(fathers)</span>:</span></span><br><span class="line">path = []</span><br><span class="line">father = <span class="string">'fin'</span></span><br><span class="line">path.append(father)</span><br><span class="line"><span class="keyword">while</span> father != <span class="string">'start'</span>:</span><br><span class="line">father = fathers[father]</span><br><span class="line">path.append(father)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Shortest path is:'</span>,</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> path[<span class="number">-1</span>:-len(path):<span class="number">-1</span>]:</span><br><span class="line"><span class="keyword">print</span> <span class="string">'&#123;&#125;--&gt;'</span>.format(i),</span><br><span class="line"><span class="keyword">print</span> path[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">graph = set_up_graph()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Graph as below:'</span></span><br><span class="line">pprint(graph)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'\n'</span></span><br><span class="line">costs, fathers = initialize_costs_n_fathers(graph)</span><br><span class="line">to_process = [i <span class="keyword">for</span> i <span class="keyword">in</span> graph.keys()]</span><br><span class="line">to_process.remove(<span class="string">'fin'</span>)</span><br><span class="line"><span class="keyword">while</span> to_process:</span><br><span class="line">node = find_lowest_cost(costs,to_process)</span><br><span class="line">neighbors = graph[node]</span><br><span class="line"><span class="keyword">for</span> neighbor <span class="keyword">in</span> neighbors:</span><br><span class="line">new_cost = costs[node] + graph[node][neighbor]</span><br><span class="line"><span class="keyword">if</span> new_cost &lt; costs[neighbor]:</span><br><span class="line">costs[neighbor] = new_cost</span><br><span class="line">fathers[neighbor] = node</span><br><span class="line">to_process.remove(node) <span class="comment"># keys donnot share names</span></span><br><span class="line">get_shortest_path(fathers)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'The lowest cost is &#123;&#125;.'</span>.format(costs[<span class="string">'fin'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>运行结果为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Graph as below:</span><br><span class="line">&#123;<span class="string">'A'</span>: &#123;<span class="string">'fin'</span>: 1&#125;,</span><br><span class="line"> <span class="string">'B'</span>: &#123;<span class="string">'A'</span>: 3, <span class="string">'fin'</span>: 5&#125;,</span><br><span class="line"> <span class="string">'fin'</span>: &#123;&#125;,</span><br><span class="line"> <span class="string">'start'</span>: &#123;<span class="string">'A'</span>: 6, <span class="string">'B'</span>: 2&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Shortest path is: start--&gt; B--&gt; A--&gt; fin</span><br><span class="line">The lowest cost is 6.</span><br></pre></td></tr></table></figure></p><p>也可以将上面的图改成是有环的图，就能验证到对有环图也是适用的。</p>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python中的argv和argc</title>
      <link href="/2018/03/17/python%E4%B8%AD%E7%9A%84argv%E5%92%8Cargc/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>为什么<code>argv</code>中第一个，即index=0的内容就是文件名？</li><li>python中<code>argc</code>是用什么实现的？<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><code>argc</code>:argument counter，命令行参数个数<br><code>argv</code>:argument vector，命令行参数向量(内容)<h2 id="通过代码理解含义"><a href="#通过代码理解含义" class="headerlink" title="通过代码理解含义"></a>通过代码理解含义</h2>创建一个文件<code>arg_exam.py</code>，其中内容如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># argv</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">    <span class="keyword">print</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment"># argc</span></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">print</span> argc</span><br></pre></td></tr></table></figure></the></li></ul><p>在shell中运行一个简单的例子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python arg_exam.py hello I am an example</span><br></pre></td></tr></table></figure></p><p>输出为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arg_exam.py</span><br><span class="line">hello</span><br><span class="line">I</span><br><span class="line">am</span><br><span class="line">an</span><br><span class="line">example</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p><p>所以说，<code>argv</code>就是<code>python</code>命令后跟着的一系列命令参数的内容。<br>而<code>argc</code>（在C语言存在的变量）就是这些命令参数的个数了，在python中因为<code>argv</code>是个列表，其长度<code>len</code>自然就是<code>argc</code>了，所以python中并没有为<code>argc</code>特地设置一个方法或者属性。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>argv是在命令行中运行程序时跟在<code>python</code>命令后的所有内容，以空格为分界，得到各元素。</li><li>python中argc并不是一个特定属性或方法，而是可以直接通过<code>len(sys.argv)</code>获得。</li></ul>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为Github page绑定自定义域名并实现https访问</title>
      <link href="/2018/03/14/%E4%B8%BAGithub-page%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%B9%B6%E5%AE%9E%E7%8E%B0https%E8%AE%BF%E9%97%AE/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><code>实现目标</code></excerpt></p><ul><li>获取自定义域名<code>yucichueng.me</code>;</li><li>将上述域名(及<strong>www</strong>域名)解析到<code>yucichueng.github.io</code>IP地址;</li><li>将域名解析服务托管于<strong>CloudFlare</strong>;</li><li>获取<strong>SSL</strong>证书，使网站可以通过<strong>https</strong>访问。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="获取自定义域名"><a href="#获取自定义域名" class="headerlink" title="获取自定义域名"></a>获取自定义域名</h2>我购买的域名是<code>yucicheung.me</code>。<br>一级域名<code>me</code>在<a href="https://au.godaddy.com/" target="_blank" rel="noopener">GoDaddy</a>网站进行购买。心仪的域名可以在网站<a href="https://www.whois.net/" target="_blank" rel="noopener">whois</a>查看是否被注册，未被注册可在相应域名商处购买。<br><strong>Tips:</strong>如果是在<code>Godaddy</code>购买的域名，建议购买隐私服务(不泄露个人信息)，不是很便宜，所以建议可以直接从国内域名商处购买，赠送隐私保护服务。<h2 id="域名解析到Github-page"><a href="#域名解析到Github-page" class="headerlink" title="域名解析到Github page"></a>域名解析到Github page</h2>购买域名后，在对应域名供应商处一般会提供域名解析服务，我们需要对解析服务进行配置。<br>对我来说，就要在<code>Godaddy</code>域名解析服务处进行配置。<h3 id="修改域名服务商解析记录"><a href="#修改域名服务商解析记录" class="headerlink" title="修改域名服务商解析记录"></a>修改域名服务商解析记录</h3></the></li></ul><ol><li>点击主页右上角自己的账户名–&gt;点击<strong>manage my domains</strong>–&gt;在<strong>My Domains</strong>选择<strong>Manage DNS</strong>;<div align="center"><br><img src="\img\manage_DNS.png" alt="manage_DNS"><br></div></li><li>添加<code>CNAME</code>和<code>A</code>解析记录，使<code>www</code>网址和<code>@</code>(即本身)都指向自己的github page；<br>按以下表格分别添加<strong>A</strong>和<strong>CNAME</strong>两条解析记录：</li></ol><table><thead><tr><th style="text-align:center">类型type</th><th style="text-align:center">主机host</th><th style="text-align:center">指向points to</th><th style="text-align:center">TTL(Time To Live)</th></tr></thead><tbody><tr><td style="text-align:center"><code>A</code></td><td style="text-align:center"><code>@</code></td><td style="text-align:center">github page的IP 地址</td><td style="text-align:center">600</td></tr><tr><td style="text-align:center"><code>CNAME</code></td><td style="text-align:center"><code>www</code></td><td style="text-align:center">github page的网址</td><td style="text-align:center">600</td></tr><tr><td style="text-align:center"><strong>A记录</strong>：<br>用来指定域名的IPv4地址<br>如要将域名指向一个IP地址<br>添加A记录<br><br><strong>CNAME</strong>：<br> 如要将域名指向另一域名<br>再由该域名提供ip<br>添加CNAME记录</td><td style="text-align:center"><strong>www</strong>：<br>解析后域名为<strong><a href="http://www.yucicheung.me" target="_blank" rel="noopener">www.yucicheung.me</a></strong><br><br><strong>@</strong>：<br>解析主域名<strong>yucicheung.me</strong><br><br><strong>*</strong>：<br>泛解析，匹配其他所有域名，<strong>*.yucicheung.me</strong></td><td style="text-align:center">对于<code>A记录</code>:<br>要指向IP地址<br><br>对于<code>CNAME</code>:<br>要指向一个域名<br><br></td><td style="text-align:center">指地方dns缓存域名记录的时间,缓存失效后会再次获取<br><br><strong>600</strong>:<br>建议采用600<br><br><strong>60</strong>:<br>如果经常修改IP可用(修改可快速生效),长期使用略影响解析速度<br><br><strong>3600</strong>:<br>如果IP极少变动(一年几次),可选择 3600,解析速度快</td></tr></tbody></table><p><strong>Tips</strong>：github page的IP地址可以通过以下命令获取：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping yucicheung.github.io</span><br></pre></td></tr></table></figure></p><h3 id="添加github仓库的域名解析记录"><a href="#添加github仓库的域名解析记录" class="headerlink" title="添加github仓库的域名解析记录"></a>添加github仓库的域名解析记录</h3><ol><li><p>按以下命令在自己的github仓库中添加CNAME文件，其中填入购买的域名。或者可以在仓库的<strong>settings</strong>中设置<strong>Custom Domain</strong>设置好自己的域名，github会自动添加CNAME文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ touch CNAME</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'yucicheung.me'</span>&gt; CNAME</span><br></pre></td></tr></table></figure></li><li><p>稍等一下就可以通过购买域名<strong>yucicheung.me</strong>访问<strong>yucicheung.github.io</strong>了，但是这时只能通过<code>http</code>访问自定义域名而非<code>https</code>。</p></li></ol><h2 id="通过HTTPS访问自定义域名"><a href="#通过HTTPS访问自定义域名" class="headerlink" title="通过HTTPS访问自定义域名"></a>通过HTTPS访问自定义域名</h2><p>在完成上述操作以后，只能通过<code>HTTP</code>协议传输(明文传输),于是在通过自定义域名访问自己的github page时，发现浏览器提示<strong>该网址不安全，没有合格的安全证书</strong>，不能通过<code>https</code>(密文传输)访问。</p><h3 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h3><p><strong>HTTP</strong>是明文传输协议，传输内容容易被嗅探和篡改。<br>而<strong>HTTPS</strong>，即<strong>HTTP over SSL/TLS</strong>,是添加了一层<strong>SSL(Secure Sockets Layer，安全套接层)</strong>，或者是<strong>TLS(Transport Layer Security,传输层安全协议)</strong>，所以<strong>HTTPS</strong>就可以视为<strong>HTTP</strong>和<strong>SSL/TLS</strong>协议的组合。<br><br><br><strong>HTTPS</strong>能做到良好的保密性(防嗅探)，真实性(防篡改)，完整性(防域名劫持和域名欺骗)。</p><h3 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h3><p><strong>SSL</strong>是<strong>TLS</strong>的前身，但<strong>TLS</strong>通常也被标志为<strong>SSL</strong>。<br><strong>SSL/TLS</strong>协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息(会话秘钥)，服务器收到密文后，用自己的私钥解密。<br>这个公钥就放在数字证书中。只要证书是可信的，公钥就是可信的。</p><h3 id="申请SSL证书"><a href="#申请SSL证书" class="headerlink" title="申请SSL证书"></a>申请SSL证书</h3><p>SSL证书由你的NS(Name Server，域名服务商)颁发，由于<code>GoDaddy</code>的SSL证书超级贵，所以我们可以迁移到免费提供SSL的NS处，比如国内的<strong>DNSpod</strong>(国内都需要备案),还有国外的<strong>Netlify</strong>和<strong>Cloudflare</strong>，从速度和操作性考虑，本人选择了<code>Cloudflare</code>。</p><ol><li>到<a href="https://www.cloudflare.com/" target="_blank" rel="noopener">Cloudflare官网</a>注册；</li><li>根据指引点击<strong>Add Site</strong>，添加自定义域名<strong>yucicheung.me</strong>，会自动开始扫描DNS解析记录；</li><li>扫描完成后，<strong>Cloudflare</strong>会选择给我们分配两个NS地址，将这两个地址替换<strong>GoDaddy</strong>上的原NS地址，等待生效；<div align="center"><br><img src="/img/change_ns.png" alt="change_ns"><br></div></li><li>在<strong>Cloudflare</strong>上检查自己网站的状态，显示为<code>Active</code>时表示NS更改成功；<div align="center"><br><img src="/img/Active.png" alt="active"><br></div></li><li>在<strong>Cloudflare</strong>将自己网站的<strong>SSL</strong>状态改变为<code>Full</code>状态，等待<strong>Status</strong>变为<code>Active Certificate</code>，通常生效需要十几分钟。<div align="center"><br><img src="/img/full_SSL.png" alt="ssl"><br></div></li><li>再访问自定义域名时，就可以看见是<code>https</code>传输，网址前也有一把绿色小锁,可以看到这个证书其实是Cloudflare的证书。<br><div align="center"><br><img src="/img/https.png" alt="https"><br><img src="/img/ssl.png" alt="ssl"><br></div><h2 id="CDN-关于访问速度"><a href="#CDN-关于访问速度" class="headerlink" title="CDN:关于访问速度"></a>CDN:关于访问速度</h2>如果因为NS在国外，担心访问速度，可以稍微放心。<br><strong>Cloudflare</strong>本身提供<code>CDN</code>(content delivery network,内容分发网络)服务，是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，就近获取网络内容传递给用户。<br>免费服务一般只能加速<strong>css、js</strong>的引用，而对于<strong>html</strong>和<strong>图片</strong>的加速通常是付费服务。<br>实验过之后，确实是图片加载会稍慢一些，但是整体速度是可以接受的，<strong>如果实在介意速度，建议通过国内NS解析网址</strong>。<br>另：发现Cloudflare已经和baidu合作针对企业级用户启动加速服务，一个节点服务海外访问者，另一个服务国内访问者。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li></ol><ul><li>最后实现的整个系统可以这么理解：就相当于由github提供主机（相当于寄存在github的服务器），自己购买域名，域名指向服务器文件进行展示。</li><li>原本的github主页，域名解析由GitHub负责，SSL证书由github.com提供，所以可以安全访问。现在的域名解析由Cloudflare服务，SSL证书也由其提供。</li></ul>]]></content>
      
      <categories>
          
          <category> Documenting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> SSL </tag>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu下用hexo搭建github博客</title>
      <link href="/2018/03/13/Ubuntu%E4%B8%8B%E7%94%A8hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>配置环境：<strong>Ubuntu 16.04</strong></li><li>搭建目标：<strong>Github page(username.github.io)</strong></li><li>搭建程序：<strong>hexo</strong></li><li>在新建分支hexo下管理部署文件，最终部署到主分支master进行网站发布，涉及第三方应用绑定。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install git-core <span class="comment"># 已安装请略过</span></span><br></pre></td></tr></table></figure></the></li></ul><p>并且在你的github主页创建一个repo，命名为<code>username.github.io</code>，比如对我来说就是<code>yucicheung.github.io</code>。本帖不细述，请参考<a href="https://pages.github.com/" target="_blank" rel="noopener">github page基本指南</a>。</p><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure><p>重新开启终端使<code>nvm</code>命令生效。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nvm ls-remote <span class="comment"># 查看所有可用版本</span></span><br><span class="line">$ nvm install v8.10.0 <span class="comment"># 选择最新稳定版本</span></span><br><span class="line">$ node -v <span class="comment">#显示v8.10.0表示安装成功</span></span><br></pre></td></tr></table></figure></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install npm <span class="comment"># 安装package manager</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure><h2 id="hexo基础配置"><a href="#hexo基础配置" class="headerlink" title="hexo基础配置"></a>hexo基础配置</h2><h3 id="初始化模板"><a href="#初始化模板" class="headerlink" title="初始化模板"></a>初始化模板</h3><p>用<code>hexo</code>命令初始化一个空文件夹。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init hexo</span><br></pre></td></tr></table></figure></p><p>hexo安装所需的新文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo</span><br><span class="line">hexo $ npm install</span><br></pre></td></tr></table></figure></p><p>改变<code>hexo/</code>文件夹下的<code>_config.yml</code>的一些简单配置包括<code>title</code>,’author’等，之后就可以用以下命令预览。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server <span class="comment"># 默认端口4000</span></span><br></pre></td></tr></table></figure></p><p><strong>Notice:</strong>如果端口<code>4000</code>被占用，或者更换端口预览，或者解除占用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1：更换端口</span></span><br><span class="line">$ hexo server -p 5000</span><br><span class="line"><span class="comment"># 方法2：解除端口占用</span></span><br><span class="line">$ lsof -i:4000</span><br><span class="line">$ <span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure></p><h2 id="更改主题为yelee"><a href="#更改主题为yelee" class="headerlink" title="更改主题为yelee"></a>更改主题为yelee</h2><p>首先要在<a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">hexo-themes</a>中选择一个喜欢的主题，从git上<code>clone</code>到本地<code>themes/</code>文件夹下并命名为<code>yelee</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo/</span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:MOxFIVE/hexo-theme-yelee.git themes/yelee</span><br></pre></td></tr></table></figure></p><p>然后更改<code>hexo/_config.yml</code>中<code>theme: landscape</code>改为<code>theme: yelee</code>，<code>themes/lanscape</code>文件夹可删除。<br>再用<code>hexo server</code>或<code>hexo s</code>就可以预览为新主题了。<br>具体theme中相应主题配置应参考对应theme的官方文档，如<a href="http://moxfive.coding.me/yelee/" target="_blank" rel="noopener">yelee的官方文档</a>。</p><h2 id="部署到网站"><a href="#部署到网站" class="headerlink" title="部署到网站"></a>部署到网站</h2><p><strong>说明:网站的部署其实就是生成静态文件，<code>hexo</code>下所有生成的静态文件会放在<code>public/</code>文件夹中，所谓部署<code>deploy</code>其实就是将<code>public/</code>文件夹中内容上传到git仓库<code>yucicheung.github.io</code>中。</strong><br>要准备将静态文件部署到自己的git主页，首先需要安装一个用于部署的插件<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>，这个插件可以自动将<code>public/</code>文件中内容上传到<code>master</code>下(即用于生成github.io界面的文件)。<br><strong>如果不装插件，也可以手动进行文件复制。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>然后在<code>hexo/_config.yml</code>的<code>deploy</code>部分配置以下语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/yucicheung/yucicheung.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>需要在根据需要修改<code>hexo/</code>和<code>hexo/themes/</code>下的<code>_config.yml</code>文件后，就可以进行生成和部署了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate <span class="comment"># 或hexo g</span></span><br><span class="line">$ hexo deploy <span class="comment"># 或hexo d</span></span><br></pre></td></tr></table></figure></p><p><code>deploy</code>时需要github的账户和密码，自动上传文件完成部署。<br><strong>Tips：</strong>网站再次进行部署时，还需要清理<code>public</code>文件夹内容，重新生成部署，用以下命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean <span class="comment"># 尤其在更换主题后需使用</span></span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></p><h2 id="管理hexo文件"><a href="#管理hexo文件" class="headerlink" title="管理hexo文件"></a>管理hexo文件</h2><p>最好的办法是在<code>username.github.io</code>主页创建两个分支，一个<code>master</code>分支(由deployer管理)，一个<code>hexo</code>分支（我们自己管理）。<br>在把自己的<code>username.github.io</code>仓库克隆到本地后，<code>cd username.github.io</code>，进行以下操作。<br>创建hexo分支并切换到该分支。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hexo</span><br></pre></td></tr></table></figure></p><p>将<code>hexo/</code>文件夹下所有内容拷贝到<code>username.github.io/hexo/</code>下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp -r ~/hexo/ ~/yucicheung.github.io/</span><br></pre></td></tr></table></figure></p><p>将修改加入并push到分支<code>hexo</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"commet"</span></span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure></p><p>这样文件管理就很方便了。</p><h2 id="第三方部署"><a href="#第三方部署" class="headerlink" title="第三方部署"></a>第三方部署</h2><p>因为第三方部署跟主题有很大关系，而<a href="http://moxfive.coding.me/yelee/5.Vendor/" target="_blank" rel="noopener">主题文档</a>中说明得比较清楚，我主要讨论一下文档中说明不清的Google站长认证问题。</p><h3 id="Google站长验证"><a href="#Google站长验证" class="headerlink" title="Google站长验证"></a>Google站长验证</h3><ol><li>如果要按照主题定义的方法操作，需要在验证备用方法中选择<code>html验证</code>。</li><li>Google验证，默认方法是提供给你一个html文件，拷贝至<code>theme</code>下的<code>source</code>文件中，在<code>generate</code>的时候会原样生成。<br><strong>Tips:</strong>同理，如果有每次生成都要保存的html文件，请都放置在此文件夹下。如果是<code>README.md</code>文件要保持不被渲染，请添加到<code>hexo/source/</code>下，并且在<code>hexo/_config.yml</code>中配置<code>skip_render: README.md</code>。<h2 id="文章的发表"><a href="#文章的发表" class="headerlink" title="文章的发表"></a>文章的发表</h2>先生成draft，然后发表。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new draft <span class="string">"title"</span> <span class="comment">#在source/_draft下生成md文件</span></span><br><span class="line">$ hexo publish <span class="string">"title"</span></span><br></pre></td></tr></table></figure></li></ol><p>草稿默认不会显示在页面中，可在配置文件中把render_drafts 参数设为 true 来预览草稿。<br><strong>或</strong>直接生成新文章。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"title"</span> <span class="comment"># 自动生成title.md在_posts下</span></span><br></pre></td></tr></table></figure></p><p>如果要删除文章的话在source下删除文章后，重新生成和部署就可以了</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://hexo.io/zh-cn/docs" target="_blank" rel="noopener">hexo文档</a></li><li><a href="http://moxfive.coding.me/yelee" target="_blank" rel="noopener">yelee主题配置帖</a></li></ol>]]></content>
      
      <categories>
          
          <category> Documenting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
