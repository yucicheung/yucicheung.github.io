<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Dijkstras算法和实现(python)</title>
      <link href="/2018/03/24/Dijkstras%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>Dijkstras算法的基本原理和求解步骤</li><li>Dijkstras算法用python实现的思路和源代码</li><li>Dijkstras算法的适用范围<br>代码和笔记记录下载请到<a href="https://github.com/yucicheung/grokking_algorithms_practice/tree/master/07_dijkstras_algorithm" target="_blank" rel="noopener">我的github仓库</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2></the></li></ul><ol><li>广度优先搜索，适用于<em>非加权图</em>(unweighted graph)，找到的<em>最短路径</em>是段数最少的路径。<strong>迪克斯特拉</strong>(Dijkstras)算法，适用于<em>加权图</em>(weighted graph)，找出的是总权重最小的路径。</li><li>Dijsktra算法包含四个步骤：<ol><li>找出当前离起点最近的节点；</li><li>对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销，并更新邻居的父节点；</li><li>重复这个过程，直到对所有节点都这样做了；</li><li>计算最终路径(路线和开销)。</li></ol></li><li>Dijstras的基本思想：对于处理的节点，已经找到到它们的最短路径(或没有到达它们的更短路径)。</li><li><p>以下图题目为例:<br><img src="/img/dijkstras_init.jpg" alt="dijkstras_init"></p><p>利用算法求最短路径的求解过程如下：</p><p><img src="/img/dijkstras_solve.jpg" alt="dijkstras_solve"></p><p>于是最终得到的最短路径<code>start--&gt; B--&gt; A--&gt; fin</code>,开销为6。</p></li></ol><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><ol><li>节点的开销应初始化为无穷大,保证只要有路线可达，其开销一定能被更新。Python中是<code>float(&#39;inf&#39;)</code>。</li><li>加权有向图仍然是散列表实现。</li><li>求解全过程要用到：<ul><li>有向图散列表；</li><li>开销散列表;</li><li>父节点散列表;</li><li>待处理节点列表(或已处理节点列表)。</li></ul></li><li>对<code>fin</code>终点不需要进行Dijkstras算法。</li></ol><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><ol><li>首先，Dijkstras算法适用于有向加权图。</li><li>对于<em>有向无环图</em>(directed acyclic graph, DAG)也是适用的，因为Dijkstras算法会自动淘汰含有环的边。</li><li><strong>不适用</strong>含负权边的有向图，负权边会在节点检查过之后仍然更新其开销，不符合Dijkstras算法的基本思想。在包含负权边的图中找最短路径要用另一种算法——Bellman-Ford算法。</li></ol><h2 id="代码实现-python"><a href="#代码实现-python" class="headerlink" title="代码实现(python)"></a>代码实现(python)</h2><p>针对上面的有向图求解。<br>代码实现和笔记都在<a href="https://github.com/yucicheung/grokking_algorithms_practice/tree/master/07_dijkstras_algorithm" target="_blank" rel="noopener">我的github仓库</a>可以下载到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_lowest_cost</span><span class="params">(costs,to_process)</span>:</span></span><br><span class="line">lowest_cost_node = to_process[<span class="number">0</span>]</span><br><span class="line">lowest_cost = costs[lowest_cost_node]</span><br><span class="line"><span class="keyword">if</span> len(to_process)&gt;<span class="number">1</span>:</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> to_process[<span class="number">1</span>:]:</span><br><span class="line">new_cost = costs[node]</span><br><span class="line"><span class="keyword">if</span> new_cost &lt; lowest_cost:</span><br><span class="line">lowest_cost = new_cost</span><br><span class="line">lowest_cost_node = node</span><br><span class="line"><span class="keyword">return</span> lowest_cost_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_up_graph</span><span class="params">()</span>:</span></span><br><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">'start'</span>] = &#123;<span class="string">"A"</span>:<span class="number">6</span>,<span class="string">"B"</span>:<span class="number">2</span>&#125;</span><br><span class="line">graph[<span class="string">"A"</span>] = &#123;<span class="string">'fin'</span>:<span class="number">1</span>&#125;</span><br><span class="line">graph[<span class="string">"B"</span>] = &#123;<span class="string">"A"</span>:<span class="number">3</span>,<span class="string">"fin"</span>:<span class="number">5</span>&#125;</span><br><span class="line">graph[<span class="string">'fin'</span>] = &#123;&#125;</span><br><span class="line"><span class="keyword">return</span> graph</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_costs_n_fathers</span><span class="params">(graph)</span>:</span></span><br><span class="line">costs, fathers =&#123;&#125;,&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line"><span class="keyword">if</span> node <span class="keyword">is</span> <span class="string">"start"</span>:</span><br><span class="line">costs[node] = <span class="number">0</span></span><br><span class="line">fathers[node] = <span class="keyword">None</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">costs[node] = float(<span class="string">'inf'</span>)</span><br><span class="line"><span class="keyword">return</span> costs,fathers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shortest_path</span><span class="params">(fathers)</span>:</span></span><br><span class="line">path = []</span><br><span class="line">father = <span class="string">'fin'</span></span><br><span class="line">path.append(father)</span><br><span class="line"><span class="keyword">while</span> father != <span class="string">'start'</span>:</span><br><span class="line">father = fathers[father]</span><br><span class="line">path.append(father)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Shortest path is:'</span>,</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> path[<span class="number">-1</span>:-len(path):<span class="number">-1</span>]:</span><br><span class="line"><span class="keyword">print</span> <span class="string">'&#123;&#125;--&gt;'</span>.format(i),</span><br><span class="line"><span class="keyword">print</span> path[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">graph = set_up_graph()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Graph as below:'</span></span><br><span class="line">pprint(graph)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'\n'</span></span><br><span class="line">costs, fathers = initialize_costs_n_fathers(graph)</span><br><span class="line">to_process = [i <span class="keyword">for</span> i <span class="keyword">in</span> graph.keys()]</span><br><span class="line">to_process.remove(<span class="string">'fin'</span>)</span><br><span class="line"><span class="keyword">while</span> to_process:</span><br><span class="line">node = find_lowest_cost(costs,to_process)</span><br><span class="line">neighbors = graph[node]</span><br><span class="line"><span class="keyword">for</span> neighbor <span class="keyword">in</span> neighbors:</span><br><span class="line">new_cost = costs[node] + graph[node][neighbor]</span><br><span class="line"><span class="keyword">if</span> new_cost &lt; costs[neighbor]:</span><br><span class="line">costs[neighbor] = new_cost</span><br><span class="line">fathers[neighbor] = node</span><br><span class="line">to_process.remove(node) <span class="comment"># keys donnot share names</span></span><br><span class="line">get_shortest_path(fathers)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'The lowest cost is &#123;&#125;.'</span>.format(costs[<span class="string">'fin'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>运行结果为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Graph as below:</span><br><span class="line">&#123;<span class="string">'A'</span>: &#123;<span class="string">'fin'</span>: 1&#125;,</span><br><span class="line"> <span class="string">'B'</span>: &#123;<span class="string">'A'</span>: 3, <span class="string">'fin'</span>: 5&#125;,</span><br><span class="line"> <span class="string">'fin'</span>: &#123;&#125;,</span><br><span class="line"> <span class="string">'start'</span>: &#123;<span class="string">'A'</span>: 6, <span class="string">'B'</span>: 2&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Shortest path is: start--&gt; B--&gt; A--&gt; fin</span><br><span class="line">The lowest cost is 6.</span><br></pre></td></tr></table></figure></p><p>也可以将上面的图改成是有环的图，就能验证到对有环图也是适用的。</p>]]></content>
      
      <categories>
          
          <category> 学艺更精 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python中的argv和argc</title>
      <link href="/2018/03/17/python%E4%B8%AD%E7%9A%84argv%E5%92%8Cargc/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>为什么<code>argv</code>中第一个，即index=0的内容就是文件名？</li><li>python中<code>argc</code>是用什么实现的？<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><code>argc</code>:argument counter，命令行参数个数<br><code>argv</code>:argument vector，命令行参数向量(内容)<h2 id="通过代码理解含义"><a href="#通过代码理解含义" class="headerlink" title="通过代码理解含义"></a>通过代码理解含义</h2>创建一个文件<code>arg_exam.py</code>，其中内容如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># argv</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">    <span class="keyword">print</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment"># argc</span></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">print</span> argc</span><br></pre></td></tr></table></figure></the></li></ul><p>在shell中运行一个简单的例子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python arg_exam.py hello I am an example</span><br></pre></td></tr></table></figure></p><p>输出为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arg_exam.py</span><br><span class="line">hello</span><br><span class="line">I</span><br><span class="line">am</span><br><span class="line">an</span><br><span class="line">example</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p><p>所以说，<code>argv</code>就是<code>python</code>命令后跟着的一系列命令参数的内容。<br>而<code>argc</code>（在C语言存在的变量）就是这些命令参数的个数了，在python中因为<code>argv</code>是个列表，其长度<code>len</code>自然就是<code>argc</code>了，所以python中并没有为<code>argc</code>特地设置一个方法或者属性。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>argv是在命令行中运行程序时跟在<code>python</code>命令后的所有内容，以空格为分界，得到各元素。</li><li>python中argc并不是一个特定属性或方法，而是可以直接通过<code>len(sys.argv)</code>获得。</li></ul>]]></content>
      
      <categories>
          
          <category> 学艺更精 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为Github page绑定自定义域名并实现https访问</title>
      <link href="/2018/03/14/%E4%B8%BAGithub-page%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%B9%B6%E5%AE%9E%E7%8E%B0https%E8%AE%BF%E9%97%AE/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><code>实现目标</code></excerpt></p><ul><li>获取自定义域名<code>yucichueng.me</code>;</li><li>将上述域名(及<strong>www</strong>域名)解析到<code>yucichueng.github.io</code>IP地址;</li><li>将域名解析服务托管于<strong>CloudFlare</strong>;</li><li>获取<strong>SSL</strong>证书，使网站可以通过<strong>https</strong>访问。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="获取自定义域名"><a href="#获取自定义域名" class="headerlink" title="获取自定义域名"></a>获取自定义域名</h2>我购买的域名是<code>yucicheung.me</code>。<br>一级域名<code>me</code>在<a href="https://au.godaddy.com/" target="_blank" rel="noopener">GoDaddy</a>网站进行购买。心仪的域名可以在网站<a href="https://www.whois.net/" target="_blank" rel="noopener">whois</a>查看是否被注册，未被注册可在相应域名商处购买。<br><strong>Tips:</strong>如果是在<code>Godaddy</code>购买的域名，建议购买隐私服务(不泄露个人信息)，不是很便宜，所以建议可以直接从国内域名商处购买，赠送隐私保护服务。<h2 id="域名解析到Github-page"><a href="#域名解析到Github-page" class="headerlink" title="域名解析到Github page"></a>域名解析到Github page</h2>购买域名后，在对应域名供应商处一般会提供域名解析服务，我们需要对解析服务进行配置。<br>对我来说，就要在<code>Godaddy</code>域名解析服务处进行配置。<h3 id="修改域名服务商解析记录"><a href="#修改域名服务商解析记录" class="headerlink" title="修改域名服务商解析记录"></a>修改域名服务商解析记录</h3></the></li></ul><ol><li>点击主页右上角自己的账户名–&gt;点击<strong>manage my domains</strong>–&gt;在<strong>My Domains</strong>选择<strong>Manage DNS</strong>;<div align="center"><br><img src="\img\manage_DNS.png" alt="manage_DNS"><br></div></li><li>添加<code>CNAME</code>和<code>A</code>解析记录，使<code>www</code>网址和<code>@</code>(即本身)都指向自己的github page；<br>按以下表格分别添加<strong>A</strong>和<strong>CNAME</strong>两条解析记录：</li></ol><table><thead><tr><th style="text-align:center">类型type</th><th style="text-align:center">主机host</th><th style="text-align:center">指向points to</th><th style="text-align:center">TTL(Time To Live)</th></tr></thead><tbody><tr><td style="text-align:center"><code>A</code></td><td style="text-align:center"><code>@</code></td><td style="text-align:center">github page的IP 地址</td><td style="text-align:center">600</td></tr><tr><td style="text-align:center"><code>CNAME</code></td><td style="text-align:center"><code>www</code></td><td style="text-align:center">github page的网址</td><td style="text-align:center">600</td></tr><tr><td style="text-align:center"><strong>A记录</strong>：<br>用来指定域名的IPv4地址<br>如要将域名指向一个IP地址<br>添加A记录<br><br><strong>CNAME</strong>：<br> 如要将域名指向另一域名<br>再由该域名提供ip<br>添加CNAME记录</td><td style="text-align:center"><strong>www</strong>：<br>解析后域名为<strong><a href="http://www.yucicheung.me" target="_blank" rel="noopener">www.yucicheung.me</a></strong><br><br><strong>@</strong>：<br>解析主域名<strong>yucicheung.me</strong><br><br><strong>*</strong>：<br>泛解析，匹配其他所有域名，<strong>*.yucicheung.me</strong></td><td style="text-align:center">对于<code>A记录</code>:<br>要指向IP地址<br><br>对于<code>CNAME</code>:<br>要指向一个域名<br><br></td><td style="text-align:center">指地方dns缓存域名记录的时间,缓存失效后会再次获取<br><br><strong>600</strong>:<br>建议采用600<br><br><strong>60</strong>:<br>如果经常修改IP可用(修改可快速生效),长期使用略影响解析速度<br><br><strong>3600</strong>:<br>如果IP极少变动(一年几次),可选择 3600,解析速度快</td></tr></tbody></table><p><strong>Tips</strong>：github page的IP地址可以通过以下命令获取：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping yucicheung.github.io</span><br></pre></td></tr></table></figure></p><h3 id="添加github仓库的域名解析记录"><a href="#添加github仓库的域名解析记录" class="headerlink" title="添加github仓库的域名解析记录"></a>添加github仓库的域名解析记录</h3><ol><li><p>按以下命令在自己的github仓库中添加CNAME文件，其中填入购买的域名。或者可以在仓库的<strong>settings</strong>中设置<strong>Custom Domain</strong>设置好自己的域名，github会自动添加CNAME文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ touch CNAME</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'yucicheung.me'</span>&gt; CNAME</span><br></pre></td></tr></table></figure></li><li><p>稍等一下就可以通过购买域名<strong>yucicheung.me</strong>访问<strong>yucicheung.github.io</strong>了，但是这时只能通过<code>http</code>访问自定义域名而非<code>https</code>。</p></li></ol><h2 id="通过HTTPS访问自定义域名"><a href="#通过HTTPS访问自定义域名" class="headerlink" title="通过HTTPS访问自定义域名"></a>通过HTTPS访问自定义域名</h2><p>在完成上述操作以后，只能通过<code>HTTP</code>协议传输(明文传输),于是在通过自定义域名访问自己的github page时，发现浏览器提示<strong>该网址不安全，没有合格的安全证书</strong>，不能通过<code>https</code>(密文传输)访问。</p><h3 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h3><p><strong>HTTP</strong>是明文传输协议，传输内容容易被嗅探和篡改。<br>而<strong>HTTPS</strong>，即<strong>HTTP over SSL/TLS</strong>,是添加了一层<strong>SSL(Secure Sockets Layer，安全套接层)</strong>，或者是<strong>TLS(Transport Layer Security,传输层安全协议)</strong>，所以<strong>HTTPS</strong>就可以视为<strong>HTTP</strong>和<strong>SSL/TLS</strong>协议的组合。<br><br><br><strong>HTTPS</strong>能做到良好的保密性(防嗅探)，真实性(防篡改)，完整性(防域名劫持和域名欺骗)。</p><h3 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h3><p><strong>SSL</strong>是<strong>TLS</strong>的前身，但<strong>TLS</strong>通常也被标志为<strong>SSL</strong>。<br><strong>SSL/TLS</strong>协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息(会话秘钥)，服务器收到密文后，用自己的私钥解密。<br>这个公钥就放在数字证书中。只要证书是可信的，公钥就是可信的。</p><h3 id="申请SSL证书"><a href="#申请SSL证书" class="headerlink" title="申请SSL证书"></a>申请SSL证书</h3><p>SSL证书由你的NS(Name Server，域名服务商)颁发，由于<code>GoDaddy</code>的SSL证书超级贵，所以我们可以迁移到免费提供SSL的NS处，比如国内的<strong>DNSpod</strong>(国内都需要备案),还有国外的<strong>Netlify</strong>和<strong>Cloudflare</strong>，从速度和操作性考虑，本人选择了<code>Cloudflare</code>。</p><ol><li>到<a href="https://www.cloudflare.com/" target="_blank" rel="noopener">Cloudflare官网</a>注册；</li><li>根据指引点击<strong>Add Site</strong>，添加自定义域名<strong>yucicheung.me</strong>，会自动开始扫描DNS解析记录；</li><li>扫描完成后，<strong>Cloudflare</strong>会选择给我们分配两个NS地址，将这两个地址替换<strong>GoDaddy</strong>上的原NS地址，等待生效；<div align="center"><br><img src="/img/change_ns.png" alt="change_ns"><br></div></li><li>在<strong>Cloudflare</strong>上检查自己网站的状态，显示为<code>Active</code>时表示NS更改成功；<div align="center"><br><img src="/img/Active.png" alt="active"><br></div></li><li>在<strong>Cloudflare</strong>将自己网站的<strong>SSL</strong>状态改变为<code>Full</code>状态，等待<strong>Status</strong>变为<code>Active Certificate</code>，通常生效需要十几分钟。<div align="center"><br><img src="/img/full_SSL.png" alt="ssl"><br></div></li><li>再访问自定义域名时，就可以看见是<code>https</code>传输，网址前也有一把绿色小锁,可以看到这个证书其实是Cloudflare的证书。<br><div align="center"><br><img src="/img/https.png" alt="https"><br><img src="/img/ssl.png" alt="ssl"><br></div><h2 id="CDN-关于访问速度"><a href="#CDN-关于访问速度" class="headerlink" title="CDN:关于访问速度"></a>CDN:关于访问速度</h2>如果因为NS在国外，担心访问速度，可以稍微放心。<br><strong>Cloudflare</strong>本身提供<code>CDN</code>(content delivery network,内容分发网络)服务，是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，就近获取网络内容传递给用户。<br>免费服务一般只能加速<strong>css、js</strong>的引用，而对于<strong>html</strong>和<strong>图片</strong>的加速通常是付费服务。<br>实验过之后，确实是图片加载会稍慢一些，但是整体速度是可以接受的，<strong>如果实在介意速度，建议通过国内NS解析网址</strong>。<br>另：发现Cloudflare已经和baidu合作针对企业级用户启动加速服务，一个节点服务海外访问者，另一个服务国内访问者。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li></ol><ul><li>最后实现的整个系统可以这么理解：就相当于由github提供主机（相当于寄存在github的服务器），自己购买域名，域名指向服务器文件进行展示。</li><li>原本的github主页，域名解析由GitHub负责，SSL证书由github.com提供，所以可以安全访问。现在的域名解析由Cloudflare服务，SSL证书也由其提供。</li></ul>]]></content>
      
      <categories>
          
          <category> 玩点别的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> SSL </tag>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu下用hexo搭建github博客</title>
      <link href="/2018/03/13/Ubuntu%E4%B8%8B%E7%94%A8hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>配置环境：<strong>Ubuntu 16.04</strong></li><li>搭建目标：<strong>Github page(username.github.io)</strong></li><li>搭建程序：<strong>hexo</strong></li><li>在新建分支hexo下管理部署文件，最终部署到主分支master进行网站发布，涉及第三方应用绑定。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install git-core <span class="comment"># 已安装请略过</span></span><br></pre></td></tr></table></figure></the></li></ul><p>并且在你的github主页创建一个repo，命名为<code>username.github.io</code>，比如对我来说就是<code>yucicheung.github.io</code>。本帖不细述，请参考<a href="https://pages.github.com/" target="_blank" rel="noopener">github page基本指南</a>。</p><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure><p>重新开启终端使<code>nvm</code>命令生效。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nvm ls-remote <span class="comment"># 查看所有可用版本</span></span><br><span class="line">$ nvm install v8.10.0 <span class="comment"># 选择最新稳定版本</span></span><br><span class="line">$ node -v <span class="comment">#显示v8.10.0表示安装成功</span></span><br></pre></td></tr></table></figure></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install npm <span class="comment"># 安装package manager</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure><h2 id="hexo基础配置"><a href="#hexo基础配置" class="headerlink" title="hexo基础配置"></a>hexo基础配置</h2><h3 id="初始化模板"><a href="#初始化模板" class="headerlink" title="初始化模板"></a>初始化模板</h3><p>用<code>hexo</code>命令初始化一个空文件夹。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init hexo</span><br></pre></td></tr></table></figure></p><p>hexo安装所需的新文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo</span><br><span class="line">hexo $ npm install</span><br></pre></td></tr></table></figure></p><p>改变<code>hexo/</code>文件夹下的<code>_config.yml</code>的一些简单配置包括<code>title</code>,’author’等，之后就可以用以下命令预览。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server <span class="comment"># 默认端口4000</span></span><br></pre></td></tr></table></figure></p><p><strong>Notice:</strong>如果端口<code>4000</code>被占用，或者更换端口预览，或者解除占用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1：更换端口</span></span><br><span class="line">$ hexo server -p 5000</span><br><span class="line"><span class="comment"># 方法2：解除端口占用</span></span><br><span class="line">$ lsof -i:4000</span><br><span class="line">$ <span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure></p><h2 id="更改主题为yelee"><a href="#更改主题为yelee" class="headerlink" title="更改主题为yelee"></a>更改主题为yelee</h2><p>首先要在<a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">hexo-themes</a>中选择一个喜欢的主题，从git上<code>clone</code>到本地<code>themes/</code>文件夹下并命名为<code>yelee</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo/</span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:MOxFIVE/hexo-theme-yelee.git themes/yelee</span><br></pre></td></tr></table></figure></p><p>然后更改<code>hexo/_config.yml</code>中<code>theme: landscape</code>改为<code>theme: yelee</code>，<code>themes/lanscape</code>文件夹可删除。<br>再用<code>hexo server</code>或<code>hexo s</code>就可以预览为新主题了。<br>具体theme中相应主题配置应参考对应theme的官方文档，如<a href="http://moxfive.coding.me/yelee/" target="_blank" rel="noopener">yelee的官方文档</a>。</p><h2 id="部署到网站"><a href="#部署到网站" class="headerlink" title="部署到网站"></a>部署到网站</h2><p><strong>说明:网站的部署其实就是生成静态文件，<code>hexo</code>下所有生成的静态文件会放在<code>public/</code>文件夹中，所谓部署<code>deploy</code>其实就是将<code>public/</code>文件夹中内容上传到git仓库<code>yucicheung.github.io</code>中。</strong><br>要准备将静态文件部署到自己的git主页，首先需要安装一个用于部署的插件<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>，这个插件可以自动将<code>public/</code>文件中内容上传到<code>master</code>下(即用于生成github.io界面的文件)。<br><strong>如果不装插件，也可以手动进行文件复制。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>然后在<code>hexo/_config.yml</code>的<code>deploy</code>部分配置以下语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/yucicheung/yucicheung.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>需要在根据需要修改<code>hexo/</code>和<code>hexo/themes/</code>下的<code>_config.yml</code>文件后，就可以进行生成和部署了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate <span class="comment"># 或hexo g</span></span><br><span class="line">$ hexo deploy <span class="comment"># 或hexo d</span></span><br></pre></td></tr></table></figure></p><p><code>deploy</code>时需要github的账户和密码，自动上传文件完成部署。<br><strong>Tips：</strong>网站再次进行部署时，还需要清理<code>public</code>文件夹内容，重新生成部署，用以下命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean <span class="comment"># 尤其在更换主题后需使用</span></span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></p><h2 id="管理hexo文件"><a href="#管理hexo文件" class="headerlink" title="管理hexo文件"></a>管理hexo文件</h2><p>最好的办法是在<code>username.github.io</code>主页创建两个分支，一个<code>master</code>分支(由deployer管理)，一个<code>hexo</code>分支（我们自己管理）。<br>在把自己的<code>username.github.io</code>仓库克隆到本地后，<code>cd username.github.io</code>，进行以下操作。<br>创建hexo分支并切换到该分支。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hexo</span><br></pre></td></tr></table></figure></p><p>将<code>hexo/</code>文件夹下所有内容拷贝到<code>username.github.io/hexo/</code>下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp -r ~/hexo/ ~/yucicheung.github.io/</span><br></pre></td></tr></table></figure></p><p>将修改加入并push到分支<code>hexo</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"commet"</span></span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure></p><p>这样文件管理就很方便了。</p><h2 id="第三方部署"><a href="#第三方部署" class="headerlink" title="第三方部署"></a>第三方部署</h2><p>因为第三方部署跟主题有很大关系，而<a href="http://moxfive.coding.me/yelee/5.Vendor/" target="_blank" rel="noopener">主题文档</a>中说明得比较清楚，我主要讨论一下文档中说明不清的Google站长认证问题。</p><h3 id="Google站长验证"><a href="#Google站长验证" class="headerlink" title="Google站长验证"></a>Google站长验证</h3><ol><li>如果要按照主题定义的方法操作，需要在验证备用方法中选择<code>html验证</code>。</li><li>Google验证，默认方法是提供给你一个html文件，拷贝至<code>theme</code>下的<code>source</code>文件中，在<code>generate</code>的时候会原样生成。<br><strong>Tips:</strong>同理，如果有每次生成都要保存的html文件，请都放置在此文件夹下。如果是<code>README.md</code>文件要保持不被渲染，请添加到<code>hexo/source/</code>下，并且在<code>hexo/_config.yml</code>中配置<code>skip_render: README.md</code>。<h2 id="文章的发表"><a href="#文章的发表" class="headerlink" title="文章的发表"></a>文章的发表</h2>先生成draft，然后发表。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new draft <span class="string">"title"</span> <span class="comment">#在source/_draft下生成md文件</span></span><br><span class="line">$ hexo publish <span class="string">"title"</span></span><br></pre></td></tr></table></figure></li></ol><p>草稿默认不会显示在页面中，可在配置文件中把render_drafts 参数设为 true 来预览草稿。<br><strong>或</strong>直接生成新文章。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"title"</span> <span class="comment"># 自动生成title.md在_posts下</span></span><br></pre></td></tr></table></figure></p><p>如果要删除文章的话在source下删除文章后，重新生成和部署就可以了</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://hexo.io/zh-cn/docs" target="_blank" rel="noopener">hexo文档</a></li><li><a href="http://moxfive.coding.me/yelee" target="_blank" rel="noopener">yelee主题配置帖</a></li></ol>]]></content>
      
      <categories>
          
          <category> 玩点别的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
