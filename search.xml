<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>C++相关知识点及建议总结(二)</title>
      <link href="/2018/08/18/C++%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%8A%E5%BB%BA%E8%AE%AE%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>上一篇笔记请参阅<a href="http://yucicheung.me/2018/08/18/C++%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%8A%E5%BB%BA%E8%AE%AE%E6%80%BB%E7%BB%93(%E4%B8%80" target="_blank" rel="noopener">C++相关知识点及总结(一)</a>)<br>本文包含：</excerpt></p><ul><li>语言特性</li><li>内存管理不当的隐患</li><li><code>new</code>/<code>delete</code>及<code>malloc</code>/<code>free</code>相关的内存管理操作<br><em>智能指针及<code>RAII</code>相关的内存管理会放在下一篇</em></li></ul><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><ul><li>大端与小端：所谓大端就是指高位值在内存中放低位地址，所谓小端是指低位值在内存中放低位地址。C/C++中判断大小端的方法是，利用联合体Union中char数组和int可以公用同一段空间地址的特点，检查输出地址和字节的对应关系。</li><li>如果是实现语言之间的混合编程<ul><li>一种方式就是语言对另一种语言留了接口;</li><li>另一种方式就是通过比更低级的公用语言形式(如二进制目标文件，可以是动态静态链接库等)进行沟通。但是因为很多语言(JAVA,Python)的虚拟机本身就是C++写的，所以可以直接在虚拟机中用C++就完成所有的操作。<ul><li>Python本身就是一个C库，其功能实现都是通过动态链接库实现，在C++调用时需要包含头文件进行实现。</li></ul></li></ul></li><li><p>C++中的结构体和类的联系和差别</p><ul><li>C++中的结构体不止可以定义成员变量，还可以定义成员函数，<strong>结构体和类可以实现相类似的功能</strong>(可以说类是结构体的演化版本)，同样结构体可<strong>以实现继承，多态</strong>。</li><li><strong>差别一</strong>在于默认继承方式，结构体默认继承方式是private，而类的继承方式默认是Public。<strong>差别二</strong>在于是否能定义模板。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">  Base(<span class="keyword">int</span>)&#123;&#125;<span class="comment">//定义</span></span><br><span class="line">  Base(<span class="built_in">string</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="keyword">using</span> Base::Base;</span><br><span class="line">  Derived(<span class="keyword">double</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Derived(<span class="number">2011</span>);    <span class="comment">//Base::Base(2011)</span></span><br><span class="line">  Derived(<span class="string">"C++11"</span>); <span class="comment">//Base::Base("C++11")</span></span><br><span class="line">  Derived(<span class="number">0.33</span>);    <span class="comment">//Derived::Derived(0.33)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>extern &quot;C&quot;</code>（链接指示）:C++程序优势需要调用其他语言编写的函数，最常见的是调用C语言编写的函数，像其他所有名字一样，其他语言中的函数名字也必须在C++中进行声明，并且该声明必须指定返回类型和形参列表。低于其他语言编写的函数来说，编译器检查其调用的方式与处理普通C++函数的方式相同，但是<strong>生成的代码有所区别</strong>。</p><ul><li>注意：要想把C++代码和其他语言编写的代码放在一起使用，必须要求有权访问该语言的编辑器，并且该编辑器与当前C++编辑器是兼容的(GCC)；</li><li>声明非C++函数的方式：extern+字符串字面值常量+普通函数声明，其中字符串字面值常量代表函数所用的语言，如”Ada”;<ul><li>链接指示不可能出现在类定义/函数定义的内部，同样的链接指示必须在函数的每个声明中都出现；</li><li>注：C++从C语言继承的标准库函数可以定义成C函数，但并非必须；决定使用C还是C++实现C标准库是每个C++实现的事情；</li></ul></li><li>指向extern “C”函数的指针<ul><li>编写函数所用的语言是函数类型的一部分(因为C++和C中对函数编译得到的结果是不同的)，因此，<strong>对于使用链接指示定义的函数，它的每个声明都必须使用相同的链接指示</strong>，如<code>extern &quot;C&quot; void (*pf)(int);</code></li><li>指向C++函数的指针和指向C函数的指针是不一样的类型，因为类型不匹配，之间不能进行赋值操作；</li></ul></li><li><strong>链接指示对整个声明都有效</strong>：不仅对函数有效，对作为返回类型或形参类型的函数指针也有效，如<code>extern &quot;C&quot; void f1(void(*)(int));</code>中，其传入的参数，即函数指针必须是一个指向C函数的指针。<ul><li>那如果我们希望给C++函数传入一个指向C函数的指针，就必须使用类型别名了，如<code>extern &quot;C&quot; typedef void FC(int);void f2(FC*);</code>;</li></ul></li><li>也可以将C++函数导出到其他语言，如<code>extern &quot;C&quot; double calc(double dparm){/*...*/}</code>,则编译器会为函数生成适合指定语言的代码；</li><li>在C和C++中编译同一个源文件，方式如下：<ul><li>在编译C++版本程序时定义<strong>cplusplus，在编译C++程序时做相应条件编译，如`#ifdef </strong>cplusplus<code>\</code>extern “C”<code>\</code>#endif`</li></ul></li><li>链接指示与重载函数的相互作用依赖于目标语言，如果目标语言支持重载函数，则为该语言实现链接指示的编译器可能也支持重载这些C++函数<ul><li>C语言不支持重载函数，因此一个”C”链接指示只能作用于重载函数中的一个。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单语句链接指示</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"><span class="comment">//复合语句链接指示</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span>*,<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//整个头文件进行链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>字符串：<code>std::string</code>和<code>std::wstring</code>(w for wide)</p><ul><li>在C++中见到的字符串，如果是<code>&quot;Hello&quot;</code>就代表是ASCII编码，如果是<code>L&quot;Hello&quot;</code>就代表是Unicode编码;</li><li>上述字符串分别对应着std::string类(一个字符占一个字节)和std::wstring类（一个字符占两个字节）。</li></ul></li><li>所谓<strong>闭包(closure)</strong>:又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。在lua中local本地变量的值被保存在函数中，即每次进入函数时local变量会记录上次的取值。</li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="隐患及相关概念"><a href="#隐患及相关概念" class="headerlink" title="隐患及相关概念"></a>隐患及相关概念</h3><ul><li>野指针、迷途指针（悬空指针），都是不指向任何合法对象的指针。<ul><li>迷途指针(dangling pointer)<ul><li>产生：当所指的对象被释放或收回，但是对该指针没有做任何的修改，以至于该指针仍指向已经回收的内存地址，这就是迷途指针(调用malloc()和free()库函数常产生的问题)；</li><li>可能后果：若操作系统将这部分已经释放的内存重新分配给另外一个进程，而原来的程序重新引用现在的迷途指针，向其中写入数据，则这部分程序内容将被破坏，而导致程序错误。这种类型的程序错误，通常会导致segment fault和一般的保护错误。</li><li>其他常见错误：返回一个基于栈分配的局部变量的地址时，一旦调用的函数返回，分配给这些变量的空间将回收，此时它们拥有的是垃圾值，如<code>return &amp;num</code>，如果要使它的生命周期边长，应该将其声明为<code>static</code>。</li></ul></li><li>野指针(wild pointer)：<ul><li>产生：未初始化的指针。注意<code>static pointer</code>不是野指针，因为静态变量会被初始化为0。</li><li>可能产生与dangling pointer一样的问题，包括程序，信息泄露(指针指向一段只读的内存)，或者访问权限的增加。</li></ul></li><li>避免迷途指针的错误：<ul><li>C++中推荐使用智能指针(smart pointer)，用RAII的方法管理资源，当对象的引用计数变为0时，将自动回收对象。<ul><li>或者在指针指向内存空间被释放时，立即将该指针置为空指针或者非法地址，这样在指针被引用时，程序就会立即停止。</li></ul></li></ul></li></ul></li><li>内存泄漏：内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存，或者说是<strong>在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费</strong>。<ul><li>可能导致可用内存的数量越来愈少，从而导致计算机性能降低。</li><li>在现代操作系统中，一个应用程序使用的常规内存在程序终止时被释放。这表示一个短暂运行的应用程序中的内存泄漏不会导致严重后果。但是在内存非常有限的系统中都可能导致非常严重的后果。</li></ul></li><li><a href="https://www.zhihu.com/question/40560123/answer/129719625" target="_blank" rel="noopener">内存溢出导致安全问题</a>:所谓内存溢出就是内存越界，内存越界存在一种情况就是调用栈溢出(stackoverflow)，还有一种情况是缓冲区溢出，这两种情况都会导致安全漏洞：<ul><li>strcpy会一直复制直到碰到<code>\0</code>，很多平台的栈变量是按照地址顺序倒着分配的（高地址向低地址），所以destination溢出后会先修改先前定义的变量，这样黑客就可以把is_administrator改为true，从而造成<strong>缓冲区溢出攻击</strong>。</li><li><strong>栈溢出攻击</strong>：在栈上分配length字节的空间，再往栈顶放上一个data。当Length十分大，会把data挤到栈空间之外，此时<strong>如果编译器不做越界检查</strong>的话，那么黑客只要用客户端送特定的length和data，就能改写服务器的任意内存(比如黑客可以修改服务器代码的机器码，注入一些JMP指令跳转到黑客想执行的函数)。</li><li>当然以上两个例子还说明一件事是：不要相信用户的输入。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓冲区溢出攻击</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_LENGTH = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">bool</span> is_administrator = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> destination[MAX_LENGTH];</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> source = read_string_from_client(); <span class="comment">//内容存储在缓冲区</span></span><br><span class="line"><span class="built_in">strcpy</span>(destination,source.c_str());</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈溢出攻击</span></span><br><span class="line"><span class="keyword">int</span> length = read_int_from_client();</span><br><span class="line"><span class="keyword">char</span> buffer[length];    <span class="comment">//栈空间分配</span></span><br><span class="line"><span class="keyword">int</span> data = read_int_from_client();</span><br></pre></td></tr></table></figure><ul><li>堆(数据结构)：堆可以被看作一棵树的数组对象，用队列做任务调度时总是反复提取第一个作业并运行，但是实际情况中kn <ul><li>堆的实现通过构造二叉堆(binary heap)即二叉堆的一种，可以当作优先队列使用。其特点如下<ul><li>任意节点均小于(或大于)它的所有后裔，最小元(或最大元)在堆的根上（性），根结最大的堆是最大堆/大根堆，最小是最小堆/小根堆；</li><li>堆总是一棵完全树，即除最底层外其他层的结点都被元素填满，且最底层尽可能从左到右填入。</li></ul></li><li>为什么要设计堆这种数据结构?</li></ul></li><li>栈：栈是由高地址向低地址延伸的，<strong>每个函数的每次调用，都有自己独立的一个“栈帧”</strong>，这个栈帧中维持着所需要的各种信息，就比如会有一个寄存器ebp和另一个寄存器esp分别指向当前栈帧的底部(高地址)和顶部(低地址)。当前的<strong>ebp,b for base</strong>和<strong>esp,s for stack</strong>之间的栈就是当前函数的<strong>栈帧</strong>，下一条CPU要执行的指令，其地址会存储在EIP寄存器中。<ul><li><strong>栈帧</strong>：就是编译器存储在用户栈上的每一次函数调用设计的相关信息的记录单元，那么显然<strong>栈上保持了N个栈帧的实体</strong>，或者说栈帧将栈分割成立N个记录块，但记录块大小不是固定的，因为<em>栈帧会保存如：函数入参、出参、返回地址和上一个栈帧的栈底指针等信息，还保存了函数内部的自动变量</em>。</li></ul></li></ul><h3 id="C-C-内存管理详细-不含智能指针"><a href="#C-C-内存管理详细-不含智能指针" class="headerlink" title="C/C++内存管理详细(不含智能指针)"></a><a href="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/" target="_blank" rel="noopener">C/C++内存管理详细(不含智能指针)</a></h3><ul><li>内存分配：在C++中，内存分成5个区，其分布和功能如下：<ul><li><strong>栈</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上进行创建，函数执行结束时这些存储单元被自动释放。栈分配运算内置于处理器的指令集中，效率高，但是可分配内存有限(由编译器分配的空间)。</li><li><strong>堆</strong>：由<code>new</code>分配的内存块，由程序员分配的空间，假如程序员没有及时释放掉空间，那么在程序结束后，操作系统会自动回收。</li><li><strong>自由存储区</strong>：由<code>malloc</code>分配的内存块，由<code>free</code>进行回收。</li><li><strong>全局/静态存储区</strong>：全局变量和静态变量被分配到同一块内存中。</li><li><strong>常量存储区</strong>：存放常量(const)，不允许修改。</li></ul></li><li>一个例子<code>void f(){int*p = new int[5];}</code>中就是在堆中分配一块内存，并且将其指针存放在栈中。这个时候要释放这个数组，就应该用<code>delete []p;</code>而不是<code>delete p;</code>(因为<code>char*</code>和<code>char[]</code>还是不一样的)，那编译器就会根据cookie信息去进行内存释放工作。<strong>堆与栈的区别</strong>：<ul><li>管理方式不同<ul><li>栈是编译器管理，堆的占用和释放都是由程序员进行控制的；</li></ul></li><li>空间大小不同<ul><li>在32位系统下，一般堆的内存可以达到4G的空间，可以说堆内存几乎是没有限制的。但是对于栈，一般都有一定空间大小(跟编译器有关)，比如在VC6下默认的栈空间大小是1M</li></ul></li><li>能否产生碎片不同<ul><li>对于堆来说，频繁的new/delete操作会造成内存空间的不连续，从而造成大量碎片，使程序效率降低；</li><li>但是对于栈来说，因为总是先进后出不存在内存块不连续的问题。</li></ul></li><li>生长方向不同<ul><li>堆的生长方向是向上的，即向着内存地址增加的方向；</li><li>栈的生长方向是向下的，即向着内存地址减小的方向增长。</li></ul></li><li>分配方式不同<ul><li>堆总是动态分配的，需要程序员手动释放；</li><li>栈存在静态分配和动态分配的：<ul><li>其中<strong>静态分配</strong>是由编译器完成的(比如局部变量的分配)；</li><li><strong>动态分配</strong>是由<code>alloca</code>函数进行分配的(这个函数会在栈帧的调用处上分配一定空间，当调用<code>alloca</code>的函数返回到调用位置时，这些临时空间会被自动释放)，栈的动态分配是由编译器自己进行释放的。</li></ul></li></ul></li><li>分配效率不同：<ul><li>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，包括：分配专门的寄存器来存放栈的地址、入出栈都有专门指令，因此栈的效率会比较高。</li><li>堆是C/C++函数库提供的，其机制非常复杂，比如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果找不到(可能是因为内存碎片过多)，就可能调用系统功能区(<strong>用户模式和内核模式的切换</strong>)增加程序数据段的内存空间，如此便有机会分到足够大小的内存，然后进行返回。</li></ul></li></ul></li><li><p><code>malloc/free</code>和<code>new/delete</code>：</p><ul><li>类型差别：前者是函数，后者是操作符；</li><li>为什么有了malloc/free之后还要有new/delete的存在？<ul><li>因为只用<code>malloc/free</code>无法满足动态对象的要求，具体说来，对象在创建时要执行构造函数，在消亡之前要执行析构函数。而malloc/free是库函数，不再编译器的控制权限之内，<strong>不能够把执行构造函数和析构函数的任务强加给malloc/free</strong>。因此才需要一个能完成动态内存分配和初始化工作的运算符<code>new</code>,以及一个能完成清理和内存释放工作的运算符<code>delete</code>。</li></ul></li><li>应用上的差别：<ul><li>对于内置类型来说，new/delete和malloc/free没有什么差别；</li><li>对于自定义类型来说，new/delete会自动调用构造和析构函数，而malloc/free函数则不会；</li><li>对于C函数来说，只能使用malloc/free进行内存管理。</li></ul></li><li>malloc/free的使用要点<ul><li><code>void *malloc(size_t size);</code>返回类型是<code>void *</code>，因此及进行赋值时需要进行显式类型转换，通常<code>size</code>用<code>sizeof</code>获得；</li><li><code>void free(void* memblock);</code>使用起来会更加简单，因为指针的类型以及它所指的内容都是被记录的的，因此可以轻松释放内存。</li></ul></li><li>new/delete使用要点<ul><li><code>new</code>运算符内置了sizeof、类型转换和类型安全检查的功能；</li><li>对于非内置数据对象，new在创建对象的同时还完成了初始化(调用构造函数)的工作；</li><li>要注意<code>new</code>创建对象数组时，只能使用无参数构造函数进行。</li><li>对于delete，在释放对象数组时，注意不要丢了符号<code>[]</code>，否则会引起内存泄漏。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建内置类型数组</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用不同构造函数创建对象</span></span><br><span class="line">Obj* a = <span class="keyword">new</span> Obj;</span><br><span class="line">Obj *b = <span class="keyword">new</span> Obj(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>常见的内存错误及其解决：</p><ul><li>内存分配未成功，却被使用；应提前检查内存不为NULL，比如可以加入断言机制<code>assert(p!=NULL)</code>进行检查。</li><li>内存分配成功，但是未初始化就被引用；因此记住总是在创建附近赋初值。</li><li>内存分配成功且初始化，但是操作越界（比如在进行数组操作时）。</li><li>忘记释放内存，导致内存泄漏：malloc/free或者new/delete的个数必须保证相同。</li><li>内存释放了却继续使用<ul><li>可能因为程序中对象调用关系特别复杂，实在难以搞清楚某个对象是否释放内存，此时应该重新设计数据结构。</li><li>return栈内存中的指针/引用，因为在脱离子函数后这些地址就会被释放，其值就无效。</li><li>使用free/delete释放内存后，没有将指针设置为<code>NULL</code>，此时就会导致产生<strong>野指针</strong>（指向不合法对象的指针）。要避免这些错误应当：<ul><li>使用malloc/new分配内存时，应立即检查指针是否为NULL</li><li>及时为动态内存/数组赋初值，防止未被初始化的内存作为右值被使用</li><li>避免数组或者指针下标越界</li><li>释放内存后要及时将指针设置为NULL</li></ul></li></ul></li></ul></li><li>指针与数组的差别<ul><li>创建位置：数组或者在静态存储区被创建(全局数组)，或者在栈上被创建(编译器)。<strong>数组名对应的是一块内存</strong>，其地址和容量在生命周期内会保持不变。而指可以指向任意类型的内存块，其特征是“可变”，因此常用指针来操作动态内存（指针会更灵活，也更危险）。</li><li>错误修改：对于常量字符串<code>&quot;helloWorld&quot;</code>，存储于静态存储区，理论上其值应该是保持不变的，但是可以用<code>char*</code>指针指向它并且做修改，这在概念上是不当的。</li><li>计算内存容量：运算符<code>sizeof</code>的使用，当后面跟着的是数组名，则返回数组长度，而如果是<code>char*</code>即char型指针，返回的就是一个指针变量的字节数(4字节，32位)，并不是指针所指内存的容量(除非是在内存申请时记住它，否则要时刻直到指针所指内容的大小是不现实的)。但是，<strong>当数组名char[]作为参数传递到函数时时，数组会自动退化为同类型的指针</strong>(<code>char*</code>)。</li></ul></li><li>指针参数传递内存的方法<ul><li>错误方法1：对于传入的参数p，在函数中会产生其一个副本，因此函数中的malloc只是对副本内容做了改变，但是对原参数并没有修改；并且因为未做<code>free</code>释放，这个函数每调用一次就会泄漏一块内存，</li><li>正确方法1：形参为指向指针的指针；对指向数组指针的内存进行直接修改，确保指针指向数组起始地址；</li><li>正确方法2：利用函数返回值来传递在堆(<strong>heap</strong>)上分配的动态内存；</li><li>错误方法2：如果是在栈(<strong>stack</strong>)上分配的动态内存会在函数运行结束时被<strong>自动释放</strong>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//错误方法1</span><br><span class="line">void GetMemory(char* p,int num)</span><br><span class="line">&#123;</span><br><span class="line">  p = (char*) malloc(sizeof(char)*num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//正确方法1：传递指向指针的指针</span><br><span class="line">void GetMemory2(char **p, int num)</span><br><span class="line">&#123;</span><br><span class="line">  *p = (char*) malloc(sizeof(char)) *num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//正确方法2：用函数返回值传递堆上分配的动态内存</span><br><span class="line">char* GetMemory3(int num)&#123;</span><br><span class="line">  char*p = (char*) malloc(sizeof(char))*num);</span><br><span class="line">  return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//错误方法2：无法指针传递在栈上分配的内存</span><br><span class="line">char *GetString(void)&#123;</span><br><span class="line">  char p[] = &quot;Hello World&quot;; //栈上分配内存，将字符串内容拷贝到栈上分配的数组中</span><br><span class="line">  return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 概念不合适的传递方法：传递指向静态存储区的指针</span><br><span class="line">char *GetString2(void)&#123;</span><br><span class="line">  char *p = &quot;Hello World&quot;;  //静态存储区中内容尽量保证只读</span><br><span class="line">  return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></the>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 编译 </tag>
            
            <tag> 书写规范 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++相关知识点及建议总结(一)</title>
      <link href="/2018/08/18/C++%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%8A%E5%BB%BA%E8%AE%AE%E6%80%BB%E7%BB%93(%E4%B8%80)/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>这些天在gist上记录了很多知识点，本来想等秋招结束后，统一整理，但是笔记慢慢也积累得很长了，担心到最后整理起来太麻烦，所以先把目前为止记录的内容整理好，之后做成一个小系列，可能会比较方便一些。<br>正在看的<em>Effective C++</em>中有很多很好的内容，但是没有总结在这里面，这部分内容主要是平时从<em>C++ Primer</em>、stackOverflow、wikipedia、MSDN和博客上了解到的相关内容的汇总。</excerpt></p><p>本文包含：<code>1.</code>编译相关;<code>2.</code>语言特性;<code>3.</code>编写规范。<br><a id="more"></a></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="编译相关"><a href="#编译相关" class="headerlink" title="编译相关"></a>编译相关</h2><ul><li>在<code>g++</code>编译一系列文件时，不要包含<code>.h</code>文件，因为<code>.h</code>内容都已经包含在<code>.cpp</code>文件中。<strong>Header files are never compiled.</strong></li><li><p><a href="https://zh.cppreference.com/w/cpp/preprocessor/conditional" target="_blank" rel="noopener">#ifdef and #ifndef Directives</a>:主要用于预处理器控制编译。</p><ul><li>头文件中的#ifndef是一个很关键的东西，比如两个c文件都include同一个头文件，而两个头文件要编译成同一个可运行文件，此时会有大量的声明冲突，所以一般把头文件内容放在#ifndef和#endif中。</li><li>identifier理论上可以是自由命名的，对于头文件来说，每个标识都应该是唯一的。标识的命名规则一般是<strong>头文件名全大些，文件中的”.”变成下划线</strong>，如”stdio.h”变为”STDIO_H”(也就是说，如果没有定义这个identifier，就将identifier定义为以下到#endif为止的内容)。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> identifier</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> identifier</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//equivalent to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined identifier</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined identifier</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><a href="https://www.zhihu.com/question/21853681/answer/74134768" target="_blank" rel="noopener">关于程序语言是如何被编译，被解释执行的过程</a></p><ul><li>字节码和二进制机器码不是一个概念，字节码是在程序语言和二进制机器码中间的一个桥梁，最终被机器执行的仍然是二进制代码。</li></ul></li><li><p>VS中解决方案solution和工程project之间的区别：本质上，解决方案是由多个工程组成的，(每个工程是一个独立的软件模块，如一个程序和一个代码库)，这样做的好处是解决方案可以共享文件和代码库。通常为解决方案创建一个主文件夹，包括所有的工程文件夹，但对于之包含一个工程的解决方案来说，习惯于把解决方案和项目放在一个解决方案中。</p></li><li><code>hpp</code>文件是将<code>.cpp</code>的实现代码混入<code>.h</code>头文件当中，定义与实现都包含在同一文件，则该类的调用者只需要include该hpp文件即可，无需再将cpp加入到project中进行编译。而实现代码<strong>将直接编译到调用者的obj文件中，不再生成单独的obj</strong>,采用hpp将大幅度减少调用 project中的cpp文件数与编译次数，也不用再发布烦人的lib与dll,因此非常适合用来编写公用的开源库。<ul><li>优点：一般已预编译;</li><li>缺点：不能包含全局对象和全局函数;类之间不可循环调用;不可使用静态成员。<code>redefined identifier</code>。</li></ul></li><li><p><code>make</code>:根据Makefile编译源代码，连接，生成目标文件，可执行文件。</p><ul><li><code>make clean</code>：清除之前编译产生的可执行object文件(“.o”)；</li><li><code>make distclean</code>:要清除所有生成的文件，包括configure生成的文件，如Makefile; </li><li><code>make install</code>:将编译成功的可执行文件安装到系统目录中，一般为<code>/usr/local/bin</code>目录;</li><li><code>make dist</code>:产生发布软件包文件(distribution package)，这个命令产生可执行文件及相关文件打成一个<code>tar.gz</code>压缩文件作为发布软件的软件包;一般会在当前目录下生成一个名字为<code>PACKAGE-VERSION.tar.gz</code>的文件，其中<code>PACKAGE</code>/<code>VERSION</code>是我们在configure.in中定义的<code>AM_INIT_AUTOMAKE(PACKAGE,VERSION)</code>。</li><li><code>make distcheck</code>：生成发布软件包并对其进行测试检测，以确定发布包的正确性。该操作将自动打开压缩包文件，执行configure，执行make确认编译不出现错误，并且提示软件已经准备好，可以发布了。</li></ul></li><li><p>宏定义<code>_WIN32</code>和<code>WIN32</code></p><ul><li><code>WIN32</code>是由工具包或者构建环境定义(user-defined)的，所以它不使用执行预留的命名空间中;</li><li><code>_WIN32</code>是编译器定义的，所以使用下划线把它放置在执行预留的命名空间中。</li></ul></li><li><p>C++关于DLL文件的导入导出</p><ul><li>使用<code>__declspec(dllexport)</code>关键字从DLL导出数据、函数、类或类成员函数。<code>__declspec(dllexport)</code>会将导出指令添加到对象文件中，因此您不需要使用<code>.def</code>文件，仅当解决任何命名约定更改时才必须重新编译DLL和依赖.exe文件;</li><li>生成DLL时，通常创建一个包含正在导出的函数原型和/或类的头文件，并将<code>__declspec(dllexport)</code>添加到头文件中的声明中，若要提高代码的可读性，请为<code>__declspec(dllexport)</code>定义一个宏并且对正在导出的每个符号使用该宏，如<code>#define DllExport __declspec(dllexport)</code>,则该命令将函数名存储在DLL的导出表中。</li><li>为使用DLL生成的应用程序创建头文件时，在公共符号的声明上使用<code>__declspec(dllimport)</code>(不论是.def文件导出还是用<strong>declspec(dllexport)关键字导出均有效),为使导入的可执行文件能够访问DLL的公共数据符号和对象，必须使用`</strong>declspec(dllimport)`;</li><li><p>如要提高代码的可读性，请为<code>__declspec(dllimport)</code>定义一个宏，然后使用该宏声明每个导入的符号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define DllImport __declspec(dllimport)</span><br><span class="line"></span><br><span class="line">DllImport int j;</span><br><span class="line">DllImport void func();</span><br></pre></td></tr></table></figure></li><li><p>对DLL和客户端应用程序可以使用相同的头文件，因此需要使用特殊的预处理器符号来指示是<em>生成DLL</em>还是<em>生成客户端应用程序</em>，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#ifdef _EXPORTING</span><br><span class="line">   #define CLASS_DECLSPEC __declspec(dllexport)</span><br><span class="line">#else</span><br><span class="line">   #define CLASS_DECLSPEC __declspec(dllimport)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">class CLASS_DECLSPEC CExampleA : public CObject</span><br><span class="line">&#123;...class definition...&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>关于<code>#if defined()</code>用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CREDIT)</span></span><br><span class="line">  credit();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(DEBIT)</span></span><br><span class="line">  debit();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  printerror();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><ul><li><p>C++中<code>int main(int argc, char* argv[])</code></p><ul><li><code>argc</code>表示命令行输入参数的总个数，文件名本身也占1;</li><li><code>argv</code>表示所有命令行输入参数的内容，其中<code>arg[0]</code>即文件名。</li></ul></li><li><p><code>size_t</code>:SIZE_T is a ULONG_PTR representing the maximum number of bytes to which a pointer can point.This type is declared as <code>typedef ULONG_PTR SIZE_T;</code>,</p><ul><li>size_t代表目标平台能够使用的最大的类型，不仅考虑到跨平台特性，还兼顾了效率。</li></ul></li><li><p><code>&lt;stdint.h&gt;</code>中带有<code>_t</code>(t for type)后缀数据类型的介绍</p><ul><li>用以下<code>_t</code>的数据类型，即我们可以以确定字节数表示一个数据类型，而不用为了适应不同CPU，而去改变数据类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef unsigned char uint8_t</span><br><span class="line">typedef unsigned int uint16_t</span><br><span class="line">typedef unsigned long int uint32_t</span><br><span class="line">typedef unsigned long long int uint64_t</span><br><span class="line"></span><br><span class="line">typedef signed char int8_t</span><br><span class="line">typedef signed int int16_t</span><br><span class="line">typedef signed long int int32_t</span><br><span class="line">typedef signed long long int64_t</span><br></pre></td></tr></table></figure></li></ul></li><li><p>关于C++中的左值lvalue和右值rvalue：</p><ul><li>每个C++表达式是左值/右值;</li><li>表达：<ul><li>凡是真正存在于内存当中，而不是寄存器当中的值就是左值，其余的都是右值。(<strong>dereference<code>&amp;</code>可以成功的都是左值，其余都是右值</strong>)。</li><li><strong>左值</strong>，在定义它的表达式以外保留的对象;<strong>右值</strong>，在定义它的表达式以外不保留的临时值。</li><li><strong>编译器将已命名的右值引用视为左值，而将未命名的右值引用视为右值</strong>。</li><li>左值引用符号<code>&amp;</code></li><li>右值引用符号<code>&amp;&amp;</code><ul><li>完美转发：在进行数值引用时，保留参数的左值/右值属性。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span> + <span class="number">4</span>;<span class="comment">//x是左值，3+4是右值</span></span><br><span class="line"><span class="comment">//perfect forwarding</span></span><br><span class="line"><span class="comment">//usage：factory function or constructor</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T，<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="function">T <span class="title">createObject</span><span class="params">(T1&amp;&amp; t1)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> T(forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> myFive2=createObject&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);   <span class="comment">//rvalue</span></span><br><span class="line"><span class="keyword">int</span> five=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> myFive=createObject&lt;<span class="keyword">int</span>&gt;(five); <span class="comment">//lvalue</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p><code>nullptr</code>是C++11的新标准，表示空指针，等同于<code>NULL</code>。如果在qt中支持，需要添加<code>CONFIG+=c++11</code>。</p></li><li><p><a href="https://stackoverflow.com/questions/172587/what-is-the-difference-between-g-and-gcc/172592#172592" target="_blank" rel="noopener">关于<code>g++</code>和<code>gcc</code>的差异</a>:</p><blockquote><p>g++ is equivalent to  gcc -xc++ -lstdc++ -shared-libgcc (the 1st is a compiler option, the 2nd two are linker options). This can be checked by running both with the -v option (it displays the backend toolchain commands being run).</p></blockquote></li><li><p><a href="https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html" target="_blank" rel="noopener"><code>volatile</code>关键字</a><strong>用来设定某个对象的存储位置在内存中，而不是寄存器中</strong>。因为一般的对象编译器可能会将其的拷贝放在寄存器中用以加快指令的执行速度</p><ul><li>当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为volatile，该关键字告诉编译器不应该对这样的对象进行优化。</li><li>什么情况下要使用这个关键字？<ul><li>代码中“内嵌汇编操纵栈”这种方式属于编译无法识别的变量改变；</li><li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li><li>多任务环境下各任务间共享的标志应该加volatile；</li><li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</li></ul></li><li>volatila限定符的用法和const很类似，起到对类型额外修饰的作用：同样地，如果出现在<code>*</code>左边，修饰被指物，如果出现在<code>*</code>右边，修饰的就是指针</li><li>就像可以定义const限定符一样，也可以定义相应的volatile函数，它只能被volatile对象调用(与const类比)。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> display_register;  <span class="comment">//该int值可能发生改变</span></span><br><span class="line"><span class="keyword">volatile</span> Task * curr_task;      <span class="comment">//curr_task指向一个volatile对象</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>元编程Meatprogramming：是指某类计算机程序的编写，这类计算机程序编写或操控其他程序作为它们的数据(比如cmake操控cpp文件或shell操控程序文件)，或者在运行时完成部分本该在编译时完成的工作。</p><ul><li>编写元程序的语言称之为元语言，被操作的语言称为目标语言。</li><li>一门语言同时也是自身的元语言的能力称为反射。</li></ul></li></ul><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>在<code>.h</code>文件中不要写<code>using namespace std</code>。</li><li>对成员变量的命名不要采用下划线开头(下划线开头的变量通常是编译器自留的)，而应该采用下划线结尾。</li></ul></the>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 编译 </tag>
            
            <tag> 书写规范 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>书籍推荐</title>
      <link href="/2018/08/17/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文记录了我自己在学习过程中看到的整理清晰或者帮助深刻理解的书籍、帖子等,所以希望记录下来,以供自己查阅(依这个目的来看,本帖应该会持续更新的样子)。</excerpt></p><p>相关阅读笔记记录在我的<a href="https://github.com/yucicheung/LearningNotes" target="_blank" rel="noopener">github仓库</a>。<br><a id="more"></a></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="Linux篇"><a href="#Linux篇" class="headerlink" title="Linux篇"></a>Linux篇</h2><p>1.<a href="http://blog.csdn.net/fanzheng220112583/article/details/7780250" target="_blank" rel="noopener">Compile、Make和Build的区别：不止适应于编程语言,也适用于Linux环境</a> </p><ol><li><a href="http://www.powerxing.com/linux-environment-variable/" target="_blank" rel="noopener">设置Linux环境变量的方法和区别_Ubuntu：讲解非常清晰</a></li><li><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/base/index.html#" target="_blank" rel="noopener">Linux的shell命令基础篇(偶尔忘记了可以随时查阅)</a></li><li><em>《Linux从入门到精通(第2版)》刘忆智 等编著</em>：是针对Ubuntu和openSUSE进行介绍的书记，要点比较全面，而且清晰易懂，<strong>适合入门</strong>，能对Linux有基础认识。</li><li><em>《鸟哥的Linux私房菜 基础学习篇》 鸟哥 著</em>：适合更为全面的Linux知识讲解，适用Linux管理员，和需要Linux有更为深入的运用时查看的一本书，讲解实例系统为CentOS。<h2 id="编程语言篇"><a href="#编程语言篇" class="headerlink" title="编程语言篇"></a>编程语言篇</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3>1.<em>《Python编程从入门到实践》Eric Matthes 著  袁国忠 译</em>：讲解思路很流畅，实例代码为python3编写，<strong>适合入门</strong>。</li><li><em>《Python核心编程（第二版）》Wesley J.Chun著 宋吉广 译</em>：基础点讲解的很清晰且全面，例子也足够丰富，<strong>适合进阶</strong>。</li><li><em>《Python Cookbook（中文版）》David Beazley &amp; Brian K.Jones著 陈舸 译</em>：适合作为手册，专治各种疑难杂症，<strong>适合解决项目问题</strong>。<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3></li><li><em>《C++程序设计(第3版)》 谭浩强 著</em>：书中还是有一些错误的，你在敲代码或尝试理解深层机制的时候就能发现，其实还是有废话，也可能是因为我可能不是它的目标人群。对于你上手C++还是有帮助的，而且可以顺便帮助复习C语言。所以如果你不敢挑战《C++ primer》就先从这本书开始也不错，但不要死扣细节，因为书上的细节可能是错的，用来熟悉上手就可以。</li><li><em>《C++ Primer(中文版)》 Stanley B.Lippman 著 王刚 译</em>。其实我这本书还没读完，但是就其相对更为简洁的语言和更接近工程的知识面来说，它会更适合已经有计算机基础知识和编程基础的人。当你总是忍不住吐槽前面那本书时，就说明你应该选择这本书来学习C++。</li><li><em>《Effective C++(中文版)》 Scoott Meyers 著 侯捷 译</em>：超级推荐的一本书！！最近准备秋招发现很多面试题在询问关于C++语言特性，甚至C++编译过程的问题的相关解答早就已经被撰写在这本书中。所以书里的建议一边是规范开发的建议，一边也帮助我们理解C++的实现机制，确实是一本好书。</li></ol><h2 id="代码基础"><a href="#代码基础" class="headerlink" title="代码基础"></a>代码基础</h2><ol><li><em>《代码整洁之道》 Robert C.Martin著 韩磊 译</em>：才看到前四章(想要腾出几天时间看书基本是不可能的，都是挤时间看)，第一次知道命名规范，怎样的注释是好的，代码应该怎样组织会比较清晰，有过一段时间的实践，确实有改进代码的可读性(就不会写着写着自己开始嫌弃自己的代码)。因此是很好的一本书，其中大部分是Java写的，还能顺便学点新语言。</li><li><em>《大话设计模式》 程杰 著</em>：几乎看完的一本书(编程语言为C#)，不仅包括大概20种设计模式，还把面向对象编程的几大原则也讲的非常清楚。其实了解设计模式主要是为了理解面向对象的好处，可以给以后如何设计出易维护，易扩展的工业级代码打个基础。并且设计模式确实在效率上对开发有一些帮助，所以先了解是好的。</li><li><em>《大话数据结构》 程杰 著</em>：秋招时几乎人手一本的树，基本上内容和本科的《数据结构》差不多，但是讲解会更加通俗、解释会更丰富一些。并且因为作者自身有工业背景，所以数据结构会结合一些应用场景讲解，能与实际问题更好地联系起来。因此还是很不错的。</li><li><em>《算法图解》Aditya Bhargava著 袁国忠 译</em>：图像很多非常有利与理解，选取的算法比较精要，除了其中一两章写的不是特别有利于知识框架整理，都写的很好。总体是一本好的入门书，配合python使用，在github上有开源库。但是其中的算法不是很全，对秋招这样的大场合不适合。</li></ol><h2 id="git篇"><a href="#git篇" class="headerlink" title="git篇"></a>git篇</h2><ol><li><a href="https://www.cnblogs.com/rossoneri/p/4446440.html" target="_blank" rel="noopener">适合于github的Markdown语法，包含特有语法</a></li><li><a href="http://www.bootcss.com/p/git-guide/" target="_blank" rel="noopener">一页有趣的git指南</a></li><li><a href="https://progit.bootcss.com/#_pro_git" target="_blank" rel="noopener">pro git</a></li><li><em>《GitHub入门与实践》 大塚弘记 著  刘斌 译</em>：很详细的教程，又很简明，讲解不罗嗦，包含一些常用但网上不常见的命令(比廖雪峰教程好用)。<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2></li><li><em>《SQL必知必会 》 Ben Forta 著 钟鸣 译</em>：这本书也是很多人推荐给我的，其实这本书很小，总共也就200+页，英文名叫《Sam Teach Yourself SQL in 10 Minutes》…不要信10分钟就能学完，知识点很多，尤其对于从没有接触过数据库的人来说，信息量很大还是需要较长时间来消化的。知识点多而且总结全面，所以书是很不错的。<h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2></li><li><em>《图解TCP/IP》 竹下隆史 著 乌尼日其其格  译</em>：本科看过《计算机网络》，没怎么看懂。这本书毕竟因为图画比较多，然后说理比较形象，因此比较好懂，可以加速理解网络协议和通信过程。</li></ol><h2 id="团队管理"><a href="#团队管理" class="headerlink" title="团队管理"></a>团队管理</h2><ol><li><em>《人件》Tom DeMarco 著 肖然 译</em> ：一本名号很响的书籍，花了差不多12个小时的阅读时间。书里面主要讲什么是好的软件开发团队，如何构建这样一个team，当然这种问题一定是没有方法的，但是作者提出了他们的观察和建议。只要在任意一个项目团队中参与过，都一定能和你的经历match的描述。对我的意义在于更加清楚了解我处在一个什么样的环境中，到什么是一个好的工作环境，什么是一个合适的管理方式，对于我们作为项目团队的一员该如何表现还是有启发作用的，也有一些有趣的观点。当然我不是要做什么管理人才，我只是偶尔换个脑子，看看闲书偷个懒。</li></ol></the>]]></content>
      
      <categories>
          
          <category> Documenting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Recommendation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>qmake手册记录</title>
      <link href="/2018/07/10/qmake%E6%89%8B%E5%86%8C%E8%AE%B0%E5%BD%95/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><code>qmake</code>基本概念介绍;</li><li><code>pro</code>文件编写示例;</li><li><code>pro</code>文件高级编写语法。<br><code>qmake</code>是Trolltech公司创建的主要用来给qt项目在<strong>不同平台和编译器书写Makefile的工具</strong>。用<code>qmake</code>，开发者可以创建一个简单的“项目”(.pro文件)然后运行<code>qmake</code>在不同平台下生成适当的Makefile。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="qmake相关基本概念"><a href="#qmake相关基本概念" class="headerlink" title="qmake相关基本概念"></a>qmake相关基本概念</h2><h3 id="几个名词说明"><a href="#几个名词说明" class="headerlink" title="几个名词说明"></a>几个名词说明</h3><ul><li><p><strong><code>QMAKESPEC</code>环境变量</strong></p><ul><li><strong>必须设置为你当前所使用的平台和编译器的组合</strong>，否则跨平台编译不会成功。比如，如你使用的是win+msvc，就该把环境变量设为win32-msvc，如果使用的是Solaris和g++，就该设置为solaris-g++。</li><li>在<code>qt/mkspecs</code>中的每一个目录里面，都有一个包含平台和编译器特定信息的<code>qmake.conf</code>文件，这些设置适用于你要使用<code>qmake</code>的任何项目，一般不要进行修改，</li></ul></li><li><p>项目(.pro)文件</p><ul><li>用于告诉qmake关于为这个应用程序创建makefile所需要的细节，如，一个源文件和头文件的列表，任何应用程序特定配置(如一个必须要连接的额外库、或者一个额外的包含路径)，都应该放到<code>.pro</code>项目文件中。</li></ul></li><li><p><code>#</code>注释</p><ul><li>可以用<code>#</code>号为项目文件添加注释。注释由”#”符号开始，直到这行结束。</li></ul></li></ul><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>模板变量告诉<code>qmake</code>为这个应用程序生成哪种makefile，有以下可供使用的选择：</p><ul><li><code>app</code>：建立一个应用程序的makefile。这是<strong>默认值</strong>，如果模板没有被指定，这个就会被使用;</li><li><code>lib</code>：建立一个库的makefile(库的文件结构关系，如何被应用程序链接);</li><li><code>vcapp</code>：建立一个库的Visual Studio项目文件;</li><li><code>vclib</code>：建立一个库的Visual Studio项目文件;</li><li><code>subdirs</code>：这是一个特殊的模板，它可以创建一个能够进入特定目录并且为一个项目文件生成makefile并且为它调用make的makefile。</li></ul><h4 id="“app”模板"><a href="#“app”模板" class="headerlink" title="“app”模板"></a>“app”模板</h4><p>“app”模板告诉qmake为建立一个应用程序生成一个makefile，当使用这个模板时，下面这些qmake系统变量是被承认的，这些信息应该在你的<code>.pro</code>文件中指定好。</p><ul><li>HEADERS 应用程序中所有头文件的列表</li><li>SOURCES 应用程序中所有源文件的列表</li><li>FORMS 应用程序中的所有<code>.ui</code>文件(由Qt设计器生成)的列表。</li><li>LEXSOURCES 应用程序中的所有lex源文件的列表。</li><li>YACCSOURCES 应用程序中的所有yacc源文件的列表。</li><li>TARGET 可执行应用程序的名称，默认值为项目文件的名称。(如果需要扩展名，会自动被加上。)</li><li>DESTDIR 放置可执行程序目标的目录。</li><li>DEFINES 应用程序所需的额外的预处理程序定义的列表。</li><li>INCLUDEPATH 应用程序所需的额外的包含理解路径的列表。</li><li>DEPENDPATH 应用程序所依赖的搜索路径。</li><li>VPATH 寻找补充文件的搜索路径。</li><li>DEF_FILE 仅Windows需要：应用程序所需要连接的<code>.def</code>文件。</li><li>RC_FILE 仅windows需要：应用程序所需要的资源文件。</li><li>RES_FILE 仅windows需要：应用程序所要连接的资源文件。</li></ul><p>如果不需要任何额外的INCLUDEPATH,那么就不需要指定它，<code>qmake</code>会提供默认值，实际的项目文件可能是下面这个样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATE = app</span><br><span class="line">DESTDIR = c:\helloapp</span><br><span class="line">HEADERS += hello.h</span><br><span class="line">SOURCES += hello.cpp \</span><br><span class="line">main.cpp</span><br><span class="line">DEFINES += QT_DLL</span><br><span class="line">CONFIG += qt warn_on release</span><br></pre></td></tr></table></figure></p><p><strong>Note</strong>:如果条目是单值的，如template或工程目录，用“=”赋值;但如果是多值条目，使用”+=”来为这个类型添加条目。</p><h4 id="“lib”模板"><a href="#“lib”模板" class="headerlink" title="“lib”模板"></a>“lib”模板</h4><p>“lib”模板告诉qmake为建立一个库而生成makefile(根据makefile进行make之后库会被编译成可调用格式)，除了”app”模板中提到的系统变量，<strong>还有一个VERSION是被支持的</strong>，也需要在”.pro”文件中使用它们</p><ul><li>VERSION 目标库的版本号，如2.3.1。</li></ul><h4 id="“subdirs”模板"><a href="#“subdirs”模板" class="headerlink" title="“subdirs”模板"></a>“subdirs”模板</h4><p>“subdirs”模板告诉qmake生成一个makefile，可以进入到特定子目录并为这个目录中的项目文件生成makefile并为它调用make。</p><p>在这个模板中只有一个系统变量<em>SUBDIRS</em>可以被识别，这个变量中包含了所要处理的含有项目文件的子目录的列表。这个项目文件的名称和子目录是同名的，这样qmake就可以发现它，如，子目录名是”myapp”，则目录中的项目文件就该叫做<code>myapp.pro</code>。</p><h3 id="CONFIG变量"><a href="#CONFIG变量" class="headerlink" title="CONFIG变量"></a>CONFIG变量</h3><p>配置变量指定了编译器所要使用的选项和所需要被连接的库。配置变量的下面这些选项可以被qmake识别。</p><ul><li><p>这些选项控制着编译器相关标志</p><ul><li><code>release</code> 应用程序以release模式连编，如果”debug”被指定，它将被忽略(优先级低于debug)。</li><li><code>debug</code> 应用程序以debug模式连编。</li><li><code>warn_on</code> 编译器会输出尽可能多的警告信息，如”warn_off”被指定，它将被忽略</li></ul></li><li><p>这些选项定义了所需要连编的库/应用程序的类型</p><ul><li><code>qt</code> 应用程序是一个Qt应用程序(非console)，则Qt库会被连接;</li><li><code>thread</code> 应用程序是一个多线程应用程序;</li><li><code>X11</code> 应用程序是一个X11应用程序或库;</li><li><code>windows</code> 只用于“app”模板：应用程序是一个窗口应用程序;</li><li><code>console</code> 只用于“app”模板：应用程序是一个控制台应用程序;</li><li><code>dll</code> 只用于“lib”模板：库是一个共享库(dll);</li><li><code>staticlib</code> 只用于“lib”模板：库是一个静态库。</li><li><code>plugin</code> 只用于“lib”模板：库是一个插件，这将会使dll选项生效。</li></ul></li></ul><p>那比如，如果你的应用程序使用Qt库，并且你想把它连编为一个可调试的多线程的应用程序，<code>pro</code>文件中的CONFIG就应该如下设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG += qt thread debug</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：必须使用”+=”号。</p><h2 id="手动安装qmake"><a href="#手动安装qmake" class="headerlink" title="手动安装qmake"></a>手动安装qmake</h2><p>当Qt被连编时，默认情况下qmake也会被连编。<br>在手工连编Qt之前，下面<strong>这些环境变量必须被设置</strong>：<br>在设置QMAKESPEC时，可以从下面的可能的环境变量列表中进行选择(在<code>/usr/lib/x86_64-linux-gnu/qt5/mkspecs</code>可以查看到各平台的<code>qmake.conf</code>)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aix-64 hpux-64 irix-032 netbsd-g++ solaris-cc unixware7-g++ aix-g++ hpux-g++</span><br><span class="line">linux-cxx openbsd-g++ solaris-g++ win32-borland aix-xlc hpux-n64 linux-g++</span><br><span class="line">openunix-cc sunos-g++ win32-g++ bsdi-g++ hpubx-o64 linux-icc qnx-g++ tru64-cxx</span><br><span class="line">win32-msvc dgux-g++ hurd-g++ linux-kcc reliant-64 tru64-g++ win32-watc freebsd-g++</span><br><span class="line">irix-64 macx-pbuilder reliant-cds ultrix-g++ win32-visa hpux-acc irix-g++ macx-g++</span><br><span class="line">sco-g++ unixware-g hpubx-acc irix-n32 solaris-64 uninxware7-cc</span><br></pre></td></tr></table></figure></p><p><img src="pics/qt_makespec.png" alt="makespec"></p><p>当envvar是以下之一时，环境变量要设置到<code>qws/envvar</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linux-arm-g++ linux-generic-g++ linux-mips-g++ linux-x86-g++ linux-freebsd-g++ </span><br><span class="line">linux-ipaq-g++ linux-solaris-g++ qnx-rtp-g++</span><br></pre></td></tr></table></figure></p><ul><li><code>QTDIR</code>:必须设置到Qt被安装(或将被安装)到的地方。<br>在上述环境变量被设置后，在自己的编译环境下运行<code>make</code>(linux)或者<code>nmake</code>(win)。此时<code>qmake</code>就可以使用了。</li></ul><h2 id="10分钟学会使用qmake"><a href="#10分钟学会使用qmake" class="headerlink" title="10分钟学会使用qmake"></a>10分钟学会使用qmake</h2><h3 id="1-创建一个项目文件"><a href="#1-创建一个项目文件" class="headerlink" title="1. 创建一个项目文件"></a>1. 创建一个项目文件</h3><p><code>qmake</code>使用储存在项目(<code>.pro</code>)文件中的信息来决定Makefile中应该生成什么。</p><p>一个基本的项目文件包含关于应用程序的信息，如编译应用程序需要哪些文件，并且使用哪些基本配置设置。</p><ul><li>一个简单的示例项目文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SOURCES = hello.cpp</span><br><span class="line">HEADERS = hello.h</span><br><span class="line">CONFIG += qt warn_on release</span><br></pre></td></tr></table></figure></li></ul><p>对以上例子进行解析：</p><ul><li><code>SOURCES = hello.cpp</code>：<strong>指定实现应用程序的源文件程序</strong>。<em>当有多个文件时</em></li></ul><ol><li><p>可以把所个文件列在一行中，以空格分隔，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOURCES = hello.cpp main.cpp</span><br></pre></td></tr></table></figure></li><li><p>又或者将每个文件列在一个分开的行中，通过反斜线<code>\</code>另起一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SOURCES = hello.cpp \</span><br><span class="line">main.cpp</span><br></pre></td></tr></table></figure></li><li><p>或者单独列出每一个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SOURCES += hello.cpp</span><br><span class="line">SOURCES += main.cpp</span><br></pre></td></tr></table></figure></li></ol><ul><li><p><code>HEADERS = hello.h</code>：<strong>指定为这个应用程序创建的头文件</strong>。当有多个文件时，上述适用<code>SOURCES</code>的方法也一样适用于<code>HEADERS</code>文件。</p></li><li><p><code>CONFIG += qt warn_on release</code>：<strong>告诉qmake</strong>关于应用程序的配置信息。<em>用<code>+=</code>添加选项比做<code>=</code>替换是安全得多的</em>。</p><ul><li><code>qt</code>部分：告诉<code>qmake</code>这个应用程序是使用Qt来连编的，即<code>qmake</code>在为连接和为编译添加所需要的包含路径时就会考虑到Qt库;</li><li><code>warn_on</code>部分：告诉<code>qmake</code>把编译器设置为输出警告信息;</li><li><code>release</code>部分：告诉<code>qmake</code>应用程序需要被连编成一个发布的应用程序。那在开发过程中，也可以用<code>debug</code>来替换这里的<code>release</code>;</li></ul></li></ul><p><strong>项目文件就是扩展名为<code>.pro</code>的纯文本文件</strong>，<code>qmake</code>就是根据这个文件确定不同平台下项目的连编规则。发布的应用程序的执行文件的名称必须和项目文件的名称一样，但是扩展名是跟着平台而改变的。举例来说，一个叫做”hello.pro”的项目文件将会在Windows下生成<code>hello.exe</code>，而在Unix下生成”hello”。</p><h3 id="2-生成Makefile"><a href="#2-生成Makefile" class="headerlink" title="2. 生成Makefile"></a>2. 生成Makefile</h3><p>根据<code>.pro</code>项目文件，用<code>qmake</code>就可以生成Makefile：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qmake -o Makefile hello.pro</span><br></pre></td></tr></table></figure></p><p>对于VS用户，<code>qmake</code>也可以生成<code>.dsp</code>(developer studio project)文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qmake -t vcapp -o hello.dsp hello.pro</span><br></pre></td></tr></table></figure></p><h2 id="qmake教程"><a href="#qmake教程" class="headerlink" title="qmake教程"></a>qmake教程</h2><h3 id="pro文件编写配合qmake和make使用"><a href="#pro文件编写配合qmake和make使用" class="headerlink" title="pro文件编写配合qmake和make使用"></a>pro文件编写配合<code>qmake</code>和<code>make</code>使用</h3><p>以一个工程实现一个qmake的编写(在qtcreator中创建工程时，所有的配置信息都会被qt自动在<code>.pro</code>中写好)。当你的工程已经创建了以下文件：</p><ul><li><code>hello.cpp</code></li><li><code>hello.h</code></li><li><code>main.cpp</code></li></ul><p>我们按照以下顺序编写项目的<code>.pro</code>文件：</p><ul><li><p>添加源文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SOURCES += hello.cpp \</span><br><span class="line">main.cpp</span><br></pre></td></tr></table></figure></li><li><p>添加头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEADERS += hello.h</span><br></pre></td></tr></table></figure></li><li><p>目标名称</p><ul><li>会被设置为和项目文件一样的名称，但是为了适合平台所需要的后缀。如，win下应该目标名称为“hello.exe”，在Unix下应该是“hello”。</li><li>如果想为项目设置一个不同的名字，可以在项目文件中设置它：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TARGET = helloworld</span><br></pre></td></tr></table></figure></li></ul></li><li><p>设置<code>CONFIG</code>变量(当在qtcreator中创建工程时，配置信息在进行工程生成时已经被用户选择好且将相关信息配置到<code>pro</code>文件中)</p><ul><li>因为这是个qt程序，我们需要把”qt”放到CONFIG这一行中，这样<code>qmake</code>才会在连接时添加相关的库，并且保证<code>moc</code>和<code>uic</code>的连编行也被包含到Makefile中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG += qt</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>pro</code>文件编写完成后，可以在应用程序目录下的命令行中输入<code>qmake</code>命令来为应用程序生成<code>Makefile</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qmake -o Makefile hello.pro</span><br></pre></td></tr></table></figure></li><li><p>根据自己使用的编译器，输入<code>make</code>或者<code>nmake</code>。</p></li></ul><h3 id="使程序可以调试"><a href="#使程序可以调试" class="headerlink" title="使程序可以调试"></a>使程序可以调试</h3><p>应用程序的发布版本不包含任何调试符号或其他调试信息(发行版本进行了代码优化，也是为了运行流畅)。</p><p>在开发过程中，要是要生成一个含有相关调试信息的应用程序的调试版本，只要在项目文件的<code>CONFIG</code>变量中添加一个”debug”就可以简单实现。比如对于<code>hello.pro</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONFIG += qt debug</span><br><span class="line">HEADERS += hello.h</span><br><span class="line">SOURCES += hello.cpp</span><br><span class="line">SOURCES += main.cpp</span><br></pre></td></tr></table></figure></p><p>再<code>qmake -o Makefile hello.pro</code>就可以生成相应的<code>Makefile</code>，再用<code>make</code>或<code>nmake</code>就可以生成debug版本的可执行程序了。</p><h3 id="添加特定平台的源文件"><a href="#添加特定平台的源文件" class="headerlink" title="添加特定平台的源文件"></a>添加特定平台的源文件</h3><p>应用程序中与平台相关的文件，如现在有两个新文件<code>hello_win.cpp</code>、<code>hello_x11.cpp</code>要添加到项目中，不能仅仅添加到<code>SOURCES</code>变量中就结束，因为那会把两个文件都添加到Makefile中。这里需要做的事是<strong>根据<code>qmake</code>所运行的平台来使用相应的作用域进行处理</strong>。</p><ul><li><strong>为Windows平台添加的平台依赖的文件</strong>的简单的作用域看起来如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">win32&#123;</span><br><span class="line">SOURCES += hello_win.cpp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当<code>qmake</code>运行在windows上，它会把<code>hello_win.cpp</code>添加到源文件列表中，如果<code>qmake</code>运行在其他平台时，这部分就会被跳过。</p><ul><li><strong>添加一个X11依赖文件的作用域</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x11&#123;</span><br><span class="line">SOURCES += hello_x11.cpp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>之后像前面一样使用<code>qmake</code>来生成Makefile，之后是<code>make</code>/<code>nmake</code>。此时项目文件应该像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CONFIG += qt debug</span><br><span class="line">HEADERS += hello.h</span><br><span class="line">SOURCES += hello.cpp \</span><br><span class="line">main.cpp</span><br><span class="line">win32&#123;</span><br><span class="line">SOURCES += hello_win.cpp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x11&#123;</span><br><span class="line">SOURCES += hello_x11.cpp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="如果一个指定文件不存在，停止qmake"><a href="#如果一个指定文件不存在，停止qmake" class="headerlink" title="如果一个指定文件不存在，停止qmake"></a>如果一个指定文件不存在，停止qmake</h3><p>当某个文件不存在时，也许不想生成一个Makefile。</p><p>我们可以通过使用<code>exists()</code>函数来检查一个文件是否存在，然后使用<code>error()</code>函数把正在运行的<code>qmake</code>停下来，这和作用域的工作方式一样，只是要将这个函数替换作用域条件。<em>其实前面的作用域条件都是bool值,bool值为真就执行作用域中语句，否则不执行</em>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!exists(main.cpp)&#123;</span><br><span class="line">error(&quot;No main.cpp file found&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么此时使用<code>qmake</code>生成Makefile文件，当缺少<code>main.cpp</code>文件时，error信息显示，并且<code>qmake</code>会停止处理。</p><h3 id="检查多于一个的条件"><a href="#检查多于一个的条件" class="headerlink" title="检查多于一个的条件"></a>检查多于一个的条件</h3><p>假设使用Windows并且在命令行运行你的应用程序时你想<strong>显示debug语句</strong>，这就需要在连编程序时使用console设置，否则看不到输出，将<code>console</code>添加到CONFIG行中。那如果我们想要(1)在程序运行在win下;(2)且debug在CONFIG行中时;添加console。</p><ul><li><p>这就需要两个嵌套的作用域，然后将设置放在最里面的作用域中，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">win32&#123;</span><br><span class="line">debug&#123;</span><br><span class="line">CONFIG += console</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>嵌套的作用域也可以使用冒号连接起来</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">win32:debug&#123;</span><br><span class="line">CONFIG += console</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>到这里，你就已经准备好为你的开发项目写项目文件了。</p><h2 id="qmake高级概念–语法"><a href="#qmake高级概念–语法" class="headerlink" title="qmake高级概念–语法"></a>qmake高级概念–语法</h2><p>qmake提供了更强大的功能，如可以使用一个简单的项目文件为多个平台生成makefile。</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><ul><li><code>=</code> 简单分配一个值给一个变量，如同赋值操作(<strong>覆盖</strong>原有值)</li><li><code>+=</code> 向一个变量的值的列表中<strong>添加</strong>一个值。 </li><li><code>-=</code> 从一个变量的值的列表中移去一个值。</li><li><code>*=</code> 仅在一个值<strong>不存在</strong>于一个变量的值的列表中时，把它<strong>添加</strong>进去。如<code>DEFINES *= QT_DLL</code>只在QT_DLL未被定义在预处理定义的列表中时，才被添加进去。</li><li><code>~=</code> 替换任何与指定正则表达式匹配的任何值(与vim命令相同，模板匹配替换)。如<code>DEFINES ~= s/QT_[DT].+/QT</code>对所有QT_D或QT_T开头的变量，替换成QT。</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>功能类似于条件判断语句，当前面的表达式为bool真，作用域中的语句会被执行。</p><ul><li><p>例如，以下语句作用是在windows下使用qmake时，将QT_DLL添加到makefile中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">win32&#123;</span><br><span class="line">DEFINES += QT_DLL</span><br><span class="line">&#125;</span><br><span class="line"># 也可以用冒号换成以下形式表示</span><br><span class="line">win32:DEFINES += QT_DLL</span><br></pre></td></tr></table></figure></li><li><p>又比如在除了win平台以外的平台做些处理，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!win32&#123;</span><br><span class="line">DEFINES += QT_DLL</span><br><span class="line">&#125;</span><br><span class="line"># 或者</span><br><span class="line">!win32:DEFINES += QT_DLL</span><br></pre></td></tr></table></figure></li><li><p>CONFIG行中任何条目都是一个作用域。如<code>CONFIG += warn_on</code>其中的<code>warn_on</code>就是一个作用域。这个特性使得考虑所有可能的编译器标志成为可能：可以针对不同编译器标志采取不同的措施，使项目易于维护和移植。如下例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CONFIG += qt warn_on debug</span><br><span class="line">debug&#123;</span><br><span class="line">TARGET = myappdebug</span><br><span class="line">&#125;</span><br><span class="line">release&#123;</span><br><span class="line">TARGET = myapp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>也可以<strong>定义嵌套作用域</strong>，为避免写出过多嵌套作用域，可以<strong>使用冒号来嵌套作用域</strong>。如以下语句检查平台是windows且线程设置是否设定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">win32&#123;</span><br><span class="line">thread&#123;</span><br><span class="line">DEFINES += QT_THREAD_SUPPORT</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"># 用冒号嵌套作用域</span><br><span class="line">win32:thread&#123;</span><br><span class="line">DEFINES += QT_THREAD_SUPPORT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还可以用<code>else</code>作用域提供替代声明，当之前的作用域是false时，对应的<code>else</code>作用域会被处理。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">win32:xml&#123;</span><br><span class="line">message(Building for Windows)</span><br><span class="line">SOURCES += xmlhandler_win.cpp</span><br><span class="line">&#125;else:xml&#123;</span><br><span class="line">SOURCES += xmlhandler.cpp</span><br><span class="line">&#125;else&#123;</span><br><span class="line">message(&quot;Unknown configuration&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>除了DEFINE、SOURCES和HEADERS这些系统变量外，用户还可以创建自己的变量，然后在作用域中使用它们。<br>当对一个给定的名字进行赋值时，qmake就会<strong>创建新的变量</strong>。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MY_VARIABLE = value</span><br></pre></td></tr></table></figure></p><p>也可以通过在其他任何一个变量的变量名前加<code>$$</code>来把这个变量的值分配给当前的变量。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MY_DEFINES = $$DEFINES</span><br></pre></td></tr></table></figure></p><p>现在MY_DEFINES变量包含了项目文件在此时DEFINES变量的值，这也和下面的语句等价：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MY_DEFINES = $$&#123;DEFINES&#125;</span><br></pre></td></tr></table></figure></p><p>第二种方法允许你将变量的内容附加到另一个值后，而不在两者之间添加空格(相当于拼接)。比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TARGET = myproject_$$&#123;TEMPLATE&#125;</span><br></pre></td></tr></table></figure></p><p>变量可以被用于存储环境变量的内容，这些值在<code>qmake</code>被运行时会被评估(evaluated)，或者会被包含在生成的Makefile中而在项目被构建时进行评估。</p><p>要在运行qmake时获取环境变量的内容，使用<code>$$(...)</code>操作符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DESTDIR = $$(PWD)</span><br><span class="line">message(The project will be installed in $$DESTDIR)</span><br></pre></td></tr></table></figure></p><p>在上面的赋值中，PWD环境变量的值会在工程文件被处理时被读出。</p><p>如果要在处理生成的Makefile时才去获取一个环境变量的值，使用<code>$(...)</code>操作符，<em>推测主要差别是什么时候用常量值去取代变量，节省空间</em>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DESTDIR = $$(PWD)</span><br><span class="line">message(The project will be installed in $$DESTDIR)</span><br><span class="line"></span><br><span class="line">DESTDIR = $(PWD)</span><br><span class="line">message(The project will be installed in the value of PWD)</span><br><span class="line">message(when the Makefile is processed)</span><br></pre></td></tr></table></figure></p><p>在上述的赋值操作中，<code>PWD</code>的值在项目文件(<code>pro</code>文件)被处理时会立即被读出，但是$(PWD)会在生成的Makefile中被赋值给<code>DESTDIR</code>。这使得构建过程更加灵活，只要环境变量在Makefile被处理时被正确设置了的话。</p><p>还有一个特殊的<code>$$[...]</code>操作符，可以被用来获取构建Qt时不同的设置选项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">message(Qt version:$$[QT_VERSION])</span><br><span class="line">message(Qt is installed in $$[QT_INSTALL_PREFIX])</span><br><span class="line">message(Qt resources can be found in the following loacations:)</span><br><span class="line">message(Documentation:$$[QT_INSTALL_DOCS])</span><br><span class="line">message(Header files:$$[QT_INSTALL_HEADERS])</span><br><span class="line">message(Libraries:$$[QT_INSTALL_LIBS])</span><br><span class="line">message(Binary files(executables):$$[QT_INSTALL_BINS])</span><br><span class="line">message(Plugins:$$[QT_INSTALL_PLUGINS])</span><br><span class="line">message(Data files:$$[QT_INSTALL_DATA])</span><br><span class="line">message(Translation files:$$[QT_INSTALL_TRANSLATIONS])</span><br><span class="line">message(Settings:$$[QT_INSTALL_SETTINGS])</span><br><span class="line">message(Examples:$$[QT_INSTALL_EXAMPLES])</span><br><span class="line">message(Demonstrations:$$[QT_INSTALL_DEMOS])</span><br></pre></td></tr></table></figure></p><p>可以通过这个操作符获取的变量，经常被用于使得整合到Qt中的第三方的插件和组件可用。比如说，按照下面的声明，一个Qt Designer插件可以被安装为Qt Designes的内建插件目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target.path = $$[QT_INSTALL_PLUGINS]/designer</span><br><span class="line">INSTALLS += target</span><br></pre></td></tr></table></figure></p><h3 id="变量处理函数"><a href="#变量处理函数" class="headerlink" title="变量处理函数"></a>变量处理函数</h3><p><code>qmake</code>提供了一系列内建函数来处理变量的内容，这些函数处理提供给它们的变量并且返回一个值，或者一个列表的值作为结果。为了能将值赋给一个变量，<strong>需要<code>$$</code>操作符来进行变量内容的取值</strong>赋值操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HEADERS = model.h</span><br><span class="line">HEADERS += $$OTHER_HEADERS</span><br><span class="line">HEADERS = $$unique(HEADERS)</span><br></pre></td></tr></table></figure></p><p>有可能需要一个你自己的函数，用于处理变量的内容，这些函数按照如下方式定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defineReplace(functionName)&#123;</span><br><span class="line">#function code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面给出一个示例函数：输入一个变量名，用内建的<code>eval()</code>函数从中提取一系列值，并且编译一系列文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">defineReplace(headersAndSources)&#123;</span><br><span class="line">variable = $$1</span><br><span class="line">names = $$eval($$variable)</span><br><span class="line">headers = </span><br><span class="line">sources =</span><br><span class="line"></span><br><span class="line">for(name,names)&#123;</span><br><span class="line">header = $$&#123;name&#125;.h</span><br><span class="line">exists($$header)&#123;</span><br><span class="line">headers += $$header</span><br><span class="line">&#125;</span><br><span class="line">source = $$&#123;name&#125;.cpp</span><br><span class="line">exists($$source)&#123;</span><br><span class="line">sources += $$source</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return($$headers $$sources)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h3><p>qmake提供了一些测试函数，这些函数也可以用作书写作用域时的条件，这些函数不返回一个值，而是指示着”success”或者”failure”(bool值)。</p><ul><li><p><code>contains(variablename,value)</code>:如果value存在于一个叫做variablename的变量的值的列表中，则执行作用域中内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contains(VCONFIG,thread)&#123;</span><br><span class="line">DEFINES += QT_THREAD_SUPPORT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>count(variablename,number)</code>:如果variablename变量的值的总数是number个，那么这个作用域中的设置会被执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count(DEFINES, 5)&#123;</span><br><span class="line">CONFIG += debug</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>error(string)</code>：输出指定字符串，然后使qmake退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error(&quot;An error has occured&quot;)</span><br></pre></td></tr></table></figure></li><li><p><code>exists(filename)</code>:如果指定文件存在，那么这个作用域中的设置会被处理。<strong>注意:可以不用考虑平台,一致使用<code>/</code>作为目录的分隔符</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exists(/local/qt/qmake/main.cpp)&#123;</span><br><span class="line">SOURCES += main.cpp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>include(filename)</code>:项目文件在执行到此语句时包含这个文件名的内容，那么作用域中的设置被执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include(myotherapp.pro)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>isEmpty(variablename)</code>:如果variablename变量中没有任何元素，那么这个作用域中的设置会被处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isEmpty(CONFIG)&#123;</span><br><span class="line">CONFIG += qt warn_on debug</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>system(command)</code>:指令执行且如果返回值为1,则作用域中内容被执行。</p></li><li><code>infile(filename,var,val)</code>：如果filename文件包含一个值为val的变量var，那么这个函数将返回成功，第三个参数val省略时，只测试文件中是否有这样一个变量。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://read.pudn.com/downloads137/sourcecode/embed/583560/qt%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/qmake%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C.pdf" target="_blank" rel="noopener">qmake用户手册</a></li><li><a href="http://doc.qt.io/qt-5/qmake-manual.html" target="_blank" rel="noopener">官方qmake manual</a></li></ul>]]></content>
      
      <categories>
          
          <category> Documenting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台编译 </tag>
            
            <tag> qmake </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cmake笔记</title>
      <link href="/2018/07/10/cmake%E7%AC%94%E8%AE%B0/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><code>cmake</code>简介;</li><li>简单语法;</li><li>几个项目示例。<br><cmake practice="">笔记内容汇总，需要结合项目代码进行理解，代码在<a href="https://github.com/yucicheung/LearningNotes/tree/master/xmake/cmake" target="_blank" rel="noopener">我的仓库</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><br>本文主要参考<a href="http://sewm.pku.edu.cn/src/paradise/reference/CMake%20Practice.pdf" target="_blank" rel="noopener">cmake practice</a>,项目代码在<a href="https://github.com/yucicheung/LearningNotes/tree/master/xmake/cmake" target="_blank" rel="noopener">我的仓库</a>(因为原书内容有点过时，所以代码做出了修正)，笔记中加入了自己的理解。<br>另，原书未更新完，所以这里只有前六章内容，但是日常也够用了。</the></cmake></li></ul><h2 id="简单的HelloWorld-文件夹t1"><a href="#简单的HelloWorld-文件夹t1" class="headerlink" title="简单的HelloWorld(文件夹t1)"></a>简单的HelloWorld(文件夹t1)</h2><p>cmake以指定目录下的<code>CMakeLists.txt</code>为根据生成相应的中间文件(包括CMakeCache.txt,cmake_install.cmake,Makefile,CMakeFiles文件夹)，之后运行<code>make</code>（或者运行<code>make VERBOSE=1</code>观察make命令构建的详细过程）。</p><h3 id="基本语法规则"><a href="#基本语法规则" class="headerlink" title="基本语法规则"></a>基本语法规则</h3><p>CMakeLists.txt必须在工程的每个目录下都存在一份，其最基本语法规则为：</p><ul><li>变量用<code>${}</code>方式取值，但在<strong>IF控制语句中</strong>直接使用变量名;</li><li><code>指令(参数1 参数2)</code>，参数用空格或分号分开;</li><li>指令大小写无关，但是变量名大小写相关，但<strong>推荐全部使用大写指令</strong>;</li><li>运行<code>make clean</code>即可对构建结果进行清理(二进制可执行文件);<code>make distclean</code>在cmake中不可用(因为中间文件不可追踪，于是干脆禁用命令)。</li></ul><p><strong>注意</strong>：</p><ol><li>工程名和生成的可执行文件名之间没有关系(因为一个项目中可以生成多个可执行文件)。</li><li>推荐外部构建(out-of-source build)而不推荐内部构建(in-source-build)，这样在需要重新构建时将整个构建文件夹删除即可。(最主要删除<code>CMakeCache.txt</code>)</li></ol><h2 id="更像工程的HelloWorld-文件夹t2"><a href="#更像工程的HelloWorld-文件夹t2" class="headerlink" title="更像工程的HelloWorld(文件夹t2)"></a>更像工程的HelloWorld(文件夹t2)</h2><p><strong>一些注意：</strong></p><ul><li>代码安装时用<strong>cmake -DCMAKE_INSTALL_PREFIX=/tmp/t2/usr ..</strong>选项;默认的CMAKE_INSTALL_PREFIX=/usr/local</li><li>在INSTALL后，注意文件的权限会发生变更。</li></ul><p>默认以后采用外部构建方式。要使项目更像工程：</p><ol><li>添加一个子目录src存放工程源代码;<ul><li>主目录下<code>CMakeLists.txt</code>填写<code>ADD_SUBDIRECTORY(src bin)</code>;</li><li>子目录下用<code>ADD_EXECUTABLE()</code>;</li></ul></li><li>添加一个子目录doc存放工程文档;</li><li>工程目录下添加文本文件COPYRIGHT,README;</li><li>工程目录添加一个<code>runhello.sh</code>脚本用于调用hello二进制文件;</li><li>安装这些文件：将hello二进制文件与runhello.sh安装至/usr/bin，将doc目录内容及COPYRIGHT/README安装到/usr/share/doc/cmake/t2。<ul><li>方式1:<code>make install</code>;方式2:打包时指定目录安装，如果是手工编写的MakeFile会看起来如下：</li><li>对于<code>cmake</code>,需要使用指令<code>INSTALL</code>和一个很有用的变量<code>CMAKE_INSTALL_PREFIX</code>，下面具体说明<h3 id="cmake-install"><a href="#cmake-install" class="headerlink" title="cmake install"></a>cmake install</h3><code>cmake</code>需要使用指令<code>INSTALL</code>和一个很有用的变量<code>CMAKE_INSTALL_PREFIX</code>：</li></ul></li><li><code>INSTALL</code>指令用于定义安装规则，安装内容可以包括目标二进制、动态库、静态库以及文件、目录、脚本等，具体安装指令在下面介绍;</li><li><code>CMAKE_INSTALL_PREFIX</code>的使用格式一般是<code>cmake -DCMAKE_INSTALL_PREFIX=/usr .</code></li></ol><h4 id="INSTALL命令"><a href="#INSTALL命令" class="headerlink" title="INSTALL命令"></a>INSTALL命令</h4><p>INSTALL命令(不管是make install或者install命令)，都是负责copy files and set attributes。</p><ol><li>目标文件(动态静态库及可执行文件)的安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSTALL(TARGET targets...#TARGETS后面跟ADD_EXECUTABLE/ADD_LIBRARY定义的目标文件，可能是可执行二进制、动态库、静态库，targets可以有多个</span><br><span class="line">[[ARCHIVE|LIBRARY|RUNTIME]# 对应目标类型为ARCHIVE静态库、LIBRARY动态库、RUNTIME可执行目标二进制</span><br><span class="line">[DESTINATION &lt;dir&gt;]# 如果路径以/开头，那么就是绝对路径，此时CMAKE_INSTALL_PREFIX无效;相对路径不要以/开头，则$&#123;CMAKE_INSTALL_PREFIX&#125;/&lt;DESTINATION&gt;为安装后的路径</span><br><span class="line">[PERMISSIONS perssions...]</span><br><span class="line">[CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">[COMPONENT &lt;component&gt;] [OPTIONAL]]</span><br><span class="line">[...]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol><p>举个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSTALL (TARGETS myrun  mylib mystaticlib</span><br><span class="line">RUNTIME DESTINATION bin# 将二进制myrun安装到$&#123;CMAKE_INSTALL_PREFIX&#125;/bin目录</span><br><span class="line">LIBRARY DESTINATION lib# 动态库libmylib安装到$&#123;CMAKE_INSTALL_PREFIX&#125;/lib目录</span><br><span class="line">ARCHIVE DESTINATION libstatic# 静态库libmystaticlib安装到$&#123;CMAKE_INSTALL_PREFIX&#125;/libstatic目录</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>上述例子中，不需要写出库文件生成的全称(lib-)，而只要写出库文件的名字即可。</p><ol><li>普通文件的安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSTALL (FILES files... DESTINATION &lt;dir&gt;</span><br><span class="line">[PERMISSIONS permissions...]</span><br><span class="line">[CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">[COMPONENT &lt;component&gt;]</span><br><span class="line">[RENAME &lt;name&gt;] [OPTIONAL])</span><br></pre></td></tr></table></figure></li></ol><p>其中，文件名(FILES)是此指令所在路径下的相对路径，默认PERMISSIONS为644权限，cmake中描述为OWNER_WRITE,OWNER_READ,GROUP_READ,WORLD_READ。</p><ol><li>非目标文件的可执行程序安装(如脚本之类)：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSTALL(PROGRAMS files... DESTINATION &lt;dir&gt;</span><br><span class="line">[PERMISSIONS permissions...]</span><br><span class="line">[CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">[COMPONENT &lt;component&gt;]</span><br><span class="line">[RENAME &lt;name&gt;] [OPTIONAL])</span><br></pre></td></tr></table></figure></li></ol><p>跟上述FILES指令使用方法一致，唯一不同的是安装后的权限为：OWNER_EXECUTE,GROUP_EXECUTE,WORLD_EXECUTE,即755权限。</p><ol><li>目录的安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSTALL(DIRECTORY dirs... DESTINATION &lt;dir&gt;</span><br><span class="line">[FILE_PERMISSIONS permissions...]# permissions总是需要一连串指令指明</span><br><span class="line">[DIRECTORY_PERMISSIONS permissions...]</span><br><span class="line">[USE_SOURCE_PERMISSIONS]</span><br><span class="line">[CONFIGUTATIONS [Debug|Release|...]]</span><br><span class="line">[COMPONENT &lt;component&gt;]</span><br><span class="line">[[PATTERN &lt;pattern&gt; | REGREX &lt;regex&gt;]</span><br><span class="line">[EXECLUDE] [PERMISSIONS permissions...]] [...])</span><br></pre></td></tr></table></figure></li></ol><p>其中</p><ul><li><code>DIRECTORY</code>:后面接所在Source目录的相对路径，但<strong>注意</strong>：<code>abc</code>表示将整个目录拷贝，<code>abc/</code>表示将目录下的所有文件拷贝过去;</li><li><code>PATTERN</code>:用于正则表达式过滤;</li><li><code>PERMISSIONS</code>：用于指定对前面的正则表达式过滤出来的文件的权限。</li></ul><p>举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSTALL(DIRECTORY icons scripts/ DESTINATION share/myproj</span><br><span class="line">PATTERN &quot;CVS&quot; EXECLUDE</span><br><span class="line">PATTERN &quot;scripts/*&quot; PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ GROUP_EXECUTE GROUP_READ</span><br><span class="line"># 可以看到每次出现一个关键词，将其后面的内容存储为其中内容，直到碰到下一个关键词</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>上述执行结果会是：icons目录安装到<prefix>/share/myproj，将<code>scripts/</code>文件夹中所有内容安装到<prefix>/share/myproj;对含有”CVS”的目录不包含，对符合<code>srcipts/*</code>模式的文件。<br>如果要换个地方存放目标二进制，可以通过<code>SET</code>命令重新定义<code>EXECUTABLE_OUTPUT_PATH</code>/<code>LIBRARY_OUTPUT_PATH</code>变量来指定最终的目标二进制的位置(指最终生成的二进制可执行文件或最终共享库，不包含编译生成的中间文件。记住:<strong>在哪里<code>ADD_EXECUTABLE()</code>/<code>ADD_LIBRARY()</code>，就在哪里加入上述修改目标文件夹的定义。</strong></prefix></prefix></p><h2 id="静态库与动态库构建-t3文件夹"><a href="#静态库与动态库构建-t3文件夹" class="headerlink" title="静态库与动态库构建(t3文件夹)"></a>静态库与动态库构建(t3文件夹)</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol><li>建立一个静态库和动态库，提供HelloFunc函数供其他程序编程使用，HelloFunc向终端输出Hello World字符串。</li><li>安装头文件及共享库。 <h3 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h3></li></ol><ul><li><code>ADD_LIBRARY</code>添加构建动态静态库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD_LIBRARY(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN)</span><br></pre></td></tr></table></figure></li></ul><p>其中，</p><ul><li>libname不需要写全<code>libhello.so</code>，只需要写<code>hello</code>就可以，cmake会自动生成<code>libhello.X</code>;</li><li>库的三种类型<ul><li><code>SHARED</code>动态库(<code>.so</code>后缀)</li><li><code>STATIC</code>静态库(<code>.a</code>后缀)</li><li><code>MODULE</code>在使用dyld的系统有效，如果不支持dyld，则被当作SHARED对待</li></ul></li><li><p><code>EXCLUDE_FROM_ALL</code>表示该库不会被默认构建，除非有其他组建依赖或者手工构建<br><strong>问题</strong>：要构建的TARGET(可执行二进制文件/动态静态链接库等)是不能重名的，但是输出库的名字可以被修改,以使输出的动态静态库可以同名。</p></li><li><p><code>SET_TARGET_PROPERTIES</code>设置输出的名称，对于动态库还可以用来指定动态库版本和API版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET_TARGET_PROPERTIES(target1 target2 ...</span><br><span class="line">PROPERTIES prop1 value1</span><br><span class="line">prop2 value2...)</span><br></pre></td></tr></table></figure></li></ul><p>在/t3/build中进行cmake，就可以同时输出<code>libhello.so</code>和<code>libhello.a</code>两个库。<br>举几个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME &quot;hello&quot;)#以下命令用来表示不清除文件中的同名目标,但在3.5.1中已经可以生成同名的目标文件而不会被清除</span><br><span class="line">SET_TARGET_PROPERTIES(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1)</span><br><span class="line">SET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUPUT 1)</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：动态库一般是包含一个版本号的，如果我们想生成以下链接，我们应该怎么实现呢?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libhello.so.1.2</span><br><span class="line">libhello.so-&gt;libhello.so.1</span><br><span class="line">libhell.so.1-&gt;libhello.so.1.2</span><br></pre></td></tr></table></figure></p><ul><li>采用以下指令添加动态库版本:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1) #SOVERSION表示API版本，VERSION表示动态库版本</span><br></pre></td></tr></table></figure></li></ul><p>最终我们需要<strong>将动态库和头文件案安装到系统目录，才能被人开发使用</strong>，按照如下命令将hello共享库安装到<prefix>/lib目录，将<code>hello.h</code>安装到<prefix>/include/hello目录下。为下一节准备，将文件安装在<code>/usr/lib</code>和<code>/usr/include/hello</code>下。</prefix></prefix></p><h2 id="使用外部共享库和头文件-t4目录"><a href="#使用外部共享库和头文件-t4目录" class="headerlink" title="使用外部共享库和头文件(t4目录)"></a>使用外部共享库和头文件(t4目录)</h2><p>按照构建可执行二进制文件的方式构建文件夹，此时<code>#include&lt;hello.h&gt;</code>需要用<code>&lt;&gt;</code>符号(因为已经在系统文件夹中,但是不在系统标准的头文件路径/usr/include中)，因此直接在<code>cmake</code>、<code>make</code>之后会出现错误,改用<strong><code>make VERBOSE=1</code></strong>来构建。<br><strong>注意</strong>：其实只要写成<code>#include&lt;hello/hello.h&gt;</code>会在<code>/usr/include</code>下查找相应文件。</p><p>此时我们要<strong>引入头文件搜索所路径</strong>，用指令<code>INCLUDE_DIRECTORIES</code>或者是<code>CMAKE_INCLUDE_PATH</code>选项</p><ul><li><code>INCLUDE_DIRECTORIES</code><ul><li>用于向工程添加多个特定的<strong>头文件搜索路径</strong>，多个路径之间用空格分割，如果路径中包含空格，可以用双括号括起来，<strong>默认</strong>的行为是<strong>追加到当前的头文件搜索路径后面</strong>;</li><li>可以通过两种方式来进行控制搜索路径添加的方式:<ol><li>CMAKE_INCLUDE_DIRECTORIES_BEFORE,通过SET这个cmake变量为on，可以将添加的头文件搜索路径放在已有路径的前面;</li><li>通过AFTER或者BEFORE参数，也可以控制是追加或者是置前。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCLUDE_DIRECTORIES([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...)</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul><p><strong>问题</strong>：上述步骤完成后，会出现一个新的错误<code>undefined reference to &#39;HelloFunc&#39;</code>，因为还没有link到共享库libhello上（gcc -lhello）。</p><ul><li><code>TARGET_LINK_LIBRARIES</code>用于为target(库/可执行二进制文件)添加需要链接的共享库。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TARGET_LINK_LIBRARIES(target library1</span><br><span class="line">&lt;debug | optimized&gt; library2</span><br><span class="line">...)</span><br></pre></td></tr></table></figure></li></ul><p>其中library可以写成<code>hello</code>(会优先链接到动态库<code>.so</code>)或者库全称<code>libhello.so</code>/<code>libhello.a</code>。<br>以下还有另外一个命令：</p><ul><li><p><code>LINK_DIRECTORIES</code>添加非标准的共享库搜索路径。</p><ul><li>如在工程内部同时存在共享库和可执行二进制，在编译时就需要指定一下这些共享库的路径。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINK_DIRECTORIES(directory1 directory2 ...)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>特殊的<strong>环境变量</strong><code>CMAKE_INCLUDE_PATH</code>和<code>CMAKE_LIBRARY_PATH</code> </p><ul><li>两个环境变量可以设置到<code>.bashrc</code>中并且<code>export</code>生效，或者在CMakeLists.txt中用<code>SET</code>设置相应变量值;</li><li><code>CMAKE_INCLUDE_PATH</code>配合<code>FIND_PATH</code>(用来在指定路径中搜索文件名)使用;<ul><li>当头文件没有存在常规路径<code>/usr/include</code>,<code>usr/local/include</code>中时，可以通过这些变量弥补。</li></ul></li><li><code>CMAKE_LIBRARY_PATH</code>配合<code>FIND_LIBRARY</code>(在指定路径中搜索库名)使用。<br>则更自动化的<code>INCLUDE_DIRECTORIES()</code>如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SET(CMAKE_INCLUDE_PATH /usr/include/hello)</span><br><span class="line">FIND_PATH(myHeader hello.h)</span><br><span class="line">IF(myHeader)</span><br><span class="line">INCLUDE_DIRECTORIES($&#123;myHeader&#125;)</span><br><span class="line">ENDIF(myHeader)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="模块的使用和自定义模块"><a href="#模块的使用和自定义模块" class="headerlink" title="模块的使用和自定义模块"></a>模块的使用和自定义模块</h2><p>对于系统与定义的Find<name>.cmake模块，使用方法如下：<br>每一个模块都会定义以下几个变量(系统预定义)：</name></p><ul><li><name>_FOUND:判断模块是否找到</name></li><li><name>_INCLUDE_DIR or <name>_INCLUDES：存储include路径，当FOUND为真，INCLUDE_DIRECTORIES();</name></name></li><li><name>_LIBRARY or <name>_LIBRARIES：存储library路径,当FOUND为真时，TARGET_LINK_LIBRARIES()。</name></name></li></ul><p>以下看一个复杂的例子，用<name>_FOUND控制工程特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SET(mySources viewer.c)</span><br><span class="line">SET(optionalSources)</span><br><span class="line">SET(optionalLibs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FIND_PACKAGE(JPEG)# 当输入选项-DENABLE_JPEG_SUPPORT以下代码生效</span><br><span class="line">IF(JPEG_FOUND)</span><br><span class="line">SET(optionalSources $&#123;optionalSources&#125; jpegview.c)</span><br><span class="line">INCLUDE_DIRECTORIES($&#123;JPEG_INCLUDE_DIR&#125;)</span><br><span class="line">SET(optionalLibs $&#123;optionalLibs&#125; $&#123;JPEG_LIBRARIES&#125;)</span><br><span class="line">ADD_DEFINITIONS(-DENABLE_JPEG_SUPPORT)</span><br><span class="line">ENDIF(JPEG_FOUND)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FIND_PACKGAE(PNG)# 当输入选项-DENABLE_PNG_SUPPORT以下代码生效</span><br><span class="line">IF(PNG_FOUND)</span><br><span class="line">SET(optionalSources $&#123;optionalSources&#125; pngview.c)</span><br><span class="line">INCLUDE_DIRECTORIES($&#123;PNG_INCLUDE_DIR&#125;)</span><br><span class="line">SET(optionalLibs $&#123;optionalLibs&#125; $&#123;PNG_LIBRATIES&#125;)</span><br><span class="line">ADD_DEFINITIONS(-DENABLE_PNG_SUPPORT)</span><br><span class="line">ENDIF(PNG_FOUND)</span><br><span class="line"></span><br><span class="line">ADD_EXECUTABLE(viewer $&#123;mySources&#125; $&#123;optionalSources&#125;)</span><br><span class="line">TARGET_LINK_LIBRARIES(viewer $&#123;optionalLibs&#125;)</span><br></pre></td></tr></table></figure></name></p><h2 id="编写自己的FindHello模块-t6目录"><a href="#编写自己的FindHello模块-t6目录" class="headerlink" title="编写自己的FindHello模块(t6目录)"></a>编写自己的FindHello模块(t6目录)</h2><p>在CMakeLists.txt中调用的是<code>.cmake</code>模块中的变量，而cmake模块中的变量可以系统定义，也可以用户自己定义。</p><ul><li><code>FIND_PACKAGE(&lt;name&gt; [major.minor] [QUIET] [NO_MODULE] [REQUIRED|COMPONENTS] [components...]])</code><ul><li>如果指定QUIET参数，就对应编写的FindHELLO.cmake中的HELLO_FIND_QUIETLY;</li><li>指定REQUIRED参数，则找不到该链接库时不能编译，对应FindHELLO.cmake中的HELLO_FIND_REQUIRED变量。</li></ul></li></ul><h2 id="指令汇总"><a href="#指令汇总" class="headerlink" title="指令汇总"></a>指令汇总</h2><p>项目中用到的指令如下：</p><ul><li><code>PROJECT(projectname [CXX] [C] [JAVA])</code><ul><li>语言列表可以忽略，默认支持所有语言;</li><li>两个隐式的cmake变量，<code>&lt;projectname&gt;_BINARY_DIR</code>、<code>&lt;projectname&gt;_SOURCE_DIR</code>,或者就直接用<code>PROJECT_BINARY_dir</code>、<code>PROJECT_SOURCE_DIR</code>;</li></ul></li><li><code>SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</code><ul><li>如给<code>SRC_LIST</code>设置变量时<code>main.cpp</code>/<code>&quot;main.cpp&quot;</code>均可;</li></ul></li><li><code>MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] &quot;message to display&quot;...)</code><ul><li>SEND_ERROR，产生错误，生成过程被跳过;</li><li>STATUS，输出前缀为<code>--</code>的信息;</li><li>FATAL_ERROR，立即终止所有cmake过程。</li></ul></li><li><code>ADD_EXECUTABLE(hello ${SRC_LIST})</code></li></ul>]]></content>
      
      <categories>
          
          <category> Documenting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> Linux </tag>
            
            <tag> cmake </tag>
            
            <tag> 跨平台编译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows及Ubuntu软件包管理器安装qt5记录</title>
      <link href="/2018/07/05/Windows%E5%8F%8AUbuntu%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AE%89%E8%A3%85qt5%E8%AE%B0%E5%BD%95/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>在windows下安装qt5;</li><li>Ubuntu下安装qt5;</li><li>qt的环境变量配置;</li><li>测试运行是否成功。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="windows下安装qt5"><a href="#windows下安装qt5" class="headerlink" title="windows下安装qt5"></a>windows下安装qt5</h2><p>如果是在windows下安装，只需要到<a href="http://download.qt.io/archive/qt/" target="_blank" rel="noopener">网站</a>安装相应版本qt和qtcreator即可。<br>再按照后文<code>环境变量配置</code>部分介绍的方法配置即可。</p><h2 id="Ubuntu下安装qt5"><a href="#Ubuntu下安装qt5" class="headerlink" title="Ubuntu下安装qt5"></a>Ubuntu下安装qt5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential # 安装编译需要的软件列表</span><br><span class="line">sudo apt-get install qtcreator # 安装qtcreator</span><br><span class="line">sudo apt-get install qt5-default # qt5相关包安装</span><br></pre></td></tr></table></figure><h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><ul><li>linux下运行<code>qtcreator</code>命令打开qtcreator，win下打开可执行文件;</li><li>打开<code>工具</code>——&gt;<code>选项</code>——&gt;<code>构建和运行</code>——&gt;<code>构建套件(kit)</code>手动设置套件相关环境变量：根据自己的电脑配置进行。<ul><li><code>设备类型</code>：桌面;</li><li><code>编译器</code>：按自己的电脑配置设为<code>GCC(x86_64bit in /usr/bin)</code>;</li><li><code>Qt mkspec</code>:<strong>重要</strong>，linux的话设为<code>linux-g++</code>，windows的话设为<code>win32-msvc</code>(如果你用的是VC)。设置错误会导致连接编译出错。</li></ul></li><li>点击<code>Apply</code>即可。</li></ul><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><ul><li>下载qt5的API文档<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qt5-doc # 安装qt5的API文档</span><br><span class="line">sudo apt install qt5-doc-html # 安装qt5的API文档，HTML格式版</span><br><span class="line">sudo apt install qtbase5-doc-html # 安装qt5基础HTML文档</span><br><span class="line">sudo apt install qtbase5-examples # 安装Qt5的基础示例</span><br></pre></td></tr></table></figure></li></ul><h2 id="简单测试所有配置是否成功"><a href="#简单测试所有配置是否成功" class="headerlink" title="简单测试所有配置是否成功"></a>简单测试所有配置是否成功</h2><p>创建一个qt工程文件，<code>helloWorld.pro</code>，还是用简单的HelloWorld。<br>程序如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello World!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>点击构建项目<code>helloWorld</code>.</p><h2 id="TroubleShooting"><a href="#TroubleShooting" class="headerlink" title="TroubleShooting"></a>TroubleShooting</h2><ul><li><code>bits/c++config.h:No such directory or file.</code>:可能是编译器和你的系统环境不统一，将你的编译器变为32/64切换一下，或者<code>sudo apt-get install gcc-multilib g++-multilib</code>会自动解析你的gcc版本,编译命令会自动调用<code>-m32</code>进行。</li><li>连接编译出错一定要检查自己的<code>mkspec</code>环境变量是否合适设置。<h2 id="参考贴"><a href="#参考贴" class="headerlink" title="参考贴"></a>参考贴</h2><a href="https://stackoverflow.com/questions/48147356/install-qt-on-ubuntu" target="_blank" rel="noopener">Ubuntu上安装qt</a></li></ul><p><a href="https://stackoverflow.com/questions/4643197/missing-include-bits-cconfig-h-when-cross-compiling-64-bit-program-on-32-bit" target="_blank" rel="noopener">64bit程序在32bit机上跨环境编译</a></p>]]></content>
      
      <categories>
          
          <category> Documenting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> qt </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CelexMatlabToolbox-1.0发布记录</title>
      <link href="/2018/06/30/CelexMatlabToolbox-1-0%E5%8F%91%E5%B8%83%E8%AE%B0%E5%BD%95/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><code>CelexMatlabToolbox-1.0</code>工具箱说明;</li><li><code>Release</code>发布操作;</li><li>选择并添加<code>Apache</code>开源证书;</li><li>发起pull request向其他仓库做贡献。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>关于我自己的博客，我其实一直觉得没有什么干货，前些天看到本科跟我同一级但是两年前选择工作而非读研的人的博客，发现人家的技术增长速度真是我们无法企及的。想象那种一切都是为了大用户量，高并发，大数据的工作，真的比我们瞎研究有意义多了，而且成就感恐怕也无法比拟，但是好在我现在的工作也不是只有空想和空谈，不是像本科一样只在看书，不做实践。<br>很期待我真的去到实际生产线接触用户需求的日子，希望那天顺利到来。<br><br>总的一句话，<strong>读研需谨慎</strong>。<br>下面正文。</p><h2 id="工具箱说明"><a href="#工具箱说明" class="headerlink" title="工具箱说明"></a>工具箱说明</h2><h3 id="DVS介绍"><a href="#DVS介绍" class="headerlink" title="DVS介绍"></a>DVS介绍</h3><p>DVS是一种与传统全帧成像的传感器(CMOS/CCD)不同的Sensor,它的主要特点是，画面中每一个像素点的强度信息可以被独立读出，只有该像素点的光强变化超过一定阈值时，才向外部电路发出请求，形成一个个package，这些package最终可以被解码为包含<code>x</code>列地址,<code>y</code>行地址,<code>a</code>强度信息,<code>t</code>时间戳格式的事件，从而被我们用来做二维/三维图像的可视化。<br>目前的DVS生产商在世界上有大概十家左右，具体可以参考<a href="https://github.com/uzh-rpg/event-based_vision_resources#devices" target="_blank" rel="noopener">event-based resources仓库的’Devices &amp; Companies Manufacturing them’目录</a>，其中就包含我们用到的<code>CeleX</code>　DVS器件，目前在售的型号是<code>CeleX IV</code>。</p><h3 id="工具箱内容"><a href="#工具箱内容" class="headerlink" title="工具箱内容"></a>工具箱内容</h3><p><code>CelexMatlabToolbox-1.0</code>是我为<code>CeleX IV</code>型号的DVS(Dynamic Vision Sensor，动态视觉传感器)编写的第一版Matlab工具箱。<br><br><br>工具箱的文件结构和功能如下：</p><ul><li><code>createImgFromRawData.m</code>(即上一版发布的文件<code>bin2picByFixedAmountOfEvents.m</code>)<ul><li>针对bin文件实时解码</li><li>二值图像的实时显示及存储；</li><li>灰度图像的实时显示及存储；</li><li>累积式灰度图的实时显示及存储；</li></ul></li><li>函数集合<code>functions</code><ul><li>对bin文件进行批量解码为<code>x,y,adc,t</code>格式(其中<code>t</code>为连续时间)；</li><li>将解码事件转存为mat文件及其读取；</li><li>二值图的显示及存储；</li><li>灰度图的显示及存储；</li><li>累积式灰度图的显示及存储；</li><li>去噪二值图的显示及存储；</li><li>去噪灰度图的显示及存储；</li><li>事件流的三维动态显示。</li></ul></li><li><code>demo.m</code><ul><li>可运行的示例文件，提供对所有工具箱函数的调用示例。</li></ul></li></ul><p><strong>这一版的代码已经发布到<a href="https://github.com/yucicheung/CelexMatlabToolbox" target="_blank" rel="noopener">我的git仓库</a>。</strong></p><p>目前可预见的待更新内容有</p><ul><li>基于时间片段的事件累积方式实现;</li><li>改进去噪效果<ul><li>考虑FPN的影响</li><li>考虑空间域的事件关联性</li></ul></li></ul><h2 id="添加开源协议"><a href="#添加开源协议" class="headerlink" title="添加开源协议"></a>添加开源协议</h2><h3 id="选择合适的开源协议"><a href="#选择合适的开源协议" class="headerlink" title="选择合适的开源协议"></a>选择合适的开源协议</h3><p><img src="/img/HowToChooseOSSL.png" alt="一张很直观的开源协议选择图"><br><br>我对开源协议的要求主要就是以下两点：</p><ol><li>所有引用或者修改自我的代码都必须加上版权说明;</li><li>保留以此代码为基础申请专利的权利。<br>基于这两点，最终选择了<code>Apache-2.0 LICENSE</code>。<h3 id="添加Apache-2-0-LICENSE"><a href="#添加Apache-2-0-LICENSE" class="headerlink" title="添加Apache-2.0 LICENSE"></a>添加Apache-2.0 LICENSE</h3>步骤如下：</li></ol><ul><li>到<a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">官网</a>下载Apache2.0 License源文件;</li><li>修改源文件，将其中<code>[]</code>包围部分替换为自己的信息;</li><li>将该文件保存为<code>LICENSE</code>文件存储在项目文件夹根目录下;</li><li>如果你还有引用到拥有协议保护的其他第三方库，请将其包含在<code>NOTICE</code>文件中并且做出一些说明，同样包含在项目文件夹的根目录下;</li><li>将license源文件最末的<code>copyright</code>开始的部分粘贴在项目的每个文件中(以注释形式)，一般放置在开头，我放在末尾。</li><li>以上都做完之后，就完成了添加协议，上传到github以后，在你的项目主页就会显示你所用的开源协议标签。</li></ul><h2 id="Release-in-github"><a href="#Release-in-github" class="headerlink" title="Release in github"></a>Release in github</h2><ul><li><p><strong>对当前版本打tag</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0 -m 'Comment'# -a选项描述版本名，-m选项描述对版本的基础描述</span><br></pre></td></tr></table></figure></li><li><p><strong>完善release描述</strong></p><ul><li>点击项目主页的<code>release</code>选项条，会显示你打过的所有tags;</li><li>在对应版本号右边点击<code>edit release notes</code>;</li><li>选择你要编辑的tag号并且添加相应的名字和描述，点击<code>Update release</code>即可发布。<br>最后在项目的<code>release</code>选项条下就会得到一个有详细描述的release版本，用户可以选择下载<code>zip</code>或者<code>.tar.gz</code>格式的版本文件，文件名上会自动加上你的标签号。</li></ul></li></ul><h2 id="发起pull-request"><a href="#发起pull-request" class="headerlink" title="发起pull request"></a>发起pull request</h2><p>最后我希望将我自己的这点小成果添加到上述的<a href="https://github.com/uzh-rpg/event-based_vision_resources" target="_blank" rel="noopener">event-based resources仓库</a>中，所以向该仓库发起了pull request，很幸运最后也确实被批准和merge进去了。<br><br><br>步骤是</p><ul><li>从源仓库fork到自己的仓库;</li><li>从远程仓库clone到本地;</li><li>在本地修改之后进行commit;</li><li>在你自己的远程仓库主页点击<code>new pull request</code>，确认修改信息，添加必要描述，就可以向源仓库发起请求了。</li><li>等待源仓库的reviewer对你的请求做出review，同意之后就等待你的commit被merge进去就可以了。当然也可能被要求修改或者是拒绝，此时你要对你的commit做出进一步修改。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>只是一点微小的工作，还有好多活没干完，当然了，活是干不完的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.oschina.net/news/74999/how-to-choose-a-license" target="_blank" rel="noopener">如何为你的开源项目选择一个合适的开源协议？</a></p>]]></content>
      
      <categories>
          
          <category> Documenting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 工具 </tag>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微信定时自动发送群消息的小工具-python-itchat</title>
      <link href="/2018/06/13/%E5%BE%AE%E4%BF%A1%E5%AE%9A%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8F%91%E9%80%81%E7%BE%A4%E6%B6%88%E6%81%AF%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本程序实现定时向指定微信群发送指定消息的功能。<br>主要工具如下：</excerpt></p><ul><li>python2.7编写;</li><li><code>itchat</code>提供微信API接口，实现进行向群组发送消息;</li><li><code>apscheduler</code>提供定时器功能。<br>代码下载请到<a href="https://github.com/yucicheung/Mini_Tools/blob/master/WechatTools/onTimeMsgSenderToChatroom.py" target="_blank" rel="noopener">我的github仓库</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><p>最开始只是想能不能做一个程序，可以定时在周二，四，六晚上10点半提醒组员们上传日志，所以就开始了搜索。发现<code>itchat</code>这个超级好用的工具，在<code>apscheduler</code>的加持下最终编了这么一个程序。灵感总是来源于生活….</p><p>当然<code>itchat</code>的功能远不止是发送个群消息而已，它提供的微信API接口还可以做很多有意思的东西，比如最常见的机器人自动回复，还可以接入其他应用程序接口用微信号做一些小应用(如自动播放歌曲，返回天气信息等)。</p><h2 id="依赖条件"><a href="#依赖条件" class="headerlink" title="依赖条件"></a>依赖条件</h2><p>Written in <strong>python2.7.12</strong>：</p><ul><li><code>itchat</code> 1.3.10</li><li><code>APScheduler</code> 3.5.1</li></ul><h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><p>定义文件中的发送时间<code>time</code>，发送群组名<code>roomName</code>，发送消息<code>context</code>(消息中含中文字符时应该使用unicode编码)。<br>运行后会在<code>time</code>对应时间，往<code>roomName</code>对应群组，发送<code>context</code>对应的消息。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul><li><p>修改<code>onTimeMsgSenderToChatroom.py</code>文件中的<code>time</code>，<code>roomName</code>，<code>context</code>设置为自己需要的参数。具体参考如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roomName = <span class="string">u'两张王'</span></span><br><span class="line">context=<span class="string">u'该消息由程序自动发送'</span></span><br><span class="line">time = &#123;<span class="string">'day_of_week'</span>:<span class="string">'*'</span>,<span class="string">'hour'</span>:<span class="number">12</span>,<span class="string">'minute'</span>:<span class="number">34</span>,<span class="string">'second'</span>:<span class="number">26</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行<code>python onTimeMsgSenderToChatroom.py</code>;</p></li><li>扫描QR码，自动登陆成功后，等待信息自动发送即可。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下是用按照上述设置运行源代码向微信群发送的消息的截图。</p><p><img src="/img/msgOnTimeSenderTest.png" alt="msgOnTimeSenderTest"></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>需要下载请到<a href="https://github.com/yucicheung/Mini_Tools/blob/master/WechatTools/onTimeMsgSenderToChatroom.py" target="_blank" rel="noopener">我的github</a>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> itchat</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">onTimeSender</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Automatically send message to chatroom on time according to user's predefinition.</span></span><br><span class="line"><span class="string">params:</span></span><br><span class="line"><span class="string">`roomName`: The name of chatroom you want to send message to;</span></span><br><span class="line"><span class="string">`context`: The message you want to send to chatroom;</span></span><br><span class="line"><span class="string">`time`: Time to send out message, in form of a dict.</span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">Please refer to the __main__ function part.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,roomName=<span class="string">''</span>,context=<span class="string">''</span>,time=&#123;&#125;)</span>:</span></span><br><span class="line">self.roomName=roomName</span><br><span class="line">self.context=context</span><br><span class="line">self.time=time</span><br><span class="line">itchat.auto_login(hotReload=<span class="keyword">True</span>,loginCallback=self.loginCallback,exitCallback=self.exitCallback)</span><br><span class="line">self.schedulerForSender()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendChatroomMsg</span><span class="params">(self,roomName,context)</span>:</span></span><br><span class="line">itchat.get_chatrooms(update=<span class="keyword">True</span>)</span><br><span class="line">roomNickName = roomName</span><br><span class="line">candidates = itchat.search_chatrooms(roomNickName)</span><br><span class="line"><span class="keyword">print</span> candidates</span><br><span class="line">username = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> candidate <span class="keyword">in</span> candidates:</span><br><span class="line"><span class="keyword">if</span> candidate[<span class="string">'NickName'</span>] == roomNickName:</span><br><span class="line">username = candidate[<span class="string">'UserName'</span>]</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> username:</span><br><span class="line">sendtime = datetime.now().strftime(<span class="string">'%A %B %d,%Y'</span>)<span class="comment">#Tue June 08,2018</span></span><br><span class="line">sendtime = datetime.now().strftime(<span class="string">'%m-%d-%Y %H:%M:%S,%A'</span>)</span><br><span class="line">msg = context + <span class="string">"Sending in "</span>+sendtime</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Ready to send message to group %s,message as follows : \n%s"</span>%(roomName,msg)</span><br><span class="line">itchat.send_msg(msg=msg,toUserName=username)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loginCallback</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Successfully logged in."</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exitCallback</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Successfully logged out."</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendMsgToChatRoom</span><span class="params">(self)</span>:</span></span><br><span class="line">self.sendChatroomMsg(self.roomName,self.context)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedulerForSender</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="comment"># scheduler setup</span></span><br><span class="line">scheduler = BlockingScheduler()</span><br><span class="line">scheduler.add_job(self.sendMsgToChatRoom,<span class="string">'cron'</span>,day_of_week=self.time[<span class="string">'day_of_week'</span>],hour=self.time[<span class="string">'hour'</span>],minute=self.time[<span class="string">'minute'</span>],second=self.time[<span class="string">'second'</span>])<span class="comment"># sending takes 4 seconds behind</span></span><br><span class="line">scheduler.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">roomName = <span class="string">'DVS_Group'</span></span><br><span class="line">context = <span class="string">u'通知上传日志'</span></span><br><span class="line">time = &#123;<span class="string">'day_of_week'</span>:<span class="string">'tue,thu,sat'</span>,<span class="string">'hour'</span>:<span class="number">22</span>,<span class="string">'minute'</span>:<span class="number">24</span>,<span class="string">'second'</span>:<span class="number">56</span>&#125;</span><br><span class="line"><span class="string">'''for testing</span></span><br><span class="line"><span class="string">roomName = u'两张王'</span></span><br><span class="line"><span class="string">context=u'该消息由程序自动发送'</span></span><br><span class="line"><span class="string">time = &#123;'day_of_week':'*','hour':12,'minute':34,'second':26&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">onTimeSender(roomName,context,time)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Linux </tag>
            
            <tag> 自制小工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>更改Ubuntu的apt源</title>
      <link href="/2018/05/25/%E6%9B%B4%E6%94%B9Ubuntu%E7%9A%84apt%E6%BA%90/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>配置环境：<strong>Ubuntu 16.04</strong>;</li><li>实现目标：替换apt源为163源，以加速<code>apt install</code>速度;</li><li>Bonus：替换apt源为Xidian源，实现免流量下载。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2>嗯，这是一篇应需而生的博文，好像有段时间没来更博了，因为在忙科研。<br>好好忙科研还是很充实的。</the></li></ul><p>你知道吗，我发现如今科研不仅要你会matlab、python、C、C++会算法，会统计数据会画图会做ppt会报告会话术会word，还要会excel会PS会Premiere。<br>其实也蛮有趣的。</p><h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><p>apt源就是一个文件(Linux下一切都是文件)，位置是<code>\etc\apt\sources.list</code>，打开就可以看到你本机的apt源。</p><p>一般在没有更换apt源的时候(此时官方软件源<code>archive.canonical.com</code>的服务器在国外)，所以你要用<code>sudo apt install</code>安装软件，或者甚至是<code>sudo apt update</code>速度都会很慢，甚至可能由于实在速度过慢，系统认为你没有网络连接而直接导致操作失败。</p><p>所以为了提升我们下载的速度，一般需要把apt源更换成国内的镜像源，这样当你用<code>apt install</code>时系统就会从国内的服务器上去搜索和获取你所查找的资源，下载也就能快很多。</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol><li><code>sudo gedit /etc/apt/sources.list</code>打开文件，原来的软件源可以不用删除，我们只需要在原有内容前面添加我们需要的软件源就行了;</li><li><p>添加163镜像源。在<strong>文件最开头添加</strong>以下内容，因为apt命令选择源的顺序就是按照<code>sources.list</code>中从前到后的顺序，即排在前面的软件源会优先被选择。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.163.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#测试版源</span></span></span><br><span class="line">deb http://mirrors.163.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> 源码</span></span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#测试版源</span></span></span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure></li><li><p>添加Xidian镜像源。如果你这么巧跟我一样是西电学生，那将以下内容添加到源文件的最开始处就能成功省下很多流量(再加上hosts一个月10G的流量限制完全可以无视)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial main multiverse restricted universe</span><br><span class="line"></span><br><span class="line">deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-backports main multiverse restricted universe</span><br><span class="line"></span><br><span class="line">deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-proposed main multiverse restricted universe</span><br><span class="line"></span><br><span class="line">deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-security main multiverse restricted universe</span><br><span class="line"></span><br><span class="line">deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-updates main multiverse restricted universe</span><br><span class="line"></span><br><span class="line">deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial main multiverse restricted universe</span><br><span class="line"></span><br><span class="line">deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-backports main multiverse restricted universe</span><br><span class="line"></span><br><span class="line">deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-proposed main multiverse restricted universe</span><br><span class="line"></span><br><span class="line">deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-security main multiverse restricted universe</span><br><span class="line"></span><br><span class="line">deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-updates main multiverse restricted universe</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> Documenting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>tmux的安装和使用</title>
      <link href="/2018/05/25/tmux-Usage/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>配置环境：<strong>Ubuntu 16.04</strong>;</li><li>安装tmux;</li><li>tmux基本使用命令。<br>tmux是一款分屏工具，可以将你的终端切分成几块利用。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2></the></li></ul><ol><li>安装tmux,<code>sudo apt install tmux</code>。</li><li>开启tmux窗口<code>tmux</code>，会自动进入tmux窗口，此时只分一个窗口。</li><li>tmux命令一般由prefix key+command key触发，使用方式是按住prefix key，松开后按下command key。prefix key默认是<code>Ctrl-b</code>，即同时按住<code>ctrl</code>和<code>b</code>键。而command key列表如下：<ol><li>对窗格的操作：<ol><li><code>%</code>:左右分窗格;</li><li><code>&quot;</code>:上下分窗格;</li><li><code>&lt;arrow key&gt;</code>:窗格导航，如配合使用left方向键时会导航到当前窗格的左端;</li></ol></li><li>对窗口的操作：<ol><li><code>c</code>:创建新窗口;</li><li><code>p</code>:切换到前一个窗口;</li><li><code>n</code>:切换到下一个窗口;</li><li><code>&lt;number&gt;</code>:切换到<number>号窗口，窗口号在窗口下端的status bar上显示。</number></li></ol></li><li>对会话的操作：<ol><li><code>d</code>:脱离当前tmux会话，回到bash下，会话会运行在后台;</li><li><code>D</code>:从tmux选择一个会话进行脱离;</li><li>bash敲入<code>tmux ls</code>可以查看到当前在运行的所有tmux sessions;</li><li>bash敲入<code>tmux attach -t &lt;number&gt;</code>用于连接到<number>对应的会话;</number></li><li>bash敲入<code>tmux new -s aMeaningfulName</code>创建一个会话并赋予名字;    </li><li>bash敲入<code>tmux rename-session -t &lt;number&gt; aMeaningfulName</code>为第<number>号的session赋予一个新的名字。</number></li><li>bash敲入<code>tmux attach -t sessionName</code>重新连接名字对应的session。</li></ol></li></ol></li><li>关闭窗格：用<code>ctrl-d</code>或者是输入<code>exit</code>来关闭。</li><li>查看相关的帮助:<code>ctrl-b</code>+<code>?</code>查看相关命令。</li><li>更多常用命令，prefix key+以下command key:<ol><li><code>z</code>:将一个窗格放大到全窗口/缩回原窗格大小;</li><li><code>Ctrl-&lt;arrow-key&gt;</code>:将窗格按照箭头方向放大/缩小;</li><li><code>,</code>:重命名当前窗口。<h2 id="更多配置"><a href="#更多配置" class="headerlink" title="更多配置"></a>更多配置</h2></li></ol></li><li>配置文件为<code>~/.tmux.conf</code>，每次开启新会话时，Tmux都会先读取该配置文件。</li><li><p>如果希望新的配置能够立即生效，在配置文件中加入以下语句，并按下<code>C-b</code> <code>r</code>就可以使新配置生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind R source-file ~/.tmux.conf; display-message &quot;Config reloaded..&quot;</span><br></pre></td></tr></table></figure></li><li><p>变更快捷键为<code>ctrl-a</code>，在<code>~/.tmux.conf</code>中添加以下语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unbind C-b</span><br><span class="line">set -g prefix C-a</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> Documenting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>建库时帮助筛选图片的GUI小工具(python+tkinter)</title>
      <link href="/2018/04/11/%E5%BB%BA%E5%BA%93%E6%97%B6%E5%B8%AE%E5%8A%A9%E7%AD%9B%E9%80%89%E5%9B%BE%E7%89%87%E7%9A%84GUI%E5%B0%8F%E5%B7%A5%E5%85%B7-python-tkinter/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>一个帮助筛选图片自制GUI程序，方便建立图片数据库时使用。</excerpt></p><ul><li>python2.7编写;</li><li>使用tkinter+Pillow;<br>代码下载请到<a href="https://github.com/yucicheung/Mini_Tools/tree/master/ClassifyGUI" target="_blank" rel="noopener">我的github仓库</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2>建立数据库过程中，需要对收集到的图片进行筛选，查看每一张图片，将合适的图片移动到最终的<code>category</code>目录中，而不合适的图片移动到<code>categoryDump</code>目录下。<br>这样一来方便建立数据库，二来不需要的图片也可以整理好(以便日后使用,如做负目标等)。<br>对于这个需求，就需要一边能实现查看图片，针对查看图片即使做出移动的动作，因此设计了一个GUI程序实现功能。<h2 id="依赖条件"><a href="#依赖条件" class="headerlink" title="依赖条件"></a>依赖条件</h2>Written in <strong>python2.7.12</strong>：</the></li><li>python-tk 2.7.12-1~16.04</li><li>PILLOW_VERSION = ‘5.0.0’</li></ul><h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><p>程序实现如下功能：</p><ol><li>当点击单选按钮时(请保证源数据目录都已正确设置)，程序会检查目录中的图片数量：<ul><li>如果图片总数是0,告知用户目录为空(即图片已处理完成);</li><li>如果大于0,显示其中一副图片，并且程序会确保源目录下有<code>category</code>目录及<code>categoryDump</code>目录存在。</li></ul></li><li>当点击<code>category</code>按钮时，将图片移动到<code>category</code>目录下;</li><li>当点击<code>categoryDump</code>钮时,将图片移动到<code>categoryDump</code>目录下。</li></ol><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>如果要测试程序,运行 <code>main.py</code>。</p><p>否则,在运行 <code>main.py</code>前你需要:</p><ul><li>根据自己的需求修改<code>main.py</code>中的参数;</li><li><strong>如果有多于4类要分</strong>，请修改<code>ClassifyGUI.py</code>中相关参数.</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>GUI的实际大小是<em>900x750</em>,以下展示图片按照0.5倍率缩放。</p><ul><li>程序初始化</li></ul><p><img src="/img/initialization.png" alt="Initialization"></p><ul><li>当点击单选按钮</li></ul><p><img src="/img/clickRadioButton.png" alt="clickRadioButton"></p><ul><li>当处理完当前类别的所有图片</li></ul><p><img src="/img/doneProcessing.png" alt="doneProcessing"></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>需要下载请到<a href="https://github.com/yucicheung/Mini_Tools/tree/master/ClassifyGUI" target="_blank" rel="noopener">我的github</a>。</p><ul><li><p><code>main.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> ClassifyGUI <span class="keyword">import</span> ClassifyGUI</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># config vars</span></span><br><span class="line">config = &#123;&#125;</span><br><span class="line">config[<span class="string">"destinationDir"</span>] = <span class="string">'./dataset'</span></span><br><span class="line">config[<span class="string">"searchPathList"</span>] = [<span class="string">'./dataset/hm'</span>,<span class="string">'./dataset/hz'</span>,<span class="string">'./dataset/ys'</span>,<span class="string">'./dataset/jq'</span>]</span><br><span class="line">config[<span class="string">"types"</span>] = [<span class="string">"AircraftCarrier"</span>,<span class="string">'Bomber'</span>,<span class="string">'TransportAircraft'</span>,<span class="string">'DestroyerAndFrigate'</span>]</span><br><span class="line">config[<span class="string">"dumpPath"</span>] = [os.path.join(config[<span class="string">"destinationDir"</span>], config[<span class="string">"types"</span>][i] + <span class="string">'Dump'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">4</span>)]</span><br><span class="line">config[<span class="string">"picSize"</span>] = (<span class="number">500</span>, <span class="number">500</span>)</span><br><span class="line">config[<span class="string">"windowTitle"</span>] = <span class="string">'Classify pics'</span></span><br><span class="line">config[<span class="string">"windowGeometry"</span>] = <span class="string">'900x750'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    ClassifyGUI(config)</span><br></pre></td></tr></table></figure></li><li><p><code>utils.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">import</span> tkinter.messagebox</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkdir</span><span class="params">(pathToCheck)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(pathToCheck):</span><br><span class="line">        os.mkdir(pathToCheck)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> len(os.listdir(pathToCheck))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkSourceEmpty</span><span class="params">(picList)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(picList)==<span class="number">0</span>:</span><br><span class="line">        tk.messagebox.showwarning(title=<span class="string">'Finish'</span>, message=<span class="string">'Finish processing all images of this type!'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></li><li><p><code>ClassifyGUI.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageTk</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassifyGUI</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, config)</span>:</span></span><br><span class="line">        self.config = config</span><br><span class="line">        self.radioButtonPos = (<span class="number">100</span>,<span class="number">150</span>)</span><br><span class="line">        self.imgBoxPos = (<span class="number">200</span>,<span class="number">200</span>)</span><br><span class="line">        self.radioPad = <span class="number">220</span></span><br><span class="line">        self.gridPad = (<span class="number">30</span>,<span class="number">10</span>)</span><br><span class="line">        self.setUpWindow()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUpWindow</span><span class="params">(self)</span>:</span></span><br><span class="line">        searchPathLists = self.config[<span class="string">"searchPathList"</span>]</span><br><span class="line">        picLists = [[p <span class="keyword">for</span> p <span class="keyword">in</span> os.listdir(searchPathLists[i]) <span class="keyword">if</span> p.endswith(<span class="string">'.png'</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">4</span>)]</span><br><span class="line">        destinationDir = self.config[<span class="string">"destinationDir"</span>]</span><br><span class="line">        types = self.config[<span class="string">"types"</span>]</span><br><span class="line">        dumpPaths = self.config[<span class="string">"dumpPath"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">radioButtonTrigger</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">            Index = pathIndex.get()</span><br><span class="line">            processPath = searchPathLists[Index]</span><br><span class="line">            picList = picLists[Index]</span><br><span class="line">            <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                destinationPath = os.path.join(destinationDir, types[Index])</span><br><span class="line">                checkdir(destinationPath)</span><br><span class="line">                checkdir(dumpPaths[Index])</span><br><span class="line">                picpath = os.path.join(processPath, picList[<span class="number">-1</span>])</span><br><span class="line">                changeImg(picpath)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">buttonTrigger0</span><span class="params">()</span>:</span></span><br><span class="line">            typeIndex = <span class="number">0</span></span><br><span class="line">            picList = picLists[typeIndex]</span><br><span class="line">            <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                processImg = picList.pop()</span><br><span class="line">                type = types[typeIndex]</span><br><span class="line">                searchPathList = searchPathLists[typeIndex]</span><br><span class="line">                srcImg = os.path.join(searchPathList, processImg)</span><br><span class="line">                desImg = os.path.join(destinationDir, type, processImg)</span><br><span class="line">                os.system(<span class="string">'mv &#123;&#125; &#123;&#125;'</span>.format(srcImg, desImg))</span><br><span class="line">                <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                    picpath = os.path.join(searchPathList, picList[<span class="number">-1</span>])</span><br><span class="line">                    changeImg(picpath)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dumpTrigger0</span><span class="params">()</span>:</span></span><br><span class="line">            typeIndex = <span class="number">0</span></span><br><span class="line">            picList = picLists[typeIndex]</span><br><span class="line">            <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                processImg = picList.pop()</span><br><span class="line">                searchPathList = searchPathLists[typeIndex]</span><br><span class="line">                dumpPath = dumpPaths[typeIndex]</span><br><span class="line">                srcImg = os.path.join(searchPathList, processImg)</span><br><span class="line">                desImg = os.path.join(dumpPath, processImg)</span><br><span class="line">                os.system(<span class="string">'mv &#123;&#125; &#123;&#125;'</span>.format(srcImg, desImg))</span><br><span class="line">                <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                    picpath = os.path.join(searchPathList, picList[<span class="number">-1</span>])</span><br><span class="line">                    changeImg(picpath)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">buttonTrigger1</span><span class="params">()</span>:</span></span><br><span class="line">            typeIndex = <span class="number">1</span></span><br><span class="line">            picList = picLists[typeIndex]</span><br><span class="line">            <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                processImg = picList.pop()</span><br><span class="line">                type = types[typeIndex]</span><br><span class="line">                searchPathList = searchPathLists[typeIndex]</span><br><span class="line">                srcImg = os.path.join(searchPathList, processImg)</span><br><span class="line">                desImg = os.path.join(destinationDir, type, processImg)</span><br><span class="line">                os.system(<span class="string">'mv &#123;&#125; &#123;&#125;'</span>.format(srcImg, desImg))</span><br><span class="line">                <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                    picpath = os.path.join(searchPathList, picList[<span class="number">-1</span>])</span><br><span class="line">                    changeImg(picpath)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dumpTrigger1</span><span class="params">()</span>:</span></span><br><span class="line">            typeIndex = <span class="number">1</span></span><br><span class="line">            picList = picLists[typeIndex]</span><br><span class="line">            <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                processImg = picList.pop()</span><br><span class="line">                searchPathList = searchPathLists[typeIndex]</span><br><span class="line">                dumpPath = dumpPaths[typeIndex]</span><br><span class="line">                srcImg = os.path.join(searchPathList, processImg)</span><br><span class="line">                desImg = os.path.join(dumpPath, processImg)</span><br><span class="line">                os.system(<span class="string">'mv &#123;&#125; &#123;&#125;'</span>.format(srcImg, desImg))</span><br><span class="line">                <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                    picpath = os.path.join(searchPathList, picList[<span class="number">-1</span>])</span><br><span class="line">                    changeImg(picpath)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">buttonTrigger2</span><span class="params">()</span>:</span></span><br><span class="line">            typeIndex = <span class="number">2</span></span><br><span class="line">            picList = picLists[typeIndex]</span><br><span class="line">            <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                processImg = picList.pop()</span><br><span class="line">                type = types[typeIndex]</span><br><span class="line">                searchPathList = searchPathLists[typeIndex]</span><br><span class="line">                srcImg = os.path.join(searchPathList, processImg)</span><br><span class="line">                desImg = os.path.join(destinationDir, type, processImg)</span><br><span class="line">                os.system(<span class="string">'mv &#123;&#125; &#123;&#125;'</span>.format(srcImg, desImg))</span><br><span class="line">                <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                    picpath = os.path.join(searchPathList, picList[<span class="number">-1</span>])</span><br><span class="line">                    changeImg(picpath)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dumpTrigger2</span><span class="params">()</span>:</span></span><br><span class="line">            typeIndex = <span class="number">2</span></span><br><span class="line">            picList = picLists[typeIndex]</span><br><span class="line">            <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                processImg = picList.pop()</span><br><span class="line">                searchPathList = searchPathLists[typeIndex]</span><br><span class="line">                dumpPath = dumpPaths[typeIndex]</span><br><span class="line">                srcImg = os.path.join(searchPathList, processImg)</span><br><span class="line">                desImg = os.path.join(dumpPath, processImg)</span><br><span class="line">                os.system(<span class="string">'mv &#123;&#125; &#123;&#125;'</span>.format(srcImg, desImg))</span><br><span class="line">                <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                    picpath = os.path.join(searchPathList, picList[<span class="number">-1</span>])</span><br><span class="line">                    changeImg(picpath)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">buttonTrigger3</span><span class="params">()</span>:</span></span><br><span class="line">            typeIndex = <span class="number">3</span></span><br><span class="line">            picList = picLists[typeIndex]</span><br><span class="line">            <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                processImg = picList.pop()</span><br><span class="line">                type = types[typeIndex]</span><br><span class="line">                searchPathList = searchPathLists[typeIndex]</span><br><span class="line">                srcImg = os.path.join(searchPathList, processImg)</span><br><span class="line">                desImg = os.path.join(destinationDir, type, processImg)</span><br><span class="line">                os.system(<span class="string">'mv &#123;&#125; &#123;&#125;'</span>.format(srcImg, desImg))</span><br><span class="line">                <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                    picpath = os.path.join(searchPathList, picList[<span class="number">-1</span>])</span><br><span class="line">                    changeImg(picpath)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dumpTrigger3</span><span class="params">()</span>:</span></span><br><span class="line">            typeIndex = <span class="number">3</span></span><br><span class="line">            picList = picLists[typeIndex]</span><br><span class="line">            <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                processImg = picList.pop()</span><br><span class="line">                searchPathList = searchPathLists[typeIndex]</span><br><span class="line">                dumpPath = dumpPaths[typeIndex]</span><br><span class="line">                srcImg = os.path.join(searchPathList, processImg)</span><br><span class="line">                desImg = os.path.join(dumpPath, processImg)</span><br><span class="line">                os.system(<span class="string">'mv &#123;&#125; &#123;&#125;'</span>.format(srcImg, desImg))</span><br><span class="line">                <span class="keyword">if</span> checkSourceEmpty(picList):</span><br><span class="line">                    picpath = os.path.join(searchPathList, picList[<span class="number">-1</span>])</span><br><span class="line">                    changeImg(picpath)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">changeImg</span><span class="params">(imgPath)</span>:</span></span><br><span class="line">            <span class="keyword">print</span> imgPath</span><br><span class="line">            im = Image.open(imgPath)</span><br><span class="line">            processImage = ImageTk.PhotoImage(im)</span><br><span class="line">            lbPic[<span class="string">'image'</span>] = processImage</span><br><span class="line">            lbPic.image = processImage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        window = tk.Tk()</span><br><span class="line">        window.title(self.config[<span class="string">"windowTitle"</span>])</span><br><span class="line">        window.geometry(self.config[<span class="string">"windowGeometry"</span>])</span><br><span class="line">        lbPic = tk.Label(window, text=<span class="string">'image'</span>, width=<span class="number">500</span>, height=<span class="number">500</span>)</span><br><span class="line">        lbPic.place(x=self.imgBoxPos[<span class="number">0</span>], y=self.imgBoxPos[<span class="number">1</span>], width=<span class="number">500</span>, height=<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># set up radio buttons</span></span><br><span class="line">        pathIndex = tk.IntVar()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">4</span>):</span><br><span class="line">            tk.Radiobutton(window, text=self.config[<span class="string">"searchPathList"</span>][i], variable=pathIndex,</span><br><span class="line">                           value=i, command=radioButtonTrigger).\</span><br><span class="line">                place(x=self.radioButtonPos[<span class="number">0</span>]+self.radioPad*i,y=self.radioButtonPos[<span class="number">1</span>],anchor=<span class="string">'nw'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">4</span>):</span><br><span class="line">                <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    tk.Button(window, text=self.config[<span class="string">"types"</span>][j], width=<span class="number">20</span>, height=<span class="number">1</span>,</span><br><span class="line">                            command=eval(<span class="string">'buttonTrigger'</span>+str(j))).\</span><br><span class="line">                        grid(row=i, column=j, padx=self.gridPad[<span class="number">0</span>], pady=self.gridPad[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">elif</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                    tk.Button(window, text=<span class="string">'dump '</span>+self.config[<span class="string">"types"</span>][j], width=<span class="number">20</span>, height=<span class="number">1</span>,</span><br><span class="line">                              command=eval(<span class="string">'dumpTrigger'</span>+str(j))). \</span><br><span class="line">                        grid(row=i, column=j, padx=self.gridPad[<span class="number">0</span>], pady=self.gridPad[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        window.mainloop()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Linux </tag>
            
            <tag> 自制小工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列11-Shell编程</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%9711-Shell%E7%BC%96%E7%A8%8B/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>正则表达式</li><li>Shell编程</li><li>Shell定制<br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2></the></li><li>正则表达式广泛应用在各种脚本语言中(解释型语言)包括Perl、PHP、Ruby和Python等，Linux的各种编程工具中也大量采用了正则表达式(Shell脚本编程)。</li><li>“正则表达式”(regexps)又被称作“模式”(至少在Linux中是这样)，是被用来字符处理的一套规则;<ul><li>简而言之，正则表达式是一组对正在查找的文本的描述。</li></ul></li><li>目前在GNU/Linux中有两套库可用于正则表达式编程：<ul><li>POSIX库：是Linux自带的正则表达式库(Python中也使用这套标准);</li><li>PCRE库：是Perl的正则表达式库。</li></ul></li><li><p>举个例子：匹配<code>/usr/share/dict/words</code>中“a开头、t结尾”的单词，采用命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ egrep <span class="string">"^a.*t$"</span> /usr/share/dict/words <span class="comment"># egrep比grep支持更多正则表达式规则，此处grep也可以</span></span><br><span class="line"><span class="comment"># 如果我们要统计总的单词数</span></span><br><span class="line">$ egrep <span class="string">'^a.*t$'</span> /usr/share/dict/words | wc -c</span><br></pre></td></tr></table></figure></li><li><p>正则表达式字符集：</p><ul><li><code>.</code>：匹配换行符之外的任意一个字符，<code>.</code>能匹配的字符范围是最大的;</li><li><code>[]</code>：指定一个字符集，要求只能匹配其中的一个字符，如<code>[abc]</code>表示三选一;</li><li><code>-</code>：连字符，和<code>[]</code>配合使用，如<code>[a-zA-Z]</code>表示匹配一个字母;</li><li><code>\&lt;</code>和<code>\&gt;</code>：一对分隔符，表示匹配一个单词，注意<strong>正则表达式中对单词的定义</strong>指的是两侧由非单词字符分隔的字符串（非单词字符指的是字母、数字、下划线以外的任何字符）;</li></ul></li><li>字符类：POSIX风格的正则表达式还提供预定义字符类来匹配某些特定的字符(但是很多类都可以用简单的正则表达式表示);</li></ul><table><thead><tr><th>类</th><th>匹配字符</th></tr></thead><tbody><tr><td>[[:alnum:]]</td><td>字母、数字字符</td></tr><tr><td>[[:alpha:]]</td><td>字母字符</td></tr><tr><td>[[:lower:]]</td><td>小写字母</td></tr><tr><td>[[:upper:]]</td><td>大写字母</td></tr><tr><td>[[:digit:]]</td><td>小数</td></tr><tr><td>[[:xdigit:]]</td><td>十六进制数字</td></tr><tr><td>[[:punct:]]</td><td>标点符号</td></tr><tr><td>[[:blank:]]</td><td>制表符和空格</td></tr><tr><td>[[:space:]]</td><td>空格</td></tr><tr><td>[[:cntrl:]]</td><td>所有控制符</td></tr><tr><td>[[:print:]]</td><td>所有可打印字符</td></tr><tr><td>[[:graph:]]</td><td>除空格外所有可打印字符</td></tr></tbody></table><ul><li>位置匹配：<ul><li><code>^</code>:用于匹配行首;</li><li><code>$</code>:用于匹配行尾。</li><li>所以如果要匹配一个空行就用<code>^$</code>，两者不必非要一起使用。</li></ul></li><li>字符转义：<ul><li><code>\</code>：当要匹配特殊字符本身时，就在前加上转义字符，取消元字符本身的特殊含义。</li></ul></li><li>重复：<ul><li><code>*</code>：表示在<code>*</code>前面的模式应该重复<strong>0次或多次</strong>;</li><li><code>+</code>:表示模式重复<strong>1次或多次</strong>;</li><li><code>?</code>:重复<strong>0次或1次</strong>;</li><li><code>{n}</code>:模式重复n次;</li><li><code>{n,}</code>:模式重复n次或更多;</li><li><code>{n,m}</code>:模式不少于n次，不多于m次。</li><li>一个例子，匹配不少于8位的数<code>\&lt;[1-9][0-9]{7,}\&gt;</code> 。</li></ul></li><li>子表达式，i.e.”分组”：<ul><li><code>()</code>:将部分字符组成一个字符组作为一个子模式，如”(or){2,}”表示整个子字符组重复2次以上，否则只重复紧挨的字符r。</li></ul></li><li>反义(<code>^</code>在行首表示位置匹配，放括号内表示反义)：<ul><li><code>^</code>:除了此字符以外，全部都可以，和<code>[]</code>配合使用，表示除括号内字符的任意一个其他字符。如<code>[^ya]</code>表示除y和a以外的任一字符。</li></ul></li><li>分支，或者叫“或”逻辑(一般正则表达式总是执行“与”逻辑，指同时满足给出的若干条件)：<ul><li><code>|</code>:如<code>^h|h$</code>表示h开头”或”h结尾，而<code>^hh$</code>表示h开头”且”h结尾(即’hh’)，一个表达式中可以出现多个或逻辑<code>Jan(uary| |\.)</code>。</li></ul></li><li>逆向引用：子表达式中捕获的内容可以在正则表达式的其他地方再次使用;<ul><li><code>\n</code>:’反斜杠+编号n’表示第n组子表示匹配到的内容，如<code>(\&lt;*.\&gt;).?( )*\1</code>可以匹配如’cart cart’,’ha!ha’这些字符组;</li><li>从左到右，第i个出现的子表达式编号为i。</li></ul></li></ul><h2 id="Shell脚本编程"><a href="#Shell脚本编程" class="headerlink" title="Shell脚本编程"></a>Shell脚本编程</h2><ul><li>Shell本身就是一个命令解释器(而不是一门编程语言)，所以可以在shell中运行命令(执行程序，命令就是语句的组合);</li><li>Shell本身都是同一个程序<code>/bin/bash</code>，子/父shell是指他们之间的调用关系。<h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3></li><li>Shell因为分许多种类，严格说这里学习的应该BASH编程。</li><li>Shell脚本语言不需要编译(并不能说’脚本语言一定不需要编译/解释型语言不需要编译’)。</li><li>下面一个例子，告诉我们：<ul><li>第一行总是以<code>#!</code>开头，指定脚本的运行环境，<code>#! /bin/bash</code>告诉shell运行此脚本应该使用的shell(可以省略但不是一个好习惯);</li><li><code>#</code>表示注释;</li><li><code>echo</code>执行时会自动加上一个换行符;</li><li>文本加上可执行权限之后才能变成脚本执行，<code>chmod a+x hello</code>/<code>chmod +x hello</code>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line">#Display a line</span><br><span class="line"></span><br><span class="line">echo &apos;Hello world!&apos; #echo会在最后自动加上一个换行符</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="变量和运算符"><a href="#变量和运算符" class="headerlink" title="变量和运算符"></a>变量和运算符</h3><ul><li>变量从诞生、消亡和作用范围：<ul><li>Shell中变量使用之前不用事先声明(脚本语言貌似都如此);</li><li><code>=</code>：赋值符号，如<code>var=1</code>就是给var赋值，<strong>注意’=’两边不能有空格</strong>;</li><li><code>$</code>:shell编程中用于对一个变量进行解析，表示取得变量的值;</li><li><code>source</code>/<code>.</code>：一般变量只在其所在的”脚本”中有效，shell中不可见其值，但<code>source</code>命令可以<strong>让一个脚本影响其父Shell环境</strong>(当前执行脚本的shell及其父shell)，使值在shell中可见;</li><li><code>export</code>：可以让脚本影响其子shell环境(子shell是在执行脚本中<code>sh</code>命令调用的shell);</li><li>在配置脚本(父shell)中命令要影响shell用<code>export</code>，在shell中要影响配置脚本用<code>source</code>;</li><li><code>unset</code>:手动注销一个变量。</li></ul></li><li><p>变量替换：</p><ul><li><code>\</code>：转义字符，如果要输出特殊字符时使用(类所有编程语言)，如<code>\$</code>输出美元符号;</li><li><code>{}</code>：限定变量的开始和结束(类python)，如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">word=<span class="string">"big"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The apple is <span class="variable">$&#123;word&#125;</span>."</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>位置变量：依次序获取各命令行参数;</p><ul><li><code>$0</code>：表示第一个<strong>命令行参数</strong>，这个参数总是脚本的名字;</li><li><code>$n</code>：表示第n个<strong>参数</strong>(不包括脚本名);</li><li><code>${n}</code>:当n为一位数以上时，需要用大括号将位置序号括起来;</li><li><code>$*</code>/<code>$@</code>:<strong>参数</strong>列表(不包括脚本名);</li><li><code>$#</code>：包含参数个数(参数列表长度)。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 是$@最常见的用法</span></span><br><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$#</span> files to list:"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="variable">$@</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">ls -l <span class="variable">$file</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>BASH引号规则</strong>：</p><ul><li><code>&quot;&quot;</code>：双引号，阻止Shell对大多特殊字符(如#)进行解释，但$/`/“仍保持其特殊含义;</li><li><code>&#39;&#39;</code>：单引号，阻止shell对所有字符进行解释;</li><li><code>\`</code>：倒引号，当倒引号括起一个shell命令时，该命令将被执行，执行后的输出结果将作为表达式的值，倒引号中的特殊字符一般都被解释。</li></ul></li><li>运算符：shell完全复制了C语言中的运算符和优先级规则。日常只使用其中部分即可，数学运算并不是shell的强项。所有可用的运算符如下，优先级从高到低：<ul><li>-，+：[<a href="单目负取反，单目正没有意义">单目[负 正]</a>[减 加]];</li><li>!，||,&amp;&amp;：逻辑[非 或 与];</li><li>~，&amp;，^，|,&gt;&gt;，&lt;&lt;：按位[取反 与 异或 或 右移 左移];</li><li>&lt;=，&gt;=,&lt;,&gt;,==,!=：[小于等于 大于等于 小于 大于 等于 不等于];</li><li>*,/,%：[乘 除 取模];</li><li>=,[+-*/%&amp;^|(&lt;&lt;)(&gt;&gt;)]=：赋值，运算并赋值。</li><li>同样可用<code>()</code>改变优先级;</li></ul></li><li>shell中相等可以用<code>=</code>和<code>==</code>表示，因为<code>=</code>赋值时两边无空格(因为变量不是命令不能分开，而整个语句才能算是一个命令)，而表示比较时两边有空格。<h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3></li><li><p><code>$[]</code>：求值后整体赋值。</p><ul><li><code>[base#]n</code>可以表示从2到36进制的任何一个n值（默认十进制），如2#10表示二进制数10;</li><li><code>$[]</code>可以接受不同基数的数字求值；</li><li>举个例子，如下第一段输出结果是<code>1+2</code>，因为shell是一种<strong>弱类型</strong>的语言，换言之shell不知道num的类型，因此只能简单取得$num将整个表达式赋值。如果按第二段就能计算后再输出结果。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">num=1</span><br><span class="line"><span class="comment"># ouput 1+2</span></span><br><span class="line">num=<span class="variable">$num</span>+2</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$num</span></span><br><span class="line"><span class="comment"># output 3</span></span><br><span class="line">num=$[num]</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>expr</code>命令也对表达式执行求值操作，可以允许更复杂的表达式。</p></li><li><code>let</code>：此命令也指导shell进行表达式求值，功能类似<code>$[]</code>，命令右边的表达式不能有空格，如<code>let num=$num+1</code>会输出值而非表达式。<h3 id="脚本执行命令和控制语句"><a href="#脚本执行命令和控制语句" class="headerlink" title="脚本执行命令和控制语句"></a>脚本执行命令和控制语句</h3></li><li><p>if条件语句格式(<strong>每个if语句都必须用fi结尾</strong>)：</p><ul><li><p>格式1:<code>if-then-fi</code>;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">test</span>-commands</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><p>格式2：<code>if-then-elif-then-else-fi</code>,当然各条件语句之间必须互斥;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">test</span>-command-1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands-1</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">test</span>-command-2</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands-2</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">test</span>-command-3</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands-3</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">commands-4</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">- **注意**(由例子):</span><br><span class="line">- (1)条件判断语句中`[`/`]`与表达式之间必须有空格，`=`两边必须有空格;</span><br><span class="line">- (2)条件语句后可以跟`;`也可以不跟，只是用于分隔语句;</span><br><span class="line">- (3)字符串可以用`<span class="string">""</span>`包围，也可以不用，等号左边的表达式/前面有`$`的是变量，否则可以自动认为是字符串。</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># if例子</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Enter password:"</span></span><br><span class="line"><span class="built_in">read</span> password</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$password</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$password</span>"</span> = john ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello John"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">"<span class="variable">$password</span>"</span> = mike ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello Mike"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">"<span class="variable">$password</span>"</span> = lewis ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello Lewis"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"I don't know you,go away"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li><p>case多选结构：用于在一系列模式中匹配某个变量的值;</p><ul><li><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> word <span class="keyword">in</span></span><br><span class="line">pattern1)</span><br><span class="line">commands1</span><br><span class="line">;;</span><br><span class="line">pattern2)</span><br><span class="line">commands2</span><br><span class="line">;;</span><br><span class="line">...</span><br><span class="line">patternN)</span><br><span class="line">commandsN</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>(将if例子用case重写)：</p></li><li>(1) <code>;;</code>相当于C语言中的<code>break</code>，shell遇见时会跳转到case结构的最后，但是Shell中<code>;;</code>是不能省略的;</li><li>(2)case语句是逐条检索匹配的;</li><li>(3)case结构最后一个模式通常用<code>*)</code>，因<code>*</code>用于匹配所有的字符串;<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># an example of case</span></span><br><span class="line"><span class="comment"># note $n means nth input params</span></span><br><span class="line"><span class="comment"># 重写if例子</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">john)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello John!"</span></span><br><span class="line">;;</span><br><span class="line">mike)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello Mike!"</span></span><br><span class="line">;;</span><br><span class="line">lewis)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello Lewis!"</span></span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Go away!!"</span></span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h3><ul><li><code>if</code>判断的依据是程序的返回值(0为真/正常，非0为假/出错序号)：<ul><li><code>if</code>接受一个程序名作为参数，根据执行程序的返回值判断是否执行：</li><li>(1)如果返回值为0，表示True;</li><li>(2)如果返回值为1，表示False。</li></ul></li><li><p>例子如下，只有返回值为0的第2条if语句成功执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ./testscript -1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"testscript exit -1"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ./testscript 0</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"testscript exit 0"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ./testscript 1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"testscript exit 1"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#----------testscript--------</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#表示退出并返回输入所有参数</span></span><br><span class="line"><span class="built_in">exit</span> <span class="variable">$@</span></span><br></pre></td></tr></table></figure></li><li><p><code>test</code>命令和空格的使用：</p><ul><li><code>test</code>:if语句既然只接受程序名为参数，所以if的条件判断需要引入一个特定的命令即<code>test</code>，也是<code>[</code>方括号的同义词;</li><li>关于空格：</li><li>(1)<code>test</code>和<code>[</code>都是<code>/usr/bin</code>下的命令，而判断的字符串(…)和<code>=</code>及<code>]</code>都是要求输入的参数，参数之间必须要空格分开(<strong>!!在赋值语句中<code>=</code>两边一定没有空格</strong>);</li><li>(2)总的来说，空格在shell这个命令解释器中的作用就是分隔命令与参数/参数与参数。</li></ul></li><li><code>test</code>/<code>[</code>命令可以对以下3类表达式进行测试(可以在<code>man test</code>中看到详细内容)：<ul><li>字符串比较(字符串相等/字符串是否为空)：<ul><li><strong>引号的使用</strong>：Bash中给字符串两边加<code>&quot;&quot;</code>不是必要的，因为Bash会自动给没有值的变量加上引号（但是有些shell不如此）,为保证清晰性和可移植性应为字符串变量加上引号。</li></ul></li></ul></li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-z str</td><td>当字符串str长度为0时返回真</td></tr><tr><td>-n str</td><td>当字符串长度不为0时返回真</td></tr><tr><td>str1 = str2</td><td>相等时返回真</td></tr><tr><td>str1 != str2</td><td>不等时返回真</td></tr></tbody></table><ul><li>文件测试：用于判断一个文件是否满足特定的条件;</li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-d pathname</td><td>是目录时返回真</td></tr><tr><td>-e pathname</td><td>指定文件或目录存在时为真</td></tr><tr><td>-f file</td><td>是常规文件(非符号链接、管道、目录等)时为真</td></tr><tr><td>-h file</td><td>是符号链接文件时返回真</td></tr><tr><td>-[rwx] pathname</td><td>当指定的文件或目录设置了可[读 写 执行]</td><td>权限时为真</td></tr></tbody></table><ul><li>数字比较：只能用于比较正/负整数<code>test int1 option int2</code>/<code>[ int1 option int2 ]</code>;</li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-eq</td><td>int1 == int2</td></tr><tr><td>-ne</td><td>int1 != int2</td></tr><tr><td>-lt</td><td>int1 &lt; int2</td></tr><tr><td>-gt</td><td>int1 &gt; int2</td></tr><tr><td>-le</td><td>int1 &lt;= int2</td></tr><tr><td>-ge</td><td>int1 &gt;= int2</td></tr></tbody></table><ul><li>复合表达式：用逻辑(与或非)串起的多个表达式；<ul><li><strong>注意</strong>：Shell的内建条件操作符<code>&amp;&amp;</code>或<code>||</code>可以代替下面的<code>-a</code>和<code>-o</code>；前者连接两条<code>[</code>或<code>test</code>语句，逻辑清晰;后者只用一条<code>[</code>/<code>test</code>语句，执行效率相对更高；如｀[ -f $@ -a -x /usr/bin/vim ]｀等于<code>[ -f $@ ] &amp;&amp; [ -x /usr/bin/vim ]</code>．</li></ul></li></ul><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>!expr</td><td>“非”运算</td></tr><tr><td>expr1 -a expr2</td><td>“与”运算</td></tr><tr><td>expr1 -o expr2</td><td>“或”运算</td></tr></tbody></table><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><ul><li>Shell中的循环结构有3种:(1)while;(2)until;(3)for;</li><li>条件测试时比较变量值时不能忘记<code>$</code>符号;</li><li><p><code>while</code>语句：</p><ul><li><p>基本结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">test</span>-commands</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p><code>while</code>语句的测试条件除了使用<code>test</code>,<code>[</code>函数，还可以利用函数<code>read</code>等的返回值。</p></li></ul></li><li><p><code>until</code>语句：和<code>while</code>功能完全一样，但是测试条件相反。</p><ul><li>基本语法，直到条件成立才停下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until <span class="built_in">test</span>-commands</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>for</code>语句：从列表/值表中逐一读取值进行操作，直到取完所有的值;</p><ul><li><strong>值表</strong>：一系列以空格分隔的值;</li><li><code>seq</code>:此命令自动接受一个参数n，产生1到n(均包含)的值表;</li><li>基本用法：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> variable [<span class="keyword">in</span> list]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>read</code>:读取用户输入;</p><ul><li>三种模式：<ul><li>(1)接受一个变量名作为参数，从标准输入中接收到的信息存放在该变量中;</li><li>(2)不提供变量名，读取的信息将放在变量<code>REPLY</code>中;</li><li>(3)提供多个变量名作为参数，Bash默认空格、制表符和换行符为分隔符，将输入拆开分别赋值给各变量;</li></ul></li><li><code>read</code>常用来在输出一段内容后暂停，等待用户的下一步指令(如“继续”)。<h3 id="脚本执行命令"><a href="#脚本执行命令" class="headerlink" title="脚本执行命令"></a>脚本执行命令</h3></li></ul></li><li><code>exit</code>：强行退出一个脚本，并向调用脚本的<strong>父进程</strong>返回一个整数值;<ul><li>进程成功运行，返回值是0，非0值表示发生某种异常;</li><li>简要用法是<code>exit n</code>。</li></ul></li><li><code>trap</code>：用于捕捉一个信号，如进程通信中，<em>用于捕捉且忽视一个信号</em>;<ul><li><code>trap</code>要<strong>置于文件首</strong>才能捕获信号;</li><li>常见信号类型用<code>kill -l</code>获取(INT为’Ctrl+c’，EXIT为’Ctrl+D’);</li><li>基本语法<code>trap &#39;commands&#39; SIGNAL</code>。</li></ul></li><li><p><code>&amp;&amp;</code>和<code>||</code>用于创建命令表：命令表利用前一个命令的退出值来控制是否执行另一条命令，命令会被自动识别寻找参数输入。</p><ul><li>3种形式命令表(<code>;</code>顺序命令表已经在<code>if</code>等语句中出现过)：<br>| 表现形式 | 说明 |<br>| — | — |<br>| a&amp;&amp;b | “与”命令表。当且仅当a执行成功，才执行b |<br>| a||b | “或”命令表。当且仅当a执行失败，才执行b |<br>| a;b | 顺序命令表。先执行a，再执行b |</li><li>关于命令的生效范围(见例子)：在脚本中的程序通常是调用子shell完成功能，如果要在执行脚本时对当前shell(即父shell)完成，用<code>source</code>命令。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">dirname=~/LearningNotes/git</span><br><span class="line"><span class="comment">#echo $dirname</span></span><br><span class="line"><span class="built_in">test</span> -d <span class="variable">$dirname</span> &amp;&amp; <span class="built_in">cd</span> <span class="variable">$dirname</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>其他Shell编程工具：</p><ul><li>以下命令均<strong>不改变源文件</strong>;</li><li><code>cut</code>：从输入行中提取指定部分;<ul><li><code>-c</code>:提取一行中指定范围的字符，如<code>cut -c3-6 file_name</code>;</li><li><code>-f</code>:提取指定行中指定的字段，分隔符用<code>-d</code>指定(否则默认使用TAB)，如<code>cut -d&quot; &quot; -f2 file_name</code>截取第2个字段。</li></ul></li><li><code>diff</code>：用于确定两个版本的源文件存在哪些修改;<ul><li>用法:<code>diff file1 file2</code>。</li></ul></li><li><code>sort</code>：以行为输入单位，对其按照字母顺序进行排列;<ul><li><code>-r</code>:默认按字母升序排列，<code>-r</code>使按降序排列;</li><li><code>-k&lt;num&gt;</code>:默认按照第1个字段执行排序，<code>-k</code>可以指定按第<num>字段排序。</num></li></ul></li><li><code>uniq</code>：从<strong>已排好序</strong>的输入行中删除重复的行，通常和<code>sort</code>命令结合管道工作。</li><li><code>tr</code>：按照用户指定方式对字符执行替换，结果输送到标准输出;<ul><li><code>tr &quot;ABH&quot; &quot;HCA&quot; &lt; file</code>：ABH分别替换为HCA;</li><li><code>tr &quot;ABC&quot; &quot;[Z*]&quot; &lt; file</code>/<code>tr &quot;A-C&quot; &quot;[Z*]&quot; &lt; file</code>：替换成”Z”;</li><li><code>tr --delete &quot; &quot; &lt; file</code>:删除空格。</li></ul></li><li><code>wc</code>：用来统计文件中字节、单词和行的数量;<ul><li>常用选项：</li></ul></li></ul></li></ul><table><thead><tr><th>选 项</th><th>描 述</th></tr></thead><tbody><tr><td><code>-c</code>/<code>--bytes</code></td><td>显示字节数</td></tr><tr><td><code>-l</code>/<code>--lines</code></td><td>显示行数</td></tr><tr><td><code>-L</code>/<code>--max-line-length</code></td><td>显示最长一行的长度</td></tr><tr><td><code>-w</code>/<code>--words</code></td><td>显示单词个数</td></tr><tr><td><code>--help</code></td><td>显示帮助</td></tr></tbody></table><ul><li><code>substr</code>：从字符串提取一部分，是shell内建的运算符，<strong>必须使用<code>expr</code>进行表达式求值</strong>;<ul><li>依次接受3个参数：(1)字符串/存放字符串的变量;(2)提取开始的位置(从1开始计数);(3)需要提取的字符数。</li><li>用法：<code>expr substr &quot;Hello World&quot; 1 5</code>。</li></ul></li><li><code>seq</code>：用于产生一个整数数列;<ul><li>只指定结束值：<code>seq &lt;end&gt;</code>产生从1到<num>的数列;</num></li><li>指定开始和结束：<code>seq &lt;start&gt; &lt;end&gt;</code>产生从<start>到<num>的数列;</num></start></li><li>指定开始结束和步长：<code>seq &lt;start&gt; &lt;step&gt; &lt;end&gt;</code>。<h2 id="Shell定制"><a href="#Shell定制" class="headerlink" title="Shell定制"></a>Shell定制</h2></li><li>设置环境变量</li><li>设置别名<h3 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h3></li><li>“环境变量”是一些和当前Shell有关的变量，用于定义特定的Shell行为;</li><li><code>printenv</code>查看当前Shell的所有环境变量。</li><li><code>PATH</code>:搜索路径，是最常用的环境变量之一，这个变量告诉Shell在什么地方查找用户要求执行的程序;\</li></ul></li><li><code>PATH</code>变量用一系列冒号分隔各目录，用户如果没有命令完整路径，Shell会依次在PATH变量指定的目录中查找;</li><li>追加路径：<code>PATH=$PATH:/usr/local/bin</code>;</li><li>shell中修改的变量只在当前shell中有效(所以有配置文件的存在);</li><li>执行本地程序用<code>./program</code>一是为了安全，在安全性要求更高的场合应该输入完全路径;二是因为命令通常在PATH中搜索，所以要加上<code>./</code>目录才能运行。<ul><li><code>alias</code>：设置命令(即程序)别名;</li></ul></li><li>用法:<code>alias ll=&#39;ls -l&#39;</code>。<ul><li>配置文件：shell中运行的命令只是临时有效，要保持长久有效需要将命令输入到配置文件中。</li></ul></li><li><code>~/.bashrc</code>：Shell为每个用户维护了一个配置文件，对当前用户有效，<strong>推荐</strong>;</li><li><code>/etc/bash.bashrc</code>：全局shell配置文件，对所有用户有效。</li><li>用<code>source</code>命令生效。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><em>Linux从入门到精通 刘忆智 著</em></p>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列10-Linux编程</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%9710-VIM/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>Linux下编辑器VIM的操作<ul><li>保存和编辑</li><li>字符串的搜索和替换</li><li>针对程序员的配置</li></ul></li><li>C/C++的编译、运行和调试</li><li>版本管理系统简介<br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="Vim编辑器"><a href="#Vim编辑器" class="headerlink" title="Vim编辑器"></a>Vim编辑器</h2></the></li><li>Vim是Vi的增强版本，在不正式的情况下，两者是一回事。</li><li>Vim是所有UNIX和Linux系统下的标准软件。<h3 id="两种模式-编辑和保存"><a href="#两种模式-编辑和保存" class="headerlink" title="两种模式/编辑和保存"></a>两种模式/编辑和保存</h3></li><li><code>vim file</code>:对文件用vim编辑器进行编辑。如果文件不存在，Vim将自动创建文件。<ul><li><code>vim</code> : 不带参数的vim自动打开编辑器。</li></ul></li><li>vim分为<em>插入</em>和<em>命令</em>两种模式。Vim启动时自动处于命令模式。<ul><li>按’I’键进入插入模式，此模式下可以输入字符;</li><li>按’Esc’键进入命令模式，此模式下执行除了字符操作以外的所有操作，包括保存、搜索、移动光标等。</li></ul></li><li>命令模式下，输入“：”在底部打开一个命令行，此时光标闪烁输入，等待用户输入。</li><li>H、J、K、L分别代表向左、上、下、右移动。当然使用方向键也是可以的。</li><li>O在当前行下插入一行空白行。</li><li><code>w</code>保存，<code>q</code>退出，<code>wq</code>保存且退出，<code>q!</code>强制退出。<h3 id="搜索字符串"><a href="#搜索字符串" class="headerlink" title="搜索字符串"></a>搜索字符串</h3></li><li><code>/string</code>用于搜索一个字符串，输入<code>/</code>后，vim底部也会出现一个命令行。</li><li>vim的搜索可以循环进行，<code>/</code>命令向前(文件尾)查找，<code>？</code>命令向后(向文件头)查找。</li><li>对大小写是否敏感：<ul><li><code>:set ignorecase</code>命令vim忽略大小写;</li><li><code>:set noignorecase</code>命令vim重新开启大小写敏感。<h3 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h3></li></ul></li><li><code>:[range]s/pattern/string/[c,e,g,i]</code>:替换命令的完整语法，将匹配pattern(正则表达式)的字符串替换为string。<ul><li>range规定替换范围，<code>1,4</code>表示1到4行，<code>1,$</code>表示1行到最后一行(全文)，<code>%</code>也表示全文。</li><li>最后方括号内的字符是可选选项，选项含义如下：</li></ul></li></ul><table><thead><tr><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>c</td><td>每次替换前询问</td></tr><tr><td>e</td><td>不显示错误信息</td></tr><tr><td>g</td><td>替换一行中的所有匹配项（通常需要使用,否则替换第一项）</td></tr><tr><td>i</td><td>不区分大小写</td></tr></tbody></table><ul><li>*清除文本文件中的<code>^M</code>字符：由于来自windows环境的源代码对换行符的表述和Linux不一致，因此文末常出现<code>^M</code>符号——虽然对程序编译器和解释器没有影响，但在shell编程时会产生问题，此时用<code>%s/^M$//g</code>删除行末的<code>^M</code>字符。<h3 id="针对程序员的配置"><a href="#针对程序员的配置" class="headerlink" title="针对程序员的配置"></a>针对程序员的配置</h3></li><li>一些常用的配置命令：<ul><li><code>:syntax on</code>打开语法高亮，vim会根据文件扩展名决定哪些为关键字。</li><li><code>:set autoindent</code>设置自动缩进;</li><li><code>:set shiftwidth=4</code>设置自动缩进的空白长度;</li><li><code>:set tabstop=4</code>将tab键缩进设置为4个空格。</li></ul></li><li>为避免每次启动vim都要手动输入命令，可以将命令写入vim的配置文件中(文件中不要包含<code>:</code>)，vim的配置文件为<code>/etc/vim/vimrc</code>(/etc中的文件对系统中所有用户生效)，推荐用户可以新建一个<code>~/.vimrc</code>文件在其中写入配置信息，只对当前用户生效。<ul><li><strong>通常用户个性化的设置文件都是隐藏文件(<code>.</code>开头的文件)，且保存在用户主目录下</strong>。<h3 id="Vim的常用命令总结"><a href="#Vim的常用命令总结" class="headerlink" title="Vim的常用命令总结"></a>Vim的常用命令总结</h3></li></ul></li><li>模式切换：<ul><li><code>a</code>:在光标后插入;</li><li><code>i</code>:在光标所在位置插入;</li><li><code>o</code>：在光标所在位置下一行插入;</li><li><code>Esc</code>:进入命令模式;</li><li><code>:</code>进入行命令模式。</li></ul></li><li>光标移动(名列前加上数字，可以重复多次移动，如<code>5w</code>)：<ul><li><code>h</code>/<code>l</code>/<code>j</code>/<code>k</code>：光标向左/右/上/下移动;</li><li><code>^</code>/<code>$</code>：移动光标到行首/尾;</li><li><code>gg</code>/<code>shift+g</code>:移动光标到文件首/尾;</li><li><code>w</code>/<code>b</code>:移动到下一个/上一个单词;</li><li><code>ctrl+f</code>/<code>ctrl+b</code>:向前(文件尾)/后(文件头)翻动一页。</li></ul></li><li>删除、复制和粘贴：<ul><li><code>x</code>:删除光标所在位置的字符;</li><li><code>dd</code>：删除光标所在行;</li><li><code>shift+d</code>:删除光标所在位置到行尾的所有字符;</li><li><code>d</code>:和移动命令配合使用的删除命令，如<code>dw</code>表示删除光标所在位置到下一个单词之间的所有字符;</li><li><code>yy</code>:复制光标所在行;</li><li><code>y</code>:和移动命令配合使用的复制命令;</li><li><code>shift+p</code>:在光标所在位置粘贴最近复制/删除的内容。</li></ul></li><li>撤销和重做：<ul><li><code>u</code>：撤销一次操作;</li><li><code>ctrl+r</code>:重做被撤销的操作。</li></ul></li><li>搜索和替换：<ul><li><code>:/string</code>：向前搜索字符串string;</li><li><code>:?string</code>：向后搜索字符串string;</li><li><code>:s/pattern/string</code>：将pattern代表的字符串替换成string。</li></ul></li><li>保存和退出：<ul><li><code>:w</code>：保存文件;</li><li><code>:w filename</code>：另存为filename;</li><li><code>:q</code>：退出vim;</li><li><code>:!q</code>：强制退出，放弃保存修改。<h2 id="C-C-的编译-gcc-g"><a href="#C-C-的编译-gcc-g" class="headerlink" title="C/C++的编译(gcc/g++)"></a>C/C++的编译(gcc/g++)</h2></li></ul></li><li>gcc最初是C编译器(GNU C Compiler)，如今支持多种语言编译(GNU Compiler Collection)。</li><li><code>gcc *.c</code>:编译C源文件，默认产生一个可执行文件为<code>a.out</code>;<ul><li><code>gcc -o &lt;outname&gt; *.c</code>:指定产生的可执行文件名字为<code>outname</code>。</li></ul></li><li>*和编译有关的选项：<ul><li><code>-c</code>：只激活预处理、编译和汇编，生成扩展名为.o的目标代码文件(在编写大型程序时必须，存在依赖关系的源代码应首先编译成目标代码，最后连接成可执行文件，超过3个源文件考虑用<code>make</code>);</li><li><code>-S</code>：只激活预处理和编译，并生成扩展名为.s的汇编代码文件;</li><li><code>-E</code>：只激活预处理，并将结果输出至标准输出;</li><li><code>-g</code>：为调试程序(gdb)生成相关信息。</li></ul></li><li>优化选项：gcc提供了从低到高3个级别的优化选项，依次为<code>-O1</code>、<code>-O2</code>、<code>-O3</code>。<ul><li>优化程序越高，效率越高，相应风险越大;</li><li>通常<code>-O2</code>选项可以满足绝大多数优化需求;</li><li>这三个优化级别其实就是对多个优化选项的“打包”。</li></ul></li><li><code>-march=</code>生成只适合特定CPU的二进制代码(一般不使用)。</li><li><code>g++ *.cpp</code>：用g++完成C++程序的编译和连接(<code>gcc</code>可以编译C++源文件，但不能和C++程序使用的库连接)，会自动调用<code>gcc</code>完成对文件的编译;<ul><li><code>-o</code>：同<code>gcc</code>，此选项指定可执行文件名。<h2 id="C程序的调试-gdb"><a href="#C程序的调试-gdb" class="headerlink" title="C程序的调试(gdb)"></a>C程序的调试(gdb)</h2></li></ul></li><li>使用<code>gdb</code>调试C/C++程序之前，要先使用<code>gcc -g</code>生成带有调试信息的可执行程序，否则只有汇编代码存在。</li><li><code>gdb a.out</code>：gdb以可执行二进制文件为参数，对其进行调试，运行后显示提示符(gdb)等待接受用户指令;一些常用指令如下：<ul><li><code>help</code>/<code>help &lt;command&gt;</code>：获取(和特定命令)有关的帮助信息;</li><li>支持<tab>命令补全，当不足以确定唯一命令时，连按两次tab获得所有符合要求的命令;</tab></li><li>支持命令缩写，如<code>h</code>就可以替代<code>help</code>;</li><li><code>list</code>/<code>l</code>:用于查看程序源代码(会自动在源代码前加上行号，每次显示10行，可指定中间行);</li><li><code>search &lt;content&gt;</code>：搜索特定内容，只能向前搜索，不能循环，支持正则表达式;</li><li><code>reverse-search &lt;content&gt;</code>：反向搜索特定内容，向后搜索，支持正则表达式。</li></ul></li><li>断点指令：<ul><li><code>break</code>/<code>b</code>：在指定位置设置断点，可以用行号或函数名做参数;</li><li><code>info break</code>：查看已设置断点信息;</li><li><code>clear</code>：清除当前行断点。</li></ul></li><li>运行程序和单步执行：<ul><li><code>run</code>/<code>r</code>：运行程序至断点;</li><li><code>next</code>/<code>n</code>：单步执行程序，可在后面添加数字n，表<strong>连续执行n行</strong>;</li><li><code>step</code>/<code>s</code>：单步执行，会在遇见函数时进入函数内部，而<code>n</code>只执行调用函数不进入内部;</li><li><code>continue</code>/<code>c</code>：继续运行程序直至遇见下一个断点;</li></ul></li><li>监视变量：<ul><li><code>print</code>/<code>p</code>：打印指定变量的值;</li><li><code>watch</code>/<code>w</code>：设置观察点(可以看作是变量的一种)，以变量名/表达式为参数，一旦参数值发生变化，就停下程序。</li></ul></li><li>临时修改变量：<ul><li><code>set var</code>实现，如<code>set var i=1</code></li></ul></li><li>查看堆栈情况(每次程序调用一个函数，其地址、参数、函数内的局部变量都会被压入栈中)：<ul><li><code>bt</code>实现。</li></ul></li><li>退出gdb：<ul><li><code>quit</code>/<code>q</code>。<h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2></li></ul></li><li>不论是与他人协作还是管理自己的密码，版本控制系统(git和SVN)都是非常好的工具。</li><li>版本控制系统是一套在开发程序时存储源代码所有修改的工具。满足这些需求：<ul><li>集中化管理，自动跟踪单个文件的修改历史;</li><li>完善的日志机制，便于掌握某次修改的原因;</li><li>快速还原到指定的版本;</li><li>协调不同开发者之间的活动，保证对源代码同一部分的改动步互相覆盖。</li></ul></li><li>Subversion相比git，管理人员对开发人员的权利可以作出规范，但git是最好用的版本管理工具。</li><li>git的使用，可以参考我的其他笔记。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><em>Linux从入门到精通 刘忆智 著</em></li></ul>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列9-网络配置和远程访问</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%979-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>连网方式的介绍</li><li><code>ifconfig</code>用于命令行下配置网络</li><li><code>route</code>配置静态路由</li><li>简单计算机网络概念</li><li><code>ftp</code>命令</li><li>基于SSH的文件传输<code>sftp</code>和<code>scp</code></li><li>关于Linux系统的远程登录<br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="连网方式"><a href="#连网方式" class="headerlink" title="连网方式"></a>连网方式</h2></the></li><li>连网方式：<ul><li>局域网(以太网技术，基于载波侦听、多路访问和冲突检测的连网协议);</li><li>无线连接(WPA加密);</li><li>有线宽带连接;<ul><li>DSL(Digital Subscriber Line)指数字用户线路，目前主要使用ADSL，A(asymmetric)表示非对称，即上传和下载速度不同。</li></ul></li><li>拨号上网(Modem)。</li></ul></li><li>局域网：<ul><li>DHCP(动态主机配置协议)：自动获取IP地址、网络掩码、默认网关和域名服务器;</li><li>静态IP：需要手动输入上述内容(<strong>服务器</strong>一般需要设置静态IP)。</li></ul></li><li>ADSL：<ul><li>使用以太网PPPoE(Point to Point Protocol over Ethernet)调制解调器设置实现连接，是一种称作”点到点”的拨号方式;</li><li>连接方式1：network manager,推荐，方便配合IPV6使用;</li><li>连接方式2：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置</span></span><br><span class="line">sudo pppoeconf</span><br><span class="line"><span class="comment"># 开启</span></span><br><span class="line">sudo pon dsl-provider</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">sudo poff dsl-provider</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="命令行下配置网络"><a href="#命令行下配置网络" class="headerlink" title="命令行下配置网络"></a>命令行下配置网络</h2><h3 id="ifconfig配置接口"><a href="#ifconfig配置接口" class="headerlink" title="ifconfig配置接口"></a><code>ifconfig</code>配置接口</h3><ul><li><code>ifconfig</code>：用于启动或禁用一个网络接口，同时设置其IP地址、子网掩码及其他网络选项。</li><li><code>sudo ifconfig eth0 192.168.1.14 netmask 255.255.255.0 up</code>，表示设置网络硬件接口的IP地址(无线网络接口往往以<code>wlan</code>开头),掩码设置，同时启动该网络接口。</li><li><code>sudo eth0 down</code>关闭网络接口。</li><li>网络基础：<ul><li>IP地址：一个长4个字节的二进制数，每个字节用10进制数表示就成了常见的IP地址形式;</li><li>IP地址分为网络部分和主机部分(如N.N.N.H)：<ul><li>网络部分：表示地址所指的逻辑网络;</li><li>主机部分：表示网络中的一台计算机。</li><li>通过对IP地址和子网掩码实施“与”运算，可以将网络号分离出来。</li></ul></li></ul></li><li><code>lo</code>网络接口是“环回网络”，是一个没有实际硬件接口的虚拟网络，<code>127.0.0.1</code>这个环回网络始终指向当前主机，也可以用<code>localhost</code>表示当前主机。<h3 id="用route配置静态路由"><a href="#用route配置静态路由" class="headerlink" title="用route配置静态路由"></a>用<code>route</code>配置静态路由</h3></li><li>路由是定义网络中两台主机间如何通信的一种机制。</li><li>Linux内核中维护着一张路由表，需要发送数据包时，Linux将这个包的目标IP地址和路由表中的路由信息比较。<ul><li>找到匹配项时，该数据包就会发送到这条路由对应的网关，网关负责将数据包转发到目的地;</li><li>找不到匹配项时，数据包会被发送到默认路由指定的网关上;</li><li>总的路线是”数据包–&gt;网关–&gt;目的地”;</li><li><strong>网关就是负责转发的主机，必须处在当前可以直接连接到的网络上(不需要转发)</strong>。</li></ul></li><li><code>netstat -r</code>查看当前系统的路由信息。<ul><li>路由表中网关<code>*</code>表示不需要网关,意味处于同一网络(一般是网络地址，末字节为0);</li></ul></li><li><code>route</code>：用于增加/删除一条路由;<ul><li><code>sudo route add default gw 10.71.84.2</code>表示增加路由表项，一条默认路由;</li><li><code>sudo route add -net 10.62.74.0/24 gw 10.71.84.51</code>增加一条目的网络路由：<ul><li><code>-net</code>表示增加的是网络地址，目的网络;</li><li><code>10.62.74.0/24</code>前部分是网络地址，24表示IP的网络地址占据24位，对应子网掩码是255.255.255.0;</li></ul></li><li><code>-host</code>：用此选项增加一条发往主机地址的路由表项。</li></ul></li><li>一般一个IP代表一台主机。全0主机地址保存为网络地址(整个网络)，全1的主机地址是广播地址(网络中的所有主机)。</li><li><code>del</code>用于删除路由，如<code>sudo route del default</code>。<h3 id="主机和IP间的映射"><a href="#主机和IP间的映射" class="headerlink" title="主机和IP间的映射"></a>主机和IP间的映射</h3></li><li>主机名是为了方便记忆，而数据传送时需要的是IP地址，映射的方法主要有：<ul><li>DNS:网络中存在DNS服务器，当用户发起查询时提供IP地址;</li><li>hosts:文件中指定本地映射关系(<code>localhost</code>和本地主机名对应的IP地址，均为<code>127.0.0.1</code>)。<h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3></li></ul></li><li>PPP协议(Point-to-Point Protocol,点到点协议)是目前应用最广泛的数据传输协议之一。</li><li>PPP建立网络连接的步骤：<ul><li>使用串行调制解调器拨号;</li><li>登录远程主机(通常是运营商的接入服务器);</li><li>启动远程PPP协议引擎;</li><li>将串行端口配置为网络接口。</li></ul></li><li>ADSL使用的PPPoE(PPP over Ethernet)就是PPP的衍生物。</li></ul><h1 id="浏览网页"><a href="#浏览网页" class="headerlink" title="浏览网页"></a>浏览网页</h1><ul><li><code>cookie</code>：<ul><li>在用户浏览网页时，一些服务器会在用户机器的特定目录(由浏览器指定)下存储一些信息用于确定用户的身份(因此用户在不同页面之间切换时，不用重复输入验证信息)，这些信息非常短小，因此被形象地称为<code>cookie</code>;</li><li>cookie由浏览器管理，可以设置失效期限;</li><li>一些恶意程序会窃取保存在cookie中的个人信息，因此定期清理是个好习惯。</li></ul></li><li>RSS(聚合内容，Really Simple Syndication)提供了一种订阅信息的途径：<ul><li>RSS是在线共享内容的一种简易方式，网站通过RSS输出，让用户获取网站内容的最新更新;</li><li>实时书签，自动显示最近更新的文章标题。</li></ul></li><li>Lynx：一款基于文本的浏览器，工作在Shell下。<ul><li>Lynx可以工作在多个操作系统平台上，是GNU/Linux中很流行的console浏览器;</li><li>当图形界面无法使用时，Lynx是个很好的选择;</li><li>访问网站：<code>lynx www.csdn.net</code>直接用lynx打开网址;</li><li>查找字符串：<code>/</code>命令可以打开命令行查找网页中的字符串;</li><li>退出浏览器：<code>q</code>退出;</li><li>下载和保存文件：移动光标使链接高亮显示，按<code>d</code>指示Lynx下载该链接对应文件;<h1 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h1></li></ul></li><li>NFS是Linux间的网络硬盘。<ul><li>NFS目前只用于在Linux和UNIX主机间共享文件系统;</li><li>“推荐”用<code>sudo mount -o rw</code>可读写方式安装文件系统;</li><li>如果要在启动时自动安装文件系统<code>nfs</code>，应配置<code>/etc/fstab</code>文件加上<code>nfs</code>项，运行<code>sudo mount -a -t nfs</code>使配置生效;</li><li>卸载文件系统前应确保没有其他进程在使用该文件系统;</li><li>如果发现进程被占用，用<code>lsof</code>命令查询哪些进程在使用该文件系统;</li><li>如果所有办法都不奏效，用<code>umount -f</code>强制卸载文件系统。</li></ul></li><li>CIFS(Common Internet File System，公共Internet文件系统)是Windows用来”共享”文件的协议机制。</li><li>Samba能够将Windows包含到Linux网络中：<ul><li>Samba提供了对CIFS的实现，用于Linux和Windows主机之间的文件共享;</li><li>安装在Linux主机上的Samba服务器端程序向Windows机器提供Linux共享，Windows主机则不需要安装其他特殊工具。</li></ul></li><li><code>nautilus</code>命令打开Linux下的“文本浏览器”。</li><li>用<code>FTP</code>在Linux系统下载文件：<ul><li>可以用Web浏览器/文件浏览器查看FTP服务器上的文件，只要在地址中加上”ftp://“前缀告诉浏览器要使用FTP协议，但是还是用FTP客户端最方便下载和上传;</li><li><code>FileZilla</code>是对中文编码支持最好的FTP客户端;<ul><li><code>FileZilla</code>在Ubuntu安装源也提供了下载;<ul><li>用户名必须提供主机名、用户名、口令和服务器端口(除主机名外，其他都是可选的);</li><li>服务器端口默认是21;</li><li>如果“用户名”和“口令”两个文本框中留白，则以“匿名用户”登录;</li><li>如果是中文站点，将该站点使用的字符编码填入“站点管理器”——&gt;”字符集”——&gt;“使用自定义的字符集”——&gt;“编码”框内(通常是gbk)。</li></ul></li></ul></li><li><code>ftp</code>命令：是Linux自带的一个命令行的FTP工具，基本可以完成所有基本的FTP操作;<ul><li>登录：<code>ftp [host [port]]</code>;</li><li>匿名连接：用户名应输入<code>anonymous</code>;</li><li>连接服务器：<code>open</code>;</li><li>关闭连接但不退出服务器：<code>close</code>/<code>disconnect</code>;</li><li>删除远程服务器文件：<code>delete &lt;file&gt;</code>;</li><li>远程浏览文件/换路径：与shell命令一致;</li><li>下载一个文件：<code>get &lt;filename&gt;</code>下载文件当前路径;</li><li>下载多个文件：<code>mget &lt;file...&gt;</code>下载多个文件，也可以用通配符指定多个文件;</li><li>上传一个文件/多个文件：<code>put &lt;filename...&gt;</code>;</li><li>关闭交互模式：<code>prompt off</code>;</li><li>改变本地目录：<code>lcd</code>;</li><li>本地执行命令：<code>!</code>在命令前表示本地执行;</li><li>列出所有命令/特定命令：<code>?</code>/<code>? &lt;command&gt;</code>;</li><li>退出：<code>quit</code>/<code>bye</code>。<h3 id="基于SSH的文件传输：sftp和scp"><a href="#基于SSH的文件传输：sftp和scp" class="headerlink" title="基于SSH的文件传输：sftp和scp"></a>基于SSH的文件传输：<code>sftp</code>和<code>scp</code></h3></li></ul></li></ul></li><li><code>sftp</code>：基于<code>SSH</code>的文件传输，和传统FTP沾不上什么关系，<strong>同样支持多用户登录</strong>;<ul><li>用<code>sftp</code>传输有助于保护用户账户和传输安全;</li><li><code>sftp</code>建立连接和上传/下载文件的流程：<ul><li>首先要确保远程主机开启了SSH守护进程，用命令<code>sftp user@&lt;ipaddress&gt;</code>建立连接;</li><li><code>sftp</code>的常见命令与<code>ftp</code>的基本命令大部分一致。</li></ul></li></ul></li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>cd</code></td><td>切换远程所在的目录</td></tr><tr><td><code>ls</code>或<code>dir</code></td><td>显示当前目录下的文件列表</td></tr><tr><td><code>mkdir</code></td><td>建立目录</td></tr><tr><td><code>rmdir</code></td><td>删除目录</td></tr><tr><td><code>pwd</code></td><td>显示当前远程目录</td></tr><tr><td><code>chgrp</code></td><td>修改文件(目录)的属组</td></tr><tr><td><code>chown</code></td><td>修改文件(目录)的属主</td></tr><tr><td><code>chmod</code></td><td>修改文件(目录)的权限</td></tr><tr><td><code>rm</code></td><td>删除文件/目录</td></tr><tr><td><code>rename &lt;oldname&gt; &lt;newname&gt;</code></td><td>修改文件名</td></tr><tr><td><code>exit</code>或<code>bye</code>或<code>quit</code></td><td>关闭sftp客户端程序</td></tr><tr><td><code>lcd</code></td><td>切换本地所在目录</td></tr><tr><td><code>lls</code></td><td>显示本地所在目录下的文件列表</td></tr><tr><td><code>lmkdir</code></td><td>当地新建目录</td></tr><tr><td><code>lpwd</code></td><td>显示当地所在的文件目录</td></tr><tr><td><code>put</code></td><td>上传文件</td></tr><tr><td><code>get</code></td><td>下载文件</td></tr></tbody></table><h3 id="利用SSH通道复制文件-scp"><a href="#利用SSH通道复制文件-scp" class="headerlink" title="利用SSH通道复制文件:scp"></a>利用SSH通道复制文件:<code>scp</code></h3><ul><li>使用<code>scp</code>前应先断开<code>SSH</code>连接。</li><li>从服务器复制文件到本地：<code>scp username@&lt;ip_address&gt;:&lt;remote_file_path&gt; &lt;local_file_path&gt;</code>;</li><li>从本地复制文件到服务器：<code>scp &lt;local_file_path&gt; username@&lt;ip_address&gt;:&lt;remote_file_path&gt;</code>。</li></ul><h1 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h1><h2 id="登录另一台Linux服务器"><a href="#登录另一台Linux服务器" class="headerlink" title="登录另一台Linux服务器"></a>登录另一台Linux服务器</h2><h3 id="SSH登录：命令行登录"><a href="#SSH登录：命令行登录" class="headerlink" title="SSH登录：命令行登录"></a>SSH登录：命令行登录</h3><ul><li><code>OpenSSH</code>：是Linux下最常用的SSH服务器/客户端;所有的Linux发行版都附带此软件(client)，可以直接通过安装源安装;<ul><li>安装OpenSSH：<code>sudo apt install ssh</code>;<ul><li>完成安装后系统会自动启动SSH服务器，同时设置为随系统启动;</li><li>如果服务器没有运行，手工执行带有<code>start</code>参数的<code>ssh</code>脚本，启动SSH服务器程序，<code>sudo /etc/init.d/ssh start</code>(守护进程)。</li></ul></li></ul></li><li>SSH(Secure SHell)：<ul><li>支持多用户同时登录;</li><li>会对用户身份验证，并加密两台主机之间的通信;</li><li>SSH商业化版本为SSH2，开源版本为OpenSSH。</li></ul></li><li>SSH远程登录：<ul><li>仅访问命令行：<code>ssh username@ip_address</code>/<code>ssh -l username ip_address</code>;</li><li>需运行X应用程序：<code>ssh -X</code>启动X转发功能，将远程的X应用程序界面完整传输到本地;</li><li>需指定端口：<code>ssh -p port</code>;</li><li>退出:<code>exit</code>;</li><li>登录后一切操作都发生在远程服务器。</li></ul></li><li>SSH密钥登录：避免每次登录时都需要输入口令;<ul><li>基本原理：<ul><li>产生一对互相匹配的密钥文件(公钥和私钥);</li><li>管理员的PC上保存私钥文件的副本;</li><li>与私钥文件匹配的公钥文件存放在服务器上;</li><li>建立SSH时检查密钥对的匹配性。</li></ul></li><li>操作过程：<ul><li>生成密钥对：<code>ssh-keygen -t rsa</code>在用户主目录下<code>.ssh</code>目录中生成密钥对，<code>id_rsa</code>是私钥文件，<code>id_rsa_pub</code>是公钥文件;</li><li>复制公钥至远程主机：<code>scp &lt;local-ssh&gt;/id_rsa.pub user@ip:&lt;remote-ssh&gt;/authorized_keys</code>。<h3 id="登录X窗口系统：图形化的VNC"><a href="#登录X窗口系统：图形化的VNC" class="headerlink" title="登录X窗口系统：图形化的VNC"></a>登录X窗口系统：图形化的VNC</h3></li></ul></li></ul></li><li><code>VNC</code>用于图形化的远程登录：<ul><li>大部分LInux发行版都附带这个软件的服务器端;</li><li>Ubuntu下，用命令<code>sudo apt install vnc4-common vnc4server</code>安装服务器端程序。</li></ul></li><li>VNC(Virtual Network Computing，虚拟网络计算)：如果要直接从X窗口登录服务器，用VNC登录。<ul><li>服务器端的配置：<ul><li><code>vncserver</code>：运行命令，设置命令，自动在主机用户目录下生成VNC配置文件。</li></ul></li><li>客户端的配置：<ul><li>需要下载特定的客户端的程序如<code>vncviewer</code>;</li><li><code>vncviewer 127.0.0.1:1</code>：登录命令，冒号后数字代表桌面号。<h2 id="从Windows登录Linux"><a href="#从Windows登录Linux" class="headerlink" title="从Windows登录Linux"></a>从Windows登录Linux</h2></li></ul></li></ul></li><li>开源代码的PuTTY使用最为广泛。</li><li>VNC也有Windows版本。<h3 id="登录Windows服务器"><a href="#登录Windows服务器" class="headerlink" title="登录Windows服务器"></a>登录Windows服务器</h3></li><li>Windows上安装<code>VNC Server</code>。</li><li>直接通过RDP协议连接Windows服务器：<ul><li>要确保Windows主机已开启“远程登录”(允许用户远程连接到此计算机)功能;</li><li>登录：<code>rdesktop -u username ip-address</code>在Linux上会显示windows桌面窗口;</li><li>修改端口：RDP协议默认端口是3389，要修改端口在IP地址+冒号<code>:</code>+端口号。</li></ul></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><em>Linux从入门到精通 刘忆智 著</em></p>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列8-进程管理</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%978-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>对进程及其属性的介绍</li><li><code>ps</code>进程监视命令</li><li><code>top</code>命令即时跟踪进程</li><li><code>lsof</code>命令查看占用文件进程</li><li><code>kill</code>命令向进程发送信号</li><li>/PROC文件系统<br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2></the></li><li>下列是一个自动创建进程的badpro程序,会自动打开程序并且创建目录和文件。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line">while echo &quot;I&apos;m making files!!&quot;</span><br><span class="line">do</span><br><span class="line">mkdir adir</span><br><span class="line">cd adir</span><br><span class="line">touch afile</span><br><span class="line"></span><br><span class="line">sleep 2s</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x badpro</span><br><span class="line">$ ./badpro &amp;</span><br></pre></td></tr></table></figure><ul><li><code>ps</code>：查看程序的PID号(PID号用于唯一表示一个进程)。<ul><li><code>ps aux | grep badpro</code>(是将前一个命令的输出作为后一个命令的输入)。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> PID</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ol><li>Linux是一种多用户、多进程的操作系统。</li><li>在Linux的内核中维护着一张表，这张表记录了当前系统中运行的所有进程的各种信息。内核会自动完成对进程的控制和调度。</li><li>进程，是正在运行的程序。<h2 id="进程的属性"><a href="#进程的属性" class="headerlink" title="进程的属性"></a>进程的属性</h2></li></ol><ul><li><code>PID</code>:进程的ID号;<ul><li>Linux自己使用PID确定进程，也要求用户在管理进程时提供相应的PID号;</li><li>几乎所有进程管理工具都使用PID而不是进程名。</li></ul></li><li><code>PPID</code>:父进程的PID;<ul><li>Linux中，所有的进程都必须由另一个进程创建——除了在系统引导时，直接由内核主动创建并安装的几个进程。当一个进程被创建时，创建它的那个进程被称为<strong>父进程</strong>，而这个进程就叫做<strong>子进程</strong>。子进程应该是其父进程的克隆体。</li></ul></li><li><code>UID</code>:真实用户ID;<ul><li>只有进程的创建者和root用户才有权利对该进程进行操作,于是记录一个进程的创建者(也就是属主)就显得非常必要，进程的UID就是其创建者的用户ID号，用于标识进程的属主。</li></ul></li><li><code>EUID</code>:有效的用户ID<br>-Linux还为进程保存一个”有效用户ID号”，被称作EUID，用来确定进程对某些资源和文件的访问权限。绝大部分情况下，进程的UID和EUID是一致的——除了著名的<code>SETUID</code>程序。</li><li>允许用户修改密码的命令<code>passwd</code>命令就是一个典型的<code>SETUID</code>程序，其UID是当前执行这个命令的用户ID，而EUID是root用户的ID(也就是0)。</li><li>GID和EGID：真实和有效的组ID;<ul><li>EGID可能在确定访问权限方面还发挥了一定作用</li></ul></li><li>谦让度和优先级;<ul><li>进程的优先级决定了其受到CPU优待的程度，优先级高的进程可以更早地被处理，并获得更多的处理器时间;</li><li>决定进程何时被处理是内核的事情，不用用户插手，但用户可以设置进程的谦让度来影响内核的想法。<h2 id="监视进程-ps命令"><a href="#监视进程-ps命令" class="headerlink" title="监视进程: ps命令"></a>监视进程: ps命令</h2></li></ul></li><li><code>ps</code>是最常用的监视进程的命令。</li><li><code>ps aux</code>命令用于现实当前系统上运行的所有进程的信息。其中部分行代表的信息是</li></ul><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>USER</td><td>进程创建者的用户名</td></tr><tr><td>PID</td><td>进程的ID号</td></tr><tr><td>%CPU</td><td>进程占用CPU的百分比</td></tr><tr><td>%MEM</td><td>进程占用内存的百分比</td></tr><tr><td>VSZ</td><td>进程占用的虚拟内存大小</td></tr><tr><td>RSS</td><td>内存中页的数量(页是管理内存的单位，在PC上通常为4K)</td></tr><tr><td>TTY</td><td>进程所在终端的ID号</td></tr><tr><td>STAT</td><td>进程状态，常用字母代表含义如下：<br><code>R</code> 正在运行/可运行  <code>D</code> 睡眠中(不可被唤醒，通常是在等待I/O设备)<br> <code>S</code> 睡眠中（可以被唤醒） <code>T</code> 停止（由于受到信号或被跟踪）<br> <code>Z</code> 僵进程（已经结束而没有释放系统资源的进程）<br>————<br>常用的附加标志有：<br> <code>&lt;</code> 进程拥有比普通优先级高的优先级<br><code>N</code> 进程拥有比普通优先级低的优先级<br><code>L</code> 有些页面被锁在内存中<br><code>s</code> 会话的先导进程</td></tr><tr><td>START</td><td>进程启动时间</td></tr><tr><td>TIME</td><td>进程已经占用的CPU时间</td></tr><tr><td>COMMAND</td><td>命令和参数</td></tr></tbody></table><ul><li><code>ps</code>的另一组选项<code>lax</code>可以提供PPID和谦让度(NI)。<ul><li>另<code>ps lax</code>不显示进程属主的用户名，因此可以提供更快的运行速度(<code>ps aux</code>需要把UID转化为用户名之后才输出)。<h2 id="即时跟踪进程信息：top命令"><a href="#即时跟踪进程信息：top命令" class="headerlink" title="即时跟踪进程信息：top命令"></a>即时跟踪进程信息：top命令</h2><code>ps</code>命令可以一次性给出当前系统中进程信息的快照，但如果管理员需要实时监视进程运行情况，就可以运行<code>top</code>命令即时跟踪当前系统中进程的情况。<br><code>top</code>命令显示的信息会占满一页，且在默认情况下每10s更新一次。使用CPU最多的程序会排在前面，用<code>h</code>查看帮助，<code>q</code>推出。<h2 id="查看占用文件的命令：lsof"><a href="#查看占用文件的命令：lsof" class="headerlink" title="查看占用文件的命令：lsof"></a>查看占用文件的命令：lsof</h2></li></ul></li><li>不带任何参数的<code>lsof</code>命令会列出当前系统中所有打开文件的进程信息。</li><li>用文件名作为参数，可以查看占用该文件的进程。<h2 id="向进程发送信号：kill"><a href="#向进程发送信号：kill" class="headerlink" title="向进程发送信号：kill"></a>向进程发送信号：kill</h2><code>kill</code>命令用来向进程发送一个信号，这个信号是什么由用户指定。默认发送的是<code>TERM</code>信号，这个信号表示请求终止某项操作。</li><li><p>标准用法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [-signal] pid</span><br></pre></td></tr></table></figure></li><li><p>信号及其编号用<code>kill -l</code>查看(INT为’ctrl+c’)。</p></li></ul><table><thead><tr><th>信号编号</th><th>信号名</th><th>描 述</th><th>默认情况下执行的操作</th></tr></thead><tbody><tr><td>0</td><td>EXIT</td><td>程序退出时收到该信号</td><td>终止</td></tr><tr><td>1</td><td>HUP</td><td>挂起</td><td>终止</td></tr><tr><td>2</td><td>INT</td><td>中断</td><td>终止</td></tr><tr><td>3</td><td>QUIT</td><td>退出</td><td>终止</td></tr><tr><td>9</td><td>KILL</td><td>杀死</td><td>终止</td></tr><tr><td>11</td><td>SEGV</td><td>段错误</td><td>终止</td></tr><tr><td>15</td><td>TERM</td><td>软件终止</td><td>终止</td></tr></tbody></table><p><em>hints</em>:信号名前缀<code>SIG</code>是可以省略，即 <code>kill -SIGTERM pid</code>和<code>kill -TERM pid</code>都是一样的。</p><ul><li><strong>注意</strong>：<code>kill</code>命令<em>不一定</em>可以终止一个进程，既然<code>kill</code>命令向进程发送一个信号，这个信号就能被程序捕捉，程序可以“封锁”或者“忽略”捕捉到的信号。只有在信号没有被程序捕捉的情况下，系统才会执行默认操作。比如可以加入<code>trap &quot;&quot; TERM</code>来忽略TERM信号。</li><li><strong><code>KILL</code>信号永远不能被程序所捕捉</strong>，<code>KILL</code>信号可以在内核级别杀死进程。<code>kill -SIGTERM pid</code>或<code>kill -TERM pid</code>或<code>kill -9 pid</code>。<br>也有<code>KILL</code>信号都不能影响的进程，常常是由一些退化的I/O（输入/输出）虚假锁定造成的。此时，重新启动系统是唯一的解决办法。<h2 id="调整进程的谦让度：nice和renice"><a href="#调整进程的谦让度：nice和renice" class="headerlink" title="调整进程的谦让度：nice和renice"></a>调整进程的谦让度：nice和renice</h2></li><li><code>nice</code>命令可以在启动程序时设置其谦让度,调整的是“相对”谦让度值。<ul><li>用不带参数的<code>nice</code>的命令查看默认谦让度值，一般是0。</li></ul></li><li><code>renice</code>命令在程序运行时调整其谦让度值，调整的是“绝对”谦让度值。</li><li>高谦让度表示低优先级，低谦让度(尤其是负数)的程序会占用更多的CPU时间，拥有更高的优先级。</li><li>新进程一般将从其父进程那里继承谦让度。为保证低优先级的进程不会派生出高优先级的进程，允许进程的属主提高其谦让度（降低优先级），但不能降低谦让度。<strong>但是root用户可以任意设置进程的优先级</strong>。<h2 id="PROC文件系统"><a href="#PROC文件系统" class="headerlink" title="/PROC文件系统"></a>/PROC文件系统</h2></li><li><code>/proc</code>目录下存放了内核有关系统状态的各种有意义的信息。<ul><li>在系统运行时，内核会随时向这个目录写入数据。<code>ps</code>和<code>top</code>命令就是从此目录中读取数据的。</li><li>实际上，这是操作系统向用户提供的一条通往内核的通道，用户甚至可以通过向/PROC目录下的文件写入数据来修改操作系统参数。</li><li>内容说明：<ul><li>以数字命名的目录存放着对应进程的信息。/proc/1包含进程init的信息，由内核在系统启动时创建，是除了那个时候同时创建的几个内核进程之外所有进程的父进程。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><em>Linux从入门到精通 刘忆智 著</em></li></ul></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列7-用户与用户组管理</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%977-%E7%94%A8%E6%88%B7%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>用户的管理(增加、删除、修改和切换)</li><li>用户组的管理</li><li>用户和组的配置文件<code>/etc/shadow</code>、<code>/etc/passwd</code>、<code>/etc/group</code></li><li>记录用户历史操作命令<code>history</code><br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li><li>Linux作为一种多用户的操作系统(服务器系统)，允许多个用户同时登陆到系统上，并响应每个用户的请求;</li><li>系统管理员的非常重要的工作之一是管理用户，包括：<ul><li>添加和删除用户;</li><li>分配用户主目录;</li><li>限制用户权限。<h2 id="用户与用户组基础"><a href="#用户与用户组基础" class="headerlink" title="用户与用户组基础"></a>用户与用户组基础</h2></li></ul></li><li>Linux识别多用户的流程：<ul><li>用户提供用户和密码，经过验证后登录到系统;</li><li>Linux为每一个用户启动一个进程，然后由这个进程接受用户的各种请求;</li><li>建立用户时，需要限定其权限(root用户拥有所有权限<code>sudo -s</code>)，如不能修改配置文件，不能查看其他用户目录等;</li><li>被划分为一个用户组的用户默认拥有用户组权限。</li></ul></li></ul><h2 id="用户和组的添加useradd、groupadd"><a href="#用户和组的添加useradd、groupadd" class="headerlink" title="用户和组的添加useradd、groupadd"></a>用户和组的添加<code>useradd</code>、<code>groupadd</code></h2><ul><li><code>useradd</code>：创建新用户;<ul><li>默认情况下，不带<code>-m</code>参数的<code>useradd</code>命令不为新用户建立主目录，此时用户可以登录到系统Shell，但不能登录到图形界面;</li><li><code>-g</code>：参数用于指定用户所属的组，不带<code>-g</code>参数时默认为新用户创建同名用户组，然后将新用户归入该组;</li><li><code>-s</code>：指定用户登录后使用的Shell(目录)，否则默认使用<code>sh</code>;</li><li>创建流程:(1)先创建用户名<code>useradd username</code>;(2)创建密码<code>passwd username</code>。</li></ul></li><li><code>groupadd</code>：增加用户组，<code>groupadd groupname</code>。<h3 id="记录用户操作history"><a href="#记录用户操作history" class="headerlink" title="记录用户操作history"></a>记录用户操作<code>history</code></h3></li><li>Shell会记录用户的每一条命令。</li><li><code>history</code>：列出所有使用过的命令并加以编号;<ul><li><code>history</code>命令只在bash中适用;</li><li>历史命令记录被存在用户主目录下的<code>.bash_history</code>中，该文件默认可以存储1000条命令记录;</li><li><code>history &lt;num&gt;</code>:列出最近<num>次输入的命令;</num></li><li><code>history</code>列出当前用户的命令历史，查看其他用户命令应到其主目录的<code>.bash_history</code>查看。<h3 id="passwd和shadow文件"><a href="#passwd和shadow文件" class="headerlink" title="passwd和shadow文件"></a>passwd和shadow文件</h3></li></ul></li><li>Linux中做的一切基本配置最终都会反映到配置文件，包括用户管理。</li><li><code>/etc/passwd</code>:登记所有用户信息;</li><li><code>/etc/shadow</code>:保存用户的登录密码(加密);</li><li>直接修改配置文件也可以实现用户管理。<h2 id="删除用户userdel"><a href="#删除用户userdel" class="headerlink" title="删除用户userdel"></a>删除用户<code>userdel</code></h2></li><li><code>userdel</code>:用于删除用户帐号;<ul><li>默认情况下，不删除用户主目录;</li><li><code>-r</code>:删除用户帐号，同时删除用户主目录;<h2 id="管理用户帐号usermod"><a href="#管理用户帐号usermod" class="headerlink" title="管理用户帐号usermod"></a>管理用户帐号<code>usermod</code></h2></li></ul></li><li><code>usermod</code>常用选项及含义：</li></ul><table><thead><tr><th>选 项</th><th>含 义</th></tr></thead><tbody><tr><td><code>-d</code></td><td>修改用户主目录</td></tr><tr><td><code>-e</code></td><td>修改帐号的有效期限(MM/DD/YY)</td></tr><tr><td><code>-g</code></td><td>修改用户所属的组</td></tr><tr><td><code>-l</code></td><td>修改用户帐号名称</td></tr><tr><td><code>-s</code></td><td>修改用户登录后所使用的shell</td></tr></tbody></table><ul><li>同样可以通过修改配置文件<code>/etc/passwd</code>、<code>/etc/shadow</code>和<code>/etc/group</code>来修改用户信息。<h2 id="查看用户信息id"><a href="#查看用户信息id" class="headerlink" title="查看用户信息id"></a>查看用户信息<code>id</code></h2></li><li><code>id</code>：查看用户信息;<ul><li>以用户名作参数，查看用户的UID、GID及所属组;</li><li>不带参数，则显示当前登录用户的信息。<h2 id="用户间切换su"><a href="#用户间切换su" class="headerlink" title="用户间切换su"></a>用户间切换<code>su</code></h2></li></ul></li><li>ubuntu使用<code>sudo -s</code>或<code>/bin/su</code>(绝对路径更为安全)来获得root权限。</li><li><code>su username</code>：用于切换用户。<h2 id="受限的特权sudo"><a href="#受限的特权sudo" class="headerlink" title="受限的特权sudo"></a>受限的特权<code>sudo</code></h2></li><li>root权限是不可分隔的，<strong>其他用户</strong>要获取某个特权时采用<code>sudo</code>命令;</li><li>使用流程：<ul><li><code>sudo</code>会首先要求用户输入用户自己的口令;</li><li>用户在在一段时间内(5分钟)没有再次使用<code>sudo</code>，就必须再次输入口令。</li></ul></li><li><code>/etc/sudoers</code>指定用户可以执行的特权命令;<ul><li><code>root ALL=(ALL) ALL</code>指定root用户可以使用<code>sudo</code>在任何机器上(1st ALL)以任何用户身份(2nd ALL)执行任何命令(3rd)，无括号时以root身份执行;</li><li><code>%admin</code>:替代所有属于admin组的用户，Ubuntu安装时创建的用户自动加入<code>admin</code>组。</li></ul></li><li><code>sudoer</code>的每行包含下面内容：<ul><li>该权限适合的用户;</li><li>这一行配置在哪些主机上适用;</li><li>该用户可以运行的命令;</li><li>该命令以那个用户身份执行。</li></ul></li><li><code>sudo -u</code>可以以其他用户身份执行命令。</li><li><code>visudo</code>：修改sudoers文件时使用的命令。<h2 id="etc-passwd文件"><a href="#etc-passwd文件" class="headerlink" title="/etc/passwd文件"></a>/etc/passwd文件</h2></li><li>早期所有信息都在<code>/etc/passwd</code>中，后来出于安全考虑，加密口令转移到<code>/etc/shadow</code>。</li><li><code>/etc/passwd</code>中每一行代表一个用户，每一行由7个字段组成，使用冒号分隔;<ul><li>登录名;</li><li>口令占位符;</li><li>用户ID(UID);</li><li>默认组ID号(GID);</li><li>用户私人信息;</li><li>用户主目录;</li><li>登录shell。</li></ul></li><li>口令占位符代表算法加密，且口令放置在<code>/etc/shadow</code>中。</li><li>Linux上使用最广泛的算法是MD5，MD5加密后长度是一个固定值(34个字符)。加密过程中，MD5算法会随机加入称作”salt”的数据，使一个口令可以对应多个不同的加密后形式。</li><li>常用加密算法通过前缀识别;<ul><li>MD5算法以”$1$”开头;</li><li>Blowfish算法以“$2a$”开头。</li></ul></li><li>UID号：用于唯一标识系统中的用户。<ul><li>是一个32位无符号整数;</li><li>root用户的UID为0。</li><li>虚拟用户(bin/daemon)被分配到比较小的UID号，通常安排在<code>passwd</code>文件的开头;</li><li>真实用户的UID号一般从比较大的数开始，这样可以为虚拟用户提供足够的余地(本机从1000开始)。</li></ul></li><li>GID号：指定用户登录时默认所在的组;<ul><li>一个32位整数;</li><li>root组的GID号为0;</li><li>在<code>/etc/group</code>中定义。<h2 id="etc-shadow文件"><a href="#etc-shadow文件" class="headerlink" title="/etc/shadow文件"></a>/etc/shadow文件</h2></li></ul></li><li><code>/etc/shadow</code>存放加密后的用户口令。</li><li><code>/etc/shadow</code>文件的每一行代表一个用户，并以冒号分隔每一个字段，每个字段的含义如下;<ul><li>登录名;</li><li>加密后口令； </li><li>上次修改口令日期;</li><li>两次修改口令之间的天数(最少);</li><li>两次修改口令之间的天数(最多);</li><li>提前多少天提醒用户修改口令;</li><li>在口令过期多少天后禁用该用户;</li><li>帐号过期的日期(<code>usermod</code>);</li><li>保留，为空。</li><li><strong>绝对日期</strong>是从1970.1.1至今的天数。<h2 id="etc-group文件"><a href="#etc-group文件" class="headerlink" title="/etc/group文件"></a><code>/etc/group</code>文件</h2></li></ul></li><li><code>/etc/group</code>文件中保存系统所有组的名称，及每个组的成员列表;</li><li>文件每一行表示一个组，由4个冒号分隔的字段组成，含义分别是：<ul><li>组名;</li><li>组口令占位符(如果口令字段是一个<code>x</code>，表示还有一个<code>/etc/gshadow</code>文件用于存放口令);</li><li>GID号;</li><li>成员列表，逗号分开，不能有空格。</li></ul></li><li>应该保证GID的唯一性。</li><li>实际上用户所属组是<code>/etc/group</code>和<code>/etc/passwd</code>中相应组的并集。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><em>Linux从入门到精通 刘忆智 著</em></li></ul>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列6-磁盘管理</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%976-%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>Linux文件系统简介</li><li>文件系统挂载/卸载(含命令)</li><li>磁盘管理命令</li><li>打包和压缩工具<code>gzip`</code>tar`等</li><li>安装硬盘和分区的操作<br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li><li>目前的电脑几乎都是SATA硬盘，即串口硬盘，在Linux被标识为sd[a-z]，分区从1开始，Grub中被表示为hd[0-…]，分区从0开始标识。<h2 id="Linux文件系统简介"><a href="#Linux文件系统简介" class="headerlink" title="Linux文件系统简介"></a>Linux文件系统简介</h2></li><li><strong>文件系统</strong>：是一种对物理空间的组织方式，通常在<em>格式化硬盘时创建</em>。<ul><li>Windows下，有NTFS和FAT两种文件系统;</li><li>Linux下：<br>| 文件系统 | 简 介 |<br>| ext3fs(2nd Extended File System) | 过去很长一段时间是Linux的主流文件系统<br>目前已被ext4取代 |<br>| ext4fs(3rd Extended File System) | 是对ext3的扩展和改善，应灾难恢复的需求增加了<em>日志功能</em><br>ext4专门预留一块区域保存日志文件<br>当对文件进行写操作时，修改首先写入日志文件，再写入记录标志日志项的结束<br>完成以上操作时，才会对文件系统作实际的修改。<br>因此可以在系统崩溃后用日志恢复文件系统 |</li></ul></li><li><strong>Swap并不是一种文件系统</strong>。swap交换分区是一种特殊的硬盘空间，当实际内存不够用时，会将内存中暂时不用的数据放在交换空间中，从而为当前运行的程序腾出足够的内存空间。<em>Windows中这个概念叫“虚拟内存”</em>。<ul><li>操作系统的这种调度使程序可以使用的内存远大于物理内存;</li><li>硬盘空间价格比RAM低廉;</li><li>但频繁读取硬盘会显著降低系统运行速度。</li><li>swap分区大小主要取决于物理内存大小（理论上要大于物理内存大小），一般设置为2GB即可。<h2 id="文件系统挂载-含命令"><a href="#文件系统挂载-含命令" class="headerlink" title="文件系统挂载(含命令)"></a>文件系统挂载(含命令)</h2></li></ul></li><li><p>对于某些外接设备，还有当你想在Linux下查看Windows分区中的时候，需要手动挂载设备。我以挂载windows中分区为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l /dev/sda <span class="comment"># 查看所有分区，在此查找win的引导分区位置,显示为/dev/sda1</span></span><br><span class="line">sudo mkdir /mnt/win</span><br><span class="line">sudo mount /dev/sda1 /mnt/win</span><br><span class="line"><span class="built_in">cd</span> /mnt/win</span><br><span class="line">ls <span class="comment"># 就可以看到已经能访问win分区中的内容了</span></span><br><span class="line"><span class="built_in">cd</span> ~ <span class="comment"># 先退出目录才能进行卸载，否则提示设备忙并拒绝卸载</span></span><br><span class="line">sudo umount /mnt/win</span><br></pre></td></tr></table></figure></li><li><p>Linux中每个设备都被映射为一个特殊文件(Linux中一切都是文件)，称为“设备文件”，对设备的操作通过读写文件实现。</p></li><li>Linux把所有的设备文件都放在/dev目录下。</li><li>因此文件系统挂载可以这么理解：/dev下记录了所有存在的物理设备，但是只有挂载到Linux目录下，这些文件才能被访问。</li><li><code>mount</code>:文件系统挂载命令，常用格式<code>mount &lt;source&gt; &lt;directory&gt;</code>,<ul><li><code>mount -r</code>:以只读模式挂载文件系统;</li><li><code>mount -w</code>:以可读写模式挂载设备。</li></ul></li><li>系统启动时要挂载的文件系统信息在<code>/etc/fstab</code>文件中规定，依次包括这些项：<ul><li>用于挂载每个文件系统的UUID(Universally Unique Identifier,通用唯一标志符，一个128bits数字，用于唯一确定互联网上的一件东西)，此处用于指代设备名/分区;</li><li>挂载点; </li><li>文件系统类型;</li><li>各种挂载参数;</li><li>备份频度;</li><li>重启动过程中文件系统的检查顺序。</li></ul></li><li><code>umount</code>:卸载文件系统，Linux规定文件系统只有在<em>没被使用时才可以被卸载</em>。<ul><li><code>umount -r</code>：指导umount在无法卸载文件系统的情况下，采用只读方式重新载入。 </li></ul></li><li><code>df</code>:收集和整理当前已挂载文件系统的重要统计数据。<ul><li><code>df -t</code>:用于显示特定文件系统，如<code>df -t ext4</code>。</li></ul></li><li><code>fsck</code>:检查和修复文件系统。对于小的损坏可以很好地解决问题，可以快速执行检查并将日志回滚到上一次正常状态中，但是<strong>存在风险</strong>。<ul><li><code>fsck -p</code>：根据fstab文件确定检查哪些文件系统，按其中指定的顺序升序检查。<em>通常会在硬盘启动时自动执行</em>。</li></ul></li><li><code>mkfs</code>：在目标盘上建立文件系统(即格式化)。常用格式mkfs [-t <type>] [fs-options] <device>。<ul><li><code>mkfs -c</code>：用于检查制定设备上损坏的块，如<code>sudo mkfs -t ext4 -c /dev/sdb1</code></li><li>硬盘分区在格式化之前必须先卸载。</li></ul></device></type></li><li>Linux会将USB设备识别为第一个没有被硬盘占用的SCSI设备，因此可以从<code>/dev/sd[a-z][1-...]</code>挂载。<ul><li><code>lsusb</code>：可以列出当前内核已经发现的USB设备。<h2 id="打包和压缩工具"><a href="#打包和压缩工具" class="headerlink" title="打包和压缩工具"></a>打包和压缩工具</h2></li></ul></li><li><code>gzip</code>:Linux下使用最广泛的压缩/解压缩工具，gzip会给文件加上<code>gz</code>扩展名;<code>.tar.gz</code>是Linux世界最流行的压缩文件格式，即首先用tar打包，再用gzip压缩的文件格式。<strong>压缩后会删除原来的文件。</strong><ul><li><code>gzip filename.tar</code>就完成了对文件的压缩;</li><li><code>gzip -d</code>：压缩文件解压;</li><li><code>gzip -l</code>：查看压缩效果;</li><li><code>gzip -t</code>：测试压缩文件的完整性。</li><li><code>gunzip</code>:也是解压缩工具。</li></ul></li><li><code>bzip2</code>：以压缩速度为代价，提供比gzip更高的压缩率。<code>bzip2</code>的使用方法基本和<code>gzip</code>一致，压缩后文件带<code>.bz2</code>后缀。<ul><li><code>bzip2 -d</code>/<code>bunzip2</code>：用于解压缩文件;</li><li><code>bzip2 -tv</code>：检查文件完整性并返回信息。<br><br></li></ul></li><li><code>tar</code>：Linux中最著名的文件打包工具，读取多个文件和目录，并将它们打包成一个文件。<strong>并不删除原来的文件</strong>。<ul><li><code>tar -cvf &lt;target&gt; &lt;source&gt;</code>:<code>c</code>指导创建归档文件,<code>v</code>用于现实命令执行过程，<code>f</code>制定归档文件名，余下参数指定要打包的文件和目录;</li><li><code>tar -xvf</code>：<code>x</code>表示提取文件;</li><li><code>tar -xzvf</code>：<code>z</code>选项让tar自动调用gzip程序完成相关操作，先gzip解压缩，再用tar解包;</li><li><code>tar -czvf</code>：先tar打包，再gzip压缩;</li><li><code>-j</code>：此参数调用bzip2程序;</li><li>tar命令选项前的<code>-</code>可以省略。</li></ul></li><li><code>dd</code>：转化和复制文件。<ul><li><code>dd if=/dev/cdrom of=CD.iso</code>:if规定输入端，of指定输出端，将CD内容转化为镜像文件。<h2 id="安装硬盘和分区-进阶"><a href="#安装硬盘和分区-进阶" class="headerlink" title="安装硬盘和分区(进阶)"></a>安装硬盘和分区(进阶)</h2></li></ul></li></ul><ol><li><code>fdisk</code>：Linux用于建立/查看分区表的工具，请不要在当前硬盘上实验导致删除整个系统;<ul><li><code>fdisk -l</code>查看分区表;</li><li><code>fdisk /dev/sdb</code>：在指定硬盘上建立分区;</li><li>此交互式工具中常用的命令如下：</li></ul></li></ol><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>new/n</td><td>创建新分区</td></tr><tr><td>print/p</td><td>显示当前分区设置</td></tr><tr><td>type/t</td><td>设置分区类型(建立swap时使用)</td></tr><tr><td>write/w</td><td>把分区表写入硬盘</td></tr></tbody></table><ul><li><code>fdisk</code>在分区完全确定之后，用<code>write</code>才会将设置写入分区表中，否则还可以<code>delete</code>删除分区。<ol><li>分区表建立完成后用<code>mkfs</code>在各分区上建立文件系统。</li><li>用<code>fsck</code>检查文件系统。</li><li>将硬盘挂载到目录下，用<code>df</code>测试分区。</li><li>对交换空间分区执行<code>mkswp &lt;par&gt;</code>和<code>swapon &lt;par&gt;</code>分别进行初始化和激活。</li></ol></li><li><code>swapon -s</code>:可以查看当前交换空间分区的信息。、<ol><li>配置/etc/fstab文件，加入新分区，使开机自动加载文件系统。</li><li>如果文件系统出问题，系统将不能正常启动，而会引导进入救援模式，依次进行下述手段：</li></ol></li><li><code>fsck</code>检查并修复受损文件系统;</li><li>如果问题仍在，<code>mkfs</code>重建文件系统;</li><li>最后尝试<code>fdisk</code>重建分区表。</li><li>但是，总是可以通过注释掉fstab中对应行解决新建分区后不能正常启动的问题。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><em>Linux从入门到精通 刘忆智 著</em></li></ul>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列5-软件包管理</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%975-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>什么是软件包</li><li>介绍<code>dpkg</code>软件包管理工具</li><li>介绍<code>apt</code>高级软件包管理工具和相关命令</li><li>从源码编译安装的基本流程<br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2></the></li><li>软件包是将应用程序、配置文件和管理数据打包的产物，常用的软件包格式有两种：<ul><li>rpm(Red Hat Package Manager)：适用SUSE、Red Hat、Fedora等;</li><li>deb：适合Debian和Ubuntu。</li></ul></li><li>使用软件包系统安装软件同样需要考虑依赖性问题，只有依赖的所有库和支持都已经正确安装好了，软件才能被正确安装。</li><li>高级软件包管理工具可以简化软件包的安装过程，常见的通用版本有<strong>APT</strong>和<strong>yum</strong>(其中yum只能用于RPM)。职责：<ul><li>简化定位和下载软件包的过程; </li><li>自动进行系统更新和升级;</li><li>方便管理软件包的依赖关系。</li></ul></li><li><code>dpkg</code>:管理.deb软件包。<code>dpkg --force</code>忽略依赖问题强制安装，一般应避免这种做法。<ul><li><code>dpkg -i</code>：安装且卸载旧版本;</li><li><code>dpkg -l</code>：列出符合模式的安装包;</li><li><code>dpkg -r</code>：删除，可能包含其他软件依赖的库和数据文件导致严重后果;</li><li><code>dpkg -S</code>：搜索所安装的文件向系统复制了哪些内容;</li></ul></li><li>rpm和dpkg软件管理包的出现大大减少了安装软件的工作量，但是不能有效解决依赖性问题。<h2 id="高级软件包工具：APT"><a href="#高级软件包工具：APT" class="headerlink" title="高级软件包工具：APT"></a>高级软件包工具：APT</h2></li><li>APT,Advanced Package Tool，高级软件包工具。适合rpm格式和deb格式。</li><li>以前APT工具最常用命令：<ul><li><code>apt-get</code>:用于执行和软件包安装有关的所有操作;</li><li><code>apt-cache</code>:主要用于查找软件包的相关信息。</li><li><code>apt</code>：用于软件包管理和查询等，<strong>可以执行上述两条命令的所有功能</strong>,但更适合交互。用<code>apt -h</code>查看<code>apt</code>的简要用法。</li></ul></li><li>安装软件：<ul><li>系统第一次启动时，需要运行<code>apt update</code>更新当前<code>apt</code>缓存中的软件包信息;</li><li>建议每一次安装前都运行<code>apt update</code>以确保获得的软件包是最新的;</li><li>[optional]用<code>apt search</code>或<code>apt list</code>搜索需要的软件包名字，用<code>apt depends</code>查看需要依赖的包;</li><li><code>sudo apt install</code>安装软件包，需要root的原因是安装过程需要将文件复制到某些系统文件夹中。</li></ul></li><li><em>安装源</em>是所有apt用于下载软件的地址，被放在/etc/apt/sources.list中，其中内容包括:<ul><li>deb和deb-src：表示软件包的类型，src表示源码。如果是RPM的软件包，应是rpm和rpm-src;</li><li>URL:HTTP、FTP服务器或CD-ROM的地址，表示从哪获得软件包;</li><li>其他：表示软件包的发行版本和分类，用于帮助<code>apt</code>遍历软件库。</li></ul></li><li>暂时禁止一个安装源时，应考虑先注释掉。<h2 id="进阶：从源代码编译软件"><a href="#进阶：从源代码编译软件" class="headerlink" title="进阶：从源代码编译软件"></a>进阶：从源代码编译软件</h2></li><li>某些情况下，编译源码安装软件是唯一的选择：<ul><li>某些厂商没有提供为此发行版提供二进制软件包;</li><li>软件的源代码经过修过，必须重新编译;</li><li>从源代码编译软件通常能让编译者获得更多控制，例如软件安装位置，开启和禁用功能。<br>编译流程：</li></ul><ol><li>源代码安装软件前的配置：<ul><li>首先要仔细阅读安装文档如README或INSTALL;</li><li>Linux上所有的软件都使用<code>configure</code>这个脚本来配置以源代码形式发布的软件;</li><li>configure依据设置参数生成相应的makefile，指导make命令编译源代码;</li><li>一般configure脚本提供一个–prefix选项，用于指定软件安装位置，如<code>./configure --prefix=</code>;</li><li>将软件安装在/usr/local下是一个好习惯，可以同安装在/usr下的系统工具区分开来。</li></ul></li><li>执行<code>make</code>，make是一个高级编译工具，依据makefile文件中的规则调用合适的编译器编译源码;</li><li><code>make install</code>安装软件。<ul><li>出错时应多参考论坛。</li></ul></li></ol></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><em>Linux从入门到精通 刘忆智 著</em></p>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列4-文件目录管理</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%974-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>Linux的文件系统架构</li><li>文件和目录管理的基本操作</li><li>更改文件和目录权限</li><li>文件类型</li><li>重定向和管道<br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="Linux文件系统架构"><a href="#Linux文件系统架构" class="headerlink" title="Linux文件系统架构"></a>Linux文件系统架构</h2></the></li><li>Linux没有盘符，有的是目录(挂载点)。</li><li>Linux标识目录使用的是正斜杠<code>/</code>。</li><li>Linux需要先建立一个根’/‘文件系统（即“分区”），并且在这个文件系统中建立一系列空目录，然后将其他硬盘分区中的文件系统（如果有的话）挂载到这些目录中，比如在安装系统时，我们先划分一个单独的分区，再将其挂载到/home目录下。</li><li>理论上可以为根目录下的每一个目录都划分一个单独的硬盘分区，这样根分区就可以设置的很小(因为子目录都“映射”到了其他分区上，不占据根分区的容量)。</li><li>如果子目录没有划分自己的分区，那么其文件内容就自动存储在<code>/</code>根分区下。</li><li>Linux系统主要目录及内容表格</li></ul><table><thead><tr><th>目 录</th><th>内 容</th></tr></thead><tbody><tr><td><code>/bin</code></td><td>构建最小系统所需要的命令（最常用的命令）</td></tr><tr><td><code>/boot</code></td><td>内核与启动文件</td></tr><tr><td><code>/dev</code></td><td>各种设备文件</td></tr><tr><td><code>/etc</code></td><td>系统软件的启动和配置文件</td></tr><tr><td><code>/home</code></td><td>用户的主目录</td></tr><tr><td><code>/lib</code></td><td>C编译器的库</td></tr><tr><td><code>/media</code></td><td>可移动介质的安装点</td></tr><tr><td><code>/opt</code></td><td>可选的应用程序包</td></tr><tr><td><code>/proc</code></td><td>进程的映像</td></tr><tr><td><code>/root</code></td><td>超级用户root的主目录</td></tr><tr><td><code>/sbin</code></td><td>和系统操作有关的命令</td></tr><tr><td><code>/tmp</code></td><td>临时文件存放点</td></tr><tr><td><code>/usr</code></td><td>非文件的程序和命令</td></tr><tr><td><code>/var</code></td><td>系统专用的数据和配置文件</td></tr></tbody></table><h2 id="工作组共享文件"><a href="#工作组共享文件" class="headerlink" title="工作组共享文件"></a>工作组共享文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd workgroup</span><br><span class="line">sudo useradd -G workgroup lucy</span><br><span class="line">sudo passwd lucy</span><br><span class="line">sudo chgrp workgroup work/ <span class="comment">#将组拥有权交给workgroup</span></span><br><span class="line">sudo chmod g+rwx work/ <span class="comment"># 用户组对目录有读写和执行权限</span></span><br><span class="line">sudo chmod o-rwx work/ <span class="comment"># 其他用户对目录无上述权限</span></span><br><span class="line">sudo chown lewis work/ <span class="comment"># 将目录所有权移交给lewis</span></span><br><span class="line">su lewis <span class="comment"># 切换用户ID</span></span><br></pre></td></tr></table></figure><h2 id="文件和目录管理"><a href="#文件和目录管理" class="headerlink" title="文件和目录管理"></a>文件和目录管理</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><code>mkdir</code>:一次性建立一个或几个目录。<ul><li><code>mkdir -p dirname</code>:如果父目录不存在会自动创建。</li></ul></li><li><code>touch</code>：建立新的空文件。</li><li><code>mv</code>:重命名是移动同时修改名字（可选择不修改），一般同名时直接覆盖。<ul><li><code>mv -i</code>:如果同名，询问;</li><li><code>mv -b</code>:如果同名，在文件名后面添加<code>~</code>符号。</li></ul></li><li><code>cp</code>:复制文件和目录。<ul><li><code>cp -i</code>:覆盖前询问;</li><li><code>cp -b</code>：同名文件重命名;</li><li><code>cp -r</code>：递归式复制（目录及子目录）。</li></ul></li><li><code>rm</code>:永久删除文件和目录。<ul><li><code>rm -i</code>:删除前询问;</li><li><code>rm -f</code>：强制删除，即对所有询问自动yes;</li><li><code>rm -r</code>：递归删除所有目录。<h3 id="更改文件和目录权限"><a href="#更改文件和目录权限" class="headerlink" title="更改文件和目录权限"></a>更改文件和目录权限</h3></li></ul></li><li><code>chmod</code>：使用格式[ugoa…][[-+=][perms…]…]。<ol><li>Linux为3种人准备了权限——文件所有者(u)，文件所属组(g)和其他人(o)，其他人指非前两者也非root用户(因为root拥有完整权限)，其他人总是享有最低权限。</li><li>所有人(a)指代上述所有3个用户组;</li><li><code>+</code>表示增加权限，<code>-</code>表示删除权限，<code>=</code>表直接设置权限;</li><li>一般来说，文件创建者自动成为所有者，但是所有权可以转让，手续由root用户实施。</li><li>权限分为3种：读取(r)，写入(w)和执行(x)。</li></ol><ul><li>对于<strong>文件</strong>，能否删除和重命名一个文件是由其父目录的权限设置所控制的，要让一个文件可执行，必须设置其执行权限;可执行文件分为两类:<ul><li>(1)可由CPU执行的二进制代码;</li><li>(2)shell脚本程序;</li></ul></li><li>对于<strong>目录</strong>，<ul><li>(1)执行权限:控制用户能否进入该目录;</li><li>(2)读取权限：负责确定能否列出该目录的内容;</li><li>(3)写入权限：在目录中创建、删除和重命名文件。</li><li>所以<strong>目录和文件的执行权限是最基本的权限</strong>。</li></ul></li></ul><ol><li><strong>权限的八进制表示</strong>：每组权限rwx用3位二进制数表示(有为1无为0)，即可以用1位八进制数表示。所以完整的9位权限位就可以用3个八进制数表示，如<code>chmod 711 prog</code>就可以规定各用户组权限。</li></ol></li><li><code>chown</code>:格式chown [OPTION]… [OWNER][:[GROUP]] FILE将file的[属主]和[属组]改变为owner和group。<ul><li><code>chown -R</code>:递归式改变所有子目录所有者和组;</li><li><code>chgrp</code>:只改变所属组。</li></ul></li><li><code>ls -l</code>和<code>ls -ld</code>:分别查看文件和目录的属性，属性项依次为:文件类型-3组权限位+链接数目+文件属主+文件属组+文件大小+最后修改日期+最后修改时间+完整路径。 <h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3></li><li>Linux中一切都表示为文件的形式（包括进程、硬件设备、通信通道等），文件类型(ls -l的显示)包括：</li></ul><table><thead><tr><th>文件类型</th><th>符号</th></tr></thead><tbody><tr><td>普通文件</td><td>-</td></tr><tr><td>目录</td><td>d</td></tr><tr><td>字符设备(顺序访问设备)文件</td><td>c</td></tr><tr><td>块设备(随机访问设备)文件</td><td>b</td></tr><tr><td>本地域套接口(进程间通信)</td><td>s</td></tr><tr><td>有名管道(进程间通信)</td><td>p</td></tr><tr><td>符号链接(快捷方式)</td><td>l</td></tr></tbody></table><ul><li>链接分为两种：<ul><li>(1)软连接/符号链接:用<code>ln -s TARGET LINK_NAME</code>创建，通过名称进行引用，删除链接也不影响原文件;</li><li>(2)硬连接：用<code>ln</code>直接创建，直接引用，对其中一者的修改会影响另一者。已<strong>很少使用</strong>。<h3 id="重定向和管道"><a href="#重定向和管道" class="headerlink" title="重定向和管道"></a>重定向和管道</h3></li></ul></li><li>输入输出重定向：改变程序获取输入或产生输出的位置。标准输出指向屏幕，标准输入指向键盘。<ul><li>输入重定向：<code>&lt;</code>;</li><li>两种常用输出重定向：<ul><li><code>&gt;</code>:相当于覆盖。</li><li><code>&gt;&gt;</code>:相当于添加。</li></ul></li></ul></li><li>管道：<code>|</code>将一条命令的输出连接到另一条命令的输入，举例：<ul><li><code>ls | grep ay</code>:ls的输出送给grep做最后一个输入。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><em>Linux从入门到精通 刘忆智 著</em></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列3-shell基本命令</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%973-shell%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>对Shell的介绍(和命令行的关系)</li><li>常用Shell命令</li><li>/etc存放大部分系统和程序的配置文件<br>如要下载笔记请到<a href="https://github.com/yucicheung/LearningNotes" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h2></the></li><li><strong>命令行</strong>指供用户输入命令的界面，其本身只是接受输入，然后把命令行传递给<strong>命令解释器</strong>(即<em>shell</em>)。</li><li><strong>shell</strong>本质上是一个程序，在用户和os之间提供了一个面向行的可交互接口。shell将用户输入的命令转换成指令代码发送给操作系统。</li><li>Linux环境下BASH (Bourne Again Shell) shell是默认安装和使用的shell。</li><li>图形界面下的终端实际上是一个终端模拟器。</li><li>Linux默认有7个控制台，可以通过按快捷键Ctrl+alt+F1~F7进入。默认情况下，前6个是命令行控制台，第7个则留给X服务器。</li><li>BASH中，”$”是命令行提示符，表示可以输入命令;如果以root身份运行，提示符为”#”。(命令和文件名都区分大小写)。</li><li>不带参数的<code>cd</code>命令表示进入主目录。</li><li>/etc目录下存放了系统和绝大部分应用软件的配置文件。Linux使用纯文本文件来配置文件。</li><li>/etc/fstab文件定义了个硬盘分区所挂载到的目录路径。<h2 id="命令行使用-含常用命令"><a href="#命令行使用-含常用命令" class="headerlink" title="命令行使用(含常用命令)"></a>命令行使用(含常用命令)</h2></li><li>命令行/文件名补全：输入开头，按tab键，shell会自动将文件名补全。如果文件名/命令不止一个，连按tab键两次列出所有符合的文件名。<ul><li><em>hints</em>：系统命令本质上就是一些<strong>可执行文件</strong>，在<code>/usr/bin/</code>目录下找到。</li></ul></li><li><strong>通配符</strong>(不同于正则表达式)：<ul><li><code>*</code>:用于匹配文件名中任意长度的字符串，如<code>ls *.md</code>;</li><li><code>?</code>:只匹配一个字符，如<code>ls text?</code>;</li><li><code>[]</code>:用于匹配出现在方括号内的字符，如<code>ls text[1A]</code>;</li><li><code>-</code>:指定字符集范围（上下界包含）。与<code>[]</code>搭配使用，如<code>ls text[1-9]</code>。</li></ul></li><li><code>pwd</code>: print working directory，打印当前目录。</li><li><code>ls</code> : 列出文件。<ul><li><code>ls</code>:目录为蓝色；普通文件为白色;可执行文件为草绿色;连接文件为淡蓝色。</li><li><code>ls -F</code>:在无法显示颜色的终端上使用，目录后加/，在可执行文件后加*，在链接文件加上@。</li><li><code>ls -a</code>：显示所有文件，包括<code>.</code>开头的隐含文件。</li><li><code>ls -l</code>:用于查看文件的各种属性(包括最后一次被修改的时间);</li><li><code>ls -ld</code>:查看目录的各种属性。</li></ul></li><li><code>cat</code>：一次性显示文件内容，后可跟多个文件名做参数，也可使用通配符。<ul><li><code>cat -n 文件名</code>：显示行号。</li></ul></li><li><code>more</code>：逐页显示文件内容，空格翻页，Enter滚动一行。</li><li><code>less</code>：功能更强大。比more更像是一个文本编辑器(有检索、高亮操作)。</li><li><code>head</code>和<code>tail</code>：查看文件的头和尾，可接多个文件。用<code>-n</code>指定显示的行数。如<code>head -n 2 shell.md</code>。</li><li><code>grep</code>:查找文件中的文本内容，用法<code>grep [OPTIONS] PATTERN [FILE...]</code>。其中的PATTERN是”基础正则表达式”。<code>egrep</code>使用扩展的正则表达式。</li><li><code>find</code>：find会深入到指定路径(绝对路径)的每一个子目录中去查找文件，<code>-name</code>指定文件名（可以使用通配符），如<code>find /usr/bin/ -name zip</code>。</li><li><code>locate</code>:更快速地定位文件。通过搜索文件名数据库来确定文件的位置（<code>locate</code>命令会自动建立整个文件名数据库）。</li><li><code>&amp;</code>：<code>firefox</code>执行时，当前终端会被挂起。如果要在后台运行，后面加上<code>&amp;</code>。</li><li><code>whereis</code>：用于查找程序文件。提供该文件的二进制可执行文件、源代码文件和使用手册页存放的位置。<strong>whereis</strong>搜索的子目录是固定的，包括<code>/usr/bin</code>、<code>usr/sbin</code>和<code>/usr/share/man</code>。</li><li><code>who</code>:查看当前系统中有哪些人登录，以及工作在哪个控制台上。</li><li><code>whoami</code>:查看当前以什么身份登陆。</li><li><code>uname</code>:显示当前系统的版本信息。<code>uname -a</code>给出所有有用信息，<code>uname -r</code>给出内核信息。</li><li><code>man</code>:显示程序使用手册（实际调用了less程序显示）。</li><li><code>whatis</code>:一句话说明一个程序大概可以做什么。</li><li><code>apropos</code>:查找简介中含有关键词的命令，输出。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><em>Linux从入门到精通 刘忆智 著</em></li></ul>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列2-基本配置</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%972-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>关于超级用户root的说明</li><li>Grub的介绍和配置</li><li>X系统的介绍和组成<br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="关于超级用户root"><a href="#关于超级用户root" class="headerlink" title="关于超级用户root"></a>关于超级用户root</h2><ul><li>所有的系统设置都需要root用户来完成，即超级用户，也叫做根用户。<ul><li>权限：是整个系统中拥有最高权限的用户，root用户可以做任何事情。root可以访问、修改、删除系统中的任何文件和目录;</li><li>Linux系统上的每个文件和目录都属于某个特定的用户(在多人协作的服务器上)，没有得到许可，其他用户就不能访问，但是root用户可以访问所有用户的文件;</li><li>用户可以执行不带参数的<code>su</code>命令将自己提升为root权限（当然需要提供root口令）;而<code>sudo</code> 可以临时使用root身份运行程序，并在执行完毕后返回至普通用户状态;</li><li>对绝大多数Linux发行版，安装最后一步会设置root和普通用户。而对于Debian和Ubuntu系统，只有一个普通用户+sudo来执行root权限。但是，sudo是通过读取<code>etc/sudoers</code>来确定什么用户可以在什么机器上执行什么命令;</li><li><code>sudo -s</code>可以将自己提升为root用户，相当于<code>su</code>命令，用<code>exit</code>退出。<h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2></li></ul></li><li>图形化管理界面只在系统正常时可以使用，命令行往往更可靠和灵活。<h2 id="进阶：配置Grub"><a href="#进阶：配置Grub" class="headerlink" title="进阶：配置Grub"></a>进阶：配置Grub</h2></li><li>Grub(多重引导程序)启动时通常从<code>/boot/grub/grub.cfg</code>读取引导配置，并且严格地依此行事。查看该文件，开头会提示<em>不要编辑该文件</em>，因为该文件是以<code>/etc/default/grub</code>作为配置自动生成的。<ul><li>但是<code>/boot/grub/grub.cfg</code>并不是不可以更改的，也可以直接移动引导项的代码来改动引导项(如windows)。</li></ul></li><li><code>/etc/default/grub</code>(修改后需执行’update-grub’生效)中的参数：<ul><li>GRUB_DEFAULT:引导项列表的<em>默认选择项序号</em>(从0开始);</li><li>GRUB_TIMEOUT:引导项列表自动选择超过时间(超过则默认选中);</li></ul></li><li>还可以在Grub启动画面出现时按下C键可以进入Grub的命令行模式。</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>help</td><td>显示帮助信息</td></tr><tr><td>reboot</td><td>重新引导系统</td></tr><tr><td>root</td><td>指定根分区</td></tr><tr><td>kernel</td><td>指定内核所在位置</td></tr><tr><td>find</td><td>在所有可以安装的分区上寻找一个文件</td></tr><tr><td>boot</td><td>依照配置引导系统</td></tr></tbody></table><h2 id="桌面"><a href="#桌面" class="headerlink" title="桌面"></a>桌面</h2><ul><li>Linux不是一种基于图形环境的操作系统，在内核眼里，图形环境只是一个普通的应用程序。</li><li>X窗口系统(X Window System)是Linux图形用户环境的基础。如今绝大多数Linux使用的是由X.org基金会维护的X.Org。</li><li>X系统基于一种独特的服务器/客户机架构：<ul><li>意味着一台主机上的X应用程序可以在另一台主机的屏幕上显示出来，X服务器接受来自多个应用程序请求，然后在本地显示。</li></ul></li><li>X窗口系统的基本组成：<ul><li><strong>X服务器</strong>:<ul><li>X服务器用于实际控制输入设备(如鼠标和键盘)和位图式输出设备(如显示器)，X服务器定义了给X客户机使用这些设备的抽象接口，X服务器没有定义高级实体的编程接口(语法上还是比较低级);</li><li>X服务器要做到最大程度上的与平台无关，用户可以选择窗口管理器和widget库来定制自己的桌面，而不需要改变底层配置。</li></ul></li><li><strong>X客户端程序</strong>:<ul><li>需要向X服务器请求服务的程序就是X客户端程序;</li><li>它们运行时需要把自己的长相描述给X服务器，由X服务器负责在显示器上绘制这些应用程序的界面。</li></ul></li><li><strong>窗口管理器(Window Manager)</strong>:<ul><li>窗口管理器负责控制应用程序窗口的各种行为(如缩放等);</li><li>是一种特殊的X客户端程序。</li></ul></li><li><strong>显示管理器(Display Manager)</strong>:<ul><li>显示管理器提供了一个登录界面，用于验证用户身份，让用户登录到系统;</li><li>图形界面的一切(除了它自己)都是由这个显示管理器启动的，包括X服务器;</li><li>从命令行启动X服务器<code>startx</code>。</li></ul></li><li><strong>widget库</strong>:<ul><li>定义了一套图形用户界面的编程接口;</li><li>通过调用widget库来实现具体的用户界面;</li><li>wiidget库会自动把高级语言翻译成X服务器可以理解的语言。</li></ul></li><li><strong>桌面环境</strong>:<ul><li>桌面环境是把各种与X有关的东西(除了X服务器);</li><li>处理图形输出的始终是X服务器。</li></ul></li></ul></li><li>X系统的启动过程：<ul><li>X系统的启动过程是由显示管理器(Display Manager)完成的，显示管理器启动后依次完成以下工作：<ul><li>启动X服务器;</li><li>提供一个界面友好的屏幕，等待和验证用户身份;</li><li>执行用户的<strong>引导脚本</strong>，该脚本用于建立用户的桌面环境。<ul><li>桌面环境的引导脚本是一段用Linux命令组成的脚本程序，叫Xsession;    </li><li>Xsession通过启动窗口管理器、任务栏，设定应用的默认值、安装标准键绑定来启动整个桌面环境;</li><li>Xsession会一直运行，直到用户退出(也Xsession运行结束时，用户就退出了);</li><li>窗口管理器是Xsession启动的唯一前台程序，如果没有这个前台程序，用户会在登录后又退出系统。</li></ul></li></ul></li></ul></li><li>KDE：<ul><li>KDE是基于C++编写的，基于Qt库;</li><li>KDE编写的程序总是带着一个字母K。</li></ul></li><li>Gnome：<ul><li>Gnome使用C语言写成，基于GTK+widget库;</li><li>Gnome程序大多带着一个字母G。</li></ul></li><li><code>/etc/X11/xorg.conf</code>：X服务器的配置文件;<ul><li>如果显卡出现问题，可以通过修改xorg.conf禁用已有的显卡驱动程序。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><em>Linux从入门到精通 刘忆智 著</em></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Grub </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系列1-概述</title>
      <link href="/2018/04/09/Linux%E7%B3%BB%E5%88%971-%E6%A6%82%E8%BF%B0/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>Linux起源和发行版本介绍</li><li>GNU和GPL概念介绍</li><li>硬盘和分区描述</li><li>修复受损Grub<br>如要下载笔记和代码请到<a href="https://github.com/yucicheung/LearningNotes/tree/master/Linux" target="_blank" rel="noopener">我的github</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="Linux和Unix"><a href="#Linux和Unix" class="headerlink" title="Linux和Unix"></a>Linux和Unix</h2><ul><li>Linux是对Unix的重新实现。</li><li>Linux开发人员最初是借鉴了UNIX的技术和用户界面，并且融入了很多独创的技术改进，从这方面可以说Linux是UNIX的一个变体。但是从开发形式(社区支持)和最终产生的源代码来看，Linux不属于BSD和AT&amp;T风格中的任一种，因此严格说来，Linux是有别于UNIX的操作系统。</li><li>Linux实际上<strong>只定义一个操作系统内核</strong>，以同一个基础开始，却衍生了不同的发行版本。以下表格列出著名的Linux发行版本(按<strong>源版本</strong>和衍生版本划分)</li></ul><table><thead><tr><th>发行版本</th><th>官方网站</th><th>说 明</th></tr></thead><tbody><tr><td><strong>Red Hat Enterprise</strong></td><td><a href="http://www.redhat.com" target="_blank" rel="noopener">www.redhat.com</a></td><td>Red Hat公司的企业级商业化发行版本</td></tr><tr><td>Fedora</td><td>fedoraproject.org</td><td>Red Hat公司赞助的社区项目免费发行版本</td></tr><tr><td>CentOS</td><td><a href="http://www.centos.org" target="_blank" rel="noopener">www.centos.org</a></td><td>模仿Red Hat Enterprise Linux的非商业发行版本</td></tr><tr><td><strong>Debian</strong></td><td><a href="http://www.debian.org" target="_blank" rel="noopener">www.debian.org</a></td><td>免费的非商业发行版本</td></tr><tr><td>Ubuntu</td><td><a href="http://www.ubuntu.com" target="_blank" rel="noopener">www.ubuntu.com</a></td><td>类似Debian的免费发行版本</td></tr><tr><td><strong>SUSE Linux Enterprise</strong></td><td><a href="http://www.suse.com/linux" target="_blank" rel="noopener">www.suse.com/linux</a></td><td>Novell公司的企业级商业化Linux发行版本</td></tr><tr><td>openSUSE</td><td><a href="http://www.opensuse.org" target="_blank" rel="noopener">www.opensuse.org</a></td><td>SUSE Linux的免费发行版本</td></tr></tbody></table><h2 id="GNU-amp-GPL"><a href="#GNU-amp-GPL" class="headerlink" title="GNU&amp;GPL"></a>GNU&amp;GPL</h2><ul><li><code>GNU</code>(GNU’s not UNIX)是使软件自由的计划;</li><li>它的开源协议是<code>GPL</code>(GNU Public License)，是包括Linux在内的一批开源软件遵循的许可证协议。<h2 id="Linux对硬盘及分区的表述"><a href="#Linux对硬盘及分区的表述" class="headerlink" title="Linux对硬盘及分区的表述"></a>Linux对硬盘及分区的表述</h2></li><li>硬盘一般分为IDE硬盘、SCSI硬盘和SATA硬盘<ul><li>Linux中，IDE的接口被称为hd，SCSI和SATA接口的设备则被称为sd。第1块硬盘称为sda,第2块称为sdb，以此类推。</li><li>Linux规定，<strong>一块硬盘上只能存在4块主分区</strong>，分别命名为sda1、sda2、sda3、sda4。<strong>逻辑分区则从5开始标识</strong>，每多一个逻辑分区，就在末尾的分区号加1。逻辑分区没有数量限制。</li></ul></li><li>一般来说，每个系统都需要一个主分区来<strong>引导</strong>。这个分区中存放着<strong>引导</strong>整个系统所必需的程序和参数。<ul><li>操作系统可以按照光在主分区也可以安装在逻辑分区，但<strong>引导程序必须安装在主分区内</strong>。</li></ul></li><li><strong>安装提示</strong>:“安装类型”界面允许用户进行分区，创建两个分区就可以，一个主分区挂载点为’/‘(‘/boot’等挂载点会自动安装在其中)，另一个交换空间(相当于虚拟内存，用于缓冲数据)。<h2 id="进阶：修复受损的Grub"><a href="#进阶：修复受损的Grub" class="headerlink" title="进阶：修复受损的Grub"></a>进阶：修复受损的Grub</h2></li><li>Linux默认使用的默认操作系统引导加载器Grub，可以引导包括Linux、Windows、FreeBSD等多种操作系统。</li><li>Linux安装程序会在一切准备稳妥之后安装Grub，并加入对硬盘中原有操作系统的支持。这一切都是自动完成的。但是后安装Windows的话，win的引导程序却会自动将Grub覆盖。导致Linux无法启动。</li><li>万一Grub失效，需要用修复盘（即安装盘）以LiveCD模式修复，即“Try Ubuntu without installing”以命令行重新安装Grub。依次用以下命令安装Grub:</li></ul><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>grub</td><td>启动光盘上的grub程序</td></tr><tr><td>find /boot/grub/stage1</td><td>查找硬盘上的Linux系统将/boot目录存放在哪个硬盘分区中，grub安装时需要读取这个目录中的相关配置文件</td></tr><tr><td>root (hdx,y)</td><td>指示Linux内核文件所在的硬盘分区（/boot所在分区），<br>将这里的(hdx,y)替换为上一行中查找到的那个分区。<br>注意括号中不能存在空格。</td></tr><tr><td>setup (hd0)</td><td>在地一块硬盘上安装引导程序Grub</td></tr><tr><td>quit</td><td>退出Grub程序</td></tr></tbody></table><p><strong>提示</strong>:Grub对磁盘分区的表示方式和Linux有所不同。Grub将所有硬盘都表示为(hd#)的形式，<code>#</code>从0开始编号。对任一块硬盘，(hd#,0)~(hd#,3)依次表示它的主分区，随后的(hd#,4)….则是逻辑分区。(sd[a-z]从1开始编号)</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><em>Linux从入门到精通 刘忆智 著</em></p>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dijkstras算法和实现(python)</title>
      <link href="/2018/03/24/Dijkstras%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>Dijkstras算法的基本原理和求解步骤</li><li>Dijkstras算法用python实现的思路和源代码</li><li>Dijkstras算法的适用范围<br>代码和笔记记录下载请到<a href="https://github.com/yucicheung/grokking_algorithms_practice/tree/master/07_dijkstras_algorithm" target="_blank" rel="noopener">我的github仓库</a>。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2></the></li></ul><ol><li>广度优先搜索，适用于<em>非加权图</em>(unweighted graph)，找到的<em>最短路径</em>是段数最少的路径。<strong>迪克斯特拉</strong>(Dijkstras)算法，适用于<em>加权图</em>(weighted graph)，找出的是总权重最小的路径。</li><li>Dijsktra算法包含四个步骤：<ol><li>找出当前离起点最近的节点；</li><li>对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销，并更新邻居的父节点；</li><li>重复这个过程，直到对所有节点都这样做了；</li><li>计算最终路径(路线和开销)。</li></ol></li><li>Dijstras的基本思想：对于处理的节点，已经找到到它们的最短路径(或没有到达它们的更短路径)。</li><li><p>以下图题目为例:<br><img src="/img/dijkstras_init.jpg" alt="dijkstras_init"></p><p>利用算法求最短路径的求解过程如下：</p><p><img src="/img/dijkstras_solve.jpg" alt="dijkstras_solve"></p><p>于是最终得到的最短路径<code>start--&gt; B--&gt; A--&gt; fin</code>,开销为6。</p></li></ol><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><ol><li>节点的开销应初始化为无穷大,保证只要有路线可达，其开销一定能被更新。Python中是<code>float(&#39;inf&#39;)</code>。</li><li>加权有向图仍然是散列表实现。</li><li>求解全过程要用到：<ul><li>有向图散列表；</li><li>开销散列表;</li><li>父节点散列表;</li><li>待处理节点列表(或已处理节点列表)。</li></ul></li><li>对<code>fin</code>终点不需要进行Dijkstras算法。</li></ol><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><ol><li>首先，Dijkstras算法适用于有向加权图。</li><li>对于<em>有向无环图</em>(directed acyclic graph, DAG)也是适用的，因为Dijkstras算法会自动淘汰含有环的边。</li><li><strong>不适用</strong>含负权边的有向图，负权边会在节点检查过之后仍然更新其开销，不符合Dijkstras算法的基本思想。在包含负权边的图中找最短路径要用另一种算法——Bellman-Ford算法。</li></ol><h2 id="代码实现-python"><a href="#代码实现-python" class="headerlink" title="代码实现(python)"></a>代码实现(python)</h2><p>针对上面的有向图求解。<br>代码实现和笔记都在<a href="https://github.com/yucicheung/grokking_algorithms_practice/tree/master/07_dijkstras_algorithm" target="_blank" rel="noopener">我的github仓库</a>可以下载到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_lowest_cost</span><span class="params">(costs,to_process)</span>:</span></span><br><span class="line">lowest_cost_node = to_process[<span class="number">0</span>]</span><br><span class="line">lowest_cost = costs[lowest_cost_node]</span><br><span class="line"><span class="keyword">if</span> len(to_process)&gt;<span class="number">1</span>:</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> to_process[<span class="number">1</span>:]:</span><br><span class="line">new_cost = costs[node]</span><br><span class="line"><span class="keyword">if</span> new_cost &lt; lowest_cost:</span><br><span class="line">lowest_cost = new_cost</span><br><span class="line">lowest_cost_node = node</span><br><span class="line"><span class="keyword">return</span> lowest_cost_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_up_graph</span><span class="params">()</span>:</span></span><br><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">'start'</span>] = &#123;<span class="string">"A"</span>:<span class="number">6</span>,<span class="string">"B"</span>:<span class="number">2</span>&#125;</span><br><span class="line">graph[<span class="string">"A"</span>] = &#123;<span class="string">'fin'</span>:<span class="number">1</span>&#125;</span><br><span class="line">graph[<span class="string">"B"</span>] = &#123;<span class="string">"A"</span>:<span class="number">3</span>,<span class="string">"fin"</span>:<span class="number">5</span>&#125;</span><br><span class="line">graph[<span class="string">'fin'</span>] = &#123;&#125;</span><br><span class="line"><span class="keyword">return</span> graph</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_costs_n_fathers</span><span class="params">(graph)</span>:</span></span><br><span class="line">costs, fathers =&#123;&#125;,&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line"><span class="keyword">if</span> node <span class="keyword">is</span> <span class="string">"start"</span>:</span><br><span class="line">costs[node] = <span class="number">0</span></span><br><span class="line">fathers[node] = <span class="keyword">None</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">costs[node] = float(<span class="string">'inf'</span>)</span><br><span class="line"><span class="keyword">return</span> costs,fathers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shortest_path</span><span class="params">(fathers)</span>:</span></span><br><span class="line">path = []</span><br><span class="line">father = <span class="string">'fin'</span></span><br><span class="line">path.append(father)</span><br><span class="line"><span class="keyword">while</span> father != <span class="string">'start'</span>:</span><br><span class="line">father = fathers[father]</span><br><span class="line">path.append(father)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Shortest path is:'</span>,</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> path[<span class="number">-1</span>:-len(path):<span class="number">-1</span>]:</span><br><span class="line"><span class="keyword">print</span> <span class="string">'&#123;&#125;--&gt;'</span>.format(i),</span><br><span class="line"><span class="keyword">print</span> path[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">graph = set_up_graph()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Graph as below:'</span></span><br><span class="line">pprint(graph)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'\n'</span></span><br><span class="line">costs, fathers = initialize_costs_n_fathers(graph)</span><br><span class="line">to_process = [i <span class="keyword">for</span> i <span class="keyword">in</span> graph.keys()]</span><br><span class="line">to_process.remove(<span class="string">'fin'</span>)</span><br><span class="line"><span class="keyword">while</span> to_process:</span><br><span class="line">node = find_lowest_cost(costs,to_process)</span><br><span class="line">neighbors = graph[node]</span><br><span class="line"><span class="keyword">for</span> neighbor <span class="keyword">in</span> neighbors:</span><br><span class="line">new_cost = costs[node] + graph[node][neighbor]</span><br><span class="line"><span class="keyword">if</span> new_cost &lt; costs[neighbor]:</span><br><span class="line">costs[neighbor] = new_cost</span><br><span class="line">fathers[neighbor] = node</span><br><span class="line">to_process.remove(node) <span class="comment"># keys donnot share names</span></span><br><span class="line">get_shortest_path(fathers)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'The lowest cost is &#123;&#125;.'</span>.format(costs[<span class="string">'fin'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>运行结果为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Graph as below:</span><br><span class="line">&#123;<span class="string">'A'</span>: &#123;<span class="string">'fin'</span>: 1&#125;,</span><br><span class="line"> <span class="string">'B'</span>: &#123;<span class="string">'A'</span>: 3, <span class="string">'fin'</span>: 5&#125;,</span><br><span class="line"> <span class="string">'fin'</span>: &#123;&#125;,</span><br><span class="line"> <span class="string">'start'</span>: &#123;<span class="string">'A'</span>: 6, <span class="string">'B'</span>: 2&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Shortest path is: start--&gt; B--&gt; A--&gt; fin</span><br><span class="line">The lowest cost is 6.</span><br></pre></td></tr></table></figure></p><p>也可以将上面的图改成是有环的图，就能验证到对有环图也是适用的。</p>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python中的argv和argc</title>
      <link href="/2018/03/17/python%E4%B8%AD%E7%9A%84argv%E5%92%8Cargc/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li>为什么<code>argv</code>中第一个，即index=0的内容就是文件名？</li><li>python中<code>argc</code>是用什么实现的？<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><code>argc</code>:argument counter，命令行参数个数<br><code>argv</code>:argument vector，命令行参数向量(内容)<h2 id="通过代码理解含义"><a href="#通过代码理解含义" class="headerlink" title="通过代码理解含义"></a>通过代码理解含义</h2>创建一个文件<code>arg_exam.py</code>，其中内容如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># argv</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">    <span class="keyword">print</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment"># argc</span></span><br><span class="line">argc = len(sys.argv)</span><br><span class="line"><span class="keyword">print</span> argc</span><br></pre></td></tr></table></figure></the></li></ul><p>在shell中运行一个简单的例子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python arg_exam.py hello I am an example</span><br></pre></td></tr></table></figure></p><p>输出为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arg_exam.py</span><br><span class="line">hello</span><br><span class="line">I</span><br><span class="line">am</span><br><span class="line">an</span><br><span class="line">example</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p><p>所以说，<code>argv</code>就是<code>python</code>命令后跟着的一系列命令参数的内容。<br>而<code>argc</code>（在C语言存在的变量）就是这些命令参数的个数了，在python中因为<code>argv</code>是个列表，其长度<code>len</code>自然就是<code>argc</code>了，所以python中并没有为<code>argc</code>特地设置一个方法或者属性。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>argv是在命令行中运行程序时跟在<code>python</code>命令后的所有内容，以空格为分界，得到各元素。</li><li>python中argc并不是一个特定属性或方法，而是可以直接通过<code>len(sys.argv)</code>获得。</li></ul>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为Github page绑定自定义域名并实现https访问</title>
      <link href="/2018/03/14/%E4%B8%BAGithub-page%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%B9%B6%E5%AE%9E%E7%8E%B0https%E8%AE%BF%E9%97%AE/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><code>实现目标</code></excerpt></p><ul><li>获取自定义域名<code>yucichueng.me</code>;</li><li>将上述域名(及<strong>www</strong>域名)解析到<code>yucichueng.github.io</code>IP地址;</li><li>将域名解析服务托管于<strong>CloudFlare</strong>;</li><li>获取<strong>SSL</strong>证书，使网站可以通过<strong>https</strong>访问。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="获取自定义域名"><a href="#获取自定义域名" class="headerlink" title="获取自定义域名"></a>获取自定义域名</h2>我购买的域名是<code>yucicheung.me</code>。<br>一级域名<code>me</code>在<a href="https://au.godaddy.com/" target="_blank" rel="noopener">GoDaddy</a>网站进行购买。心仪的域名可以在网站<a href="https://www.whois.net/" target="_blank" rel="noopener">whois</a>查看是否被注册，未被注册可在相应域名商处购买。<br><strong>Tips:</strong>如果是在<code>Godaddy</code>购买的域名，建议购买隐私服务(不泄露个人信息)，不是很便宜，所以建议可以直接从国内域名商处购买，赠送隐私保护服务。<h2 id="域名解析到Github-page"><a href="#域名解析到Github-page" class="headerlink" title="域名解析到Github page"></a>域名解析到Github page</h2>购买域名后，在对应域名供应商处一般会提供域名解析服务，我们需要对解析服务进行配置。<br>对我来说，就要在<code>Godaddy</code>域名解析服务处进行配置。<h3 id="修改域名服务商解析记录"><a href="#修改域名服务商解析记录" class="headerlink" title="修改域名服务商解析记录"></a>修改域名服务商解析记录</h3></the></li></ul><ol><li>点击主页右上角自己的账户名–&gt;点击<strong>manage my domains</strong>–&gt;在<strong>My Domains</strong>选择<strong>Manage DNS</strong>;<div align="center"><br><img src="\img\manage_DNS.png" alt="manage_DNS"><br></div></li><li>添加<code>CNAME</code>和<code>A</code>解析记录，使<code>www</code>网址和<code>@</code>(即本身)都指向自己的github page；<br>按以下表格分别添加<strong>A</strong>和<strong>CNAME</strong>两条解析记录：</li></ol><table><thead><tr><th style="text-align:center">类型type</th><th style="text-align:center">主机host</th><th style="text-align:center">指向points to</th><th style="text-align:center">TTL(Time To Live)</th></tr></thead><tbody><tr><td style="text-align:center"><code>A</code></td><td style="text-align:center"><code>@</code></td><td style="text-align:center">github page的IP 地址</td><td style="text-align:center">600</td></tr><tr><td style="text-align:center"><code>CNAME</code></td><td style="text-align:center"><code>www</code></td><td style="text-align:center">github page的网址</td><td style="text-align:center">600</td></tr><tr><td style="text-align:center"><strong>A记录</strong>：<br>用来指定域名的IPv4地址<br>如要将域名指向一个IP地址<br>添加A记录<br><br><strong>CNAME</strong>：<br> 如要将域名指向另一域名<br>再由该域名提供ip<br>添加CNAME记录</td><td style="text-align:center"><strong>www</strong>：<br>解析后域名为<strong><a href="http://www.yucicheung.me" target="_blank" rel="noopener">www.yucicheung.me</a></strong><br><br><strong>@</strong>：<br>解析主域名<strong>yucicheung.me</strong><br><br><strong>*</strong>：<br>泛解析，匹配其他所有域名，<strong>*.yucicheung.me</strong></td><td style="text-align:center">对于<code>A记录</code>:<br>要指向IP地址<br><br>对于<code>CNAME</code>:<br>要指向一个域名<br><br></td><td style="text-align:center">指地方dns缓存域名记录的时间,缓存失效后会再次获取<br><br><strong>600</strong>:<br>建议采用600<br><br><strong>60</strong>:<br>如果经常修改IP可用(修改可快速生效),长期使用略影响解析速度<br><br><strong>3600</strong>:<br>如果IP极少变动(一年几次),可选择 3600,解析速度快</td></tr></tbody></table><p><strong>Tips</strong>：github page的IP地址可以通过以下命令获取：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping yucicheung.github.io</span><br></pre></td></tr></table></figure></p><h3 id="添加github仓库的域名解析记录"><a href="#添加github仓库的域名解析记录" class="headerlink" title="添加github仓库的域名解析记录"></a>添加github仓库的域名解析记录</h3><ol><li><p>按以下命令在自己的github仓库中添加CNAME文件，其中填入购买的域名。或者可以在仓库的<strong>settings</strong>中设置<strong>Custom Domain</strong>设置好自己的域名，github会自动添加CNAME文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ touch CNAME</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'yucicheung.me'</span>&gt; CNAME</span><br></pre></td></tr></table></figure></li><li><p>稍等一下就可以通过购买域名<strong>yucicheung.me</strong>访问<strong>yucicheung.github.io</strong>了，但是这时只能通过<code>http</code>访问自定义域名而非<code>https</code>。</p></li></ol><h2 id="通过HTTPS访问自定义域名"><a href="#通过HTTPS访问自定义域名" class="headerlink" title="通过HTTPS访问自定义域名"></a>通过HTTPS访问自定义域名</h2><p>在完成上述操作以后，只能通过<code>HTTP</code>协议传输(明文传输),于是在通过自定义域名访问自己的github page时，发现浏览器提示<strong>该网址不安全，没有合格的安全证书</strong>，不能通过<code>https</code>(密文传输)访问。</p><h3 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h3><p><strong>HTTP</strong>是明文传输协议，传输内容容易被嗅探和篡改。<br>而<strong>HTTPS</strong>，即<strong>HTTP over SSL/TLS</strong>,是添加了一层<strong>SSL(Secure Sockets Layer，安全套接层)</strong>，或者是<strong>TLS(Transport Layer Security,传输层安全协议)</strong>，所以<strong>HTTPS</strong>就可以视为<strong>HTTP</strong>和<strong>SSL/TLS</strong>协议的组合。<br><br><br><strong>HTTPS</strong>能做到良好的保密性(防嗅探)，真实性(防篡改)，完整性(防域名劫持和域名欺骗)。</p><h3 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h3><p><strong>SSL</strong>是<strong>TLS</strong>的前身，但<strong>TLS</strong>通常也被标志为<strong>SSL</strong>。<br><strong>SSL/TLS</strong>协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息(会话秘钥)，服务器收到密文后，用自己的私钥解密。<br>这个公钥就放在数字证书中。只要证书是可信的，公钥就是可信的。</p><h3 id="申请SSL证书"><a href="#申请SSL证书" class="headerlink" title="申请SSL证书"></a>申请SSL证书</h3><p>SSL证书由你的NS(Name Server，域名服务商)颁发，由于<code>GoDaddy</code>的SSL证书超级贵，所以我们可以迁移到免费提供SSL的NS处，比如国内的<strong>DNSpod</strong>(国内都需要备案),还有国外的<strong>Netlify</strong>和<strong>Cloudflare</strong>，从速度和操作性考虑，本人选择了<code>Cloudflare</code>。</p><ol><li>到<a href="https://www.cloudflare.com/" target="_blank" rel="noopener">Cloudflare官网</a>注册；</li><li>根据指引点击<strong>Add Site</strong>，添加自定义域名<strong>yucicheung.me</strong>，会自动开始扫描DNS解析记录；</li><li>扫描完成后，<strong>Cloudflare</strong>会选择给我们分配两个NS地址，将这两个地址替换<strong>GoDaddy</strong>上的原NS地址，等待生效；<div align="center"><br><img src="/img/change_ns.png" alt="change_ns"><br></div></li><li>在<strong>Cloudflare</strong>上检查自己网站的状态，显示为<code>Active</code>时表示NS更改成功；<div align="center"><br><img src="/img/Active.png" alt="active"><br></div></li><li>在<strong>Cloudflare</strong>将自己网站的<strong>SSL</strong>状态改变为<code>Full</code>状态，等待<strong>Status</strong>变为<code>Active Certificate</code>，通常生效需要十几分钟。<div align="center"><br><img src="/img/full_SSL.png" alt="ssl"><br></div></li><li>再访问自定义域名时，就可以看见是<code>https</code>传输，网址前也有一把绿色小锁,可以看到这个证书其实是Cloudflare的证书。<br><div align="center"><br><img src="/img/https.png" alt="https"><br><img src="/img/ssl.png" alt="ssl"><br></div><h2 id="CDN-关于访问速度"><a href="#CDN-关于访问速度" class="headerlink" title="CDN:关于访问速度"></a>CDN:关于访问速度</h2>如果因为NS在国外，担心访问速度，可以稍微放心。<br><strong>Cloudflare</strong>本身提供<code>CDN</code>(content delivery network,内容分发网络)服务，是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，就近获取网络内容传递给用户。<br>免费服务一般只能加速<strong>css、js</strong>的引用，而对于<strong>html</strong>和<strong>图片</strong>的加速通常是付费服务。<br>实验过之后，确实是图片加载会稍慢一些，但是整体速度是可以接受的，<strong>如果实在介意速度，建议通过国内NS解析网址</strong>。<br>另：发现Cloudflare已经和baidu合作针对企业级用户启动加速服务，一个节点服务海外访问者，另一个服务国内访问者。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li></ol><ul><li>最后实现的整个系统可以这么理解：就相当于由github提供主机（相当于寄存在github的服务器），自己购买域名，域名指向服务器文件进行展示。</li><li>原本的github主页，域名解析由GitHub负责，SSL证书由github.com提供，所以可以安全访问。现在的域名解析由Cloudflare服务，SSL证书也由其提供。</li></ul>]]></content>
      
      <categories>
          
          <category> Documenting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> SSL </tag>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu下用hexo搭建github博客</title>
      <link href="/2018/03/13/Ubuntu%E4%B8%8B%E7%94%A8hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li>配置环境：<strong>Ubuntu 16.04</strong></li><li>搭建目标：<strong>Github page(username.github.io)</strong></li><li>搭建程序：<strong>hexo</strong></li><li>在新建分支hexo下管理部署文件，最终部署到主分支master进行网站发布，涉及第三方应用绑定。<a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install git-core <span class="comment"># 已安装请略过</span></span><br></pre></td></tr></table></figure></the></li></ul><p>并且在你的github主页创建一个repo，命名为<code>username.github.io</code>，比如对我来说就是<code>yucicheung.github.io</code>。本帖不细述，请参考<a href="https://pages.github.com/" target="_blank" rel="noopener">github page基本指南</a>。</p><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure><p>重新开启终端使<code>nvm</code>命令生效。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nvm ls-remote <span class="comment"># 查看所有可用版本</span></span><br><span class="line">$ nvm install v8.10.0 <span class="comment"># 选择最新稳定版本</span></span><br><span class="line">$ node -v <span class="comment">#显示v8.10.0表示安装成功</span></span><br></pre></td></tr></table></figure></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install npm <span class="comment"># 安装package manager</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure><h2 id="hexo基础配置"><a href="#hexo基础配置" class="headerlink" title="hexo基础配置"></a>hexo基础配置</h2><h3 id="初始化模板"><a href="#初始化模板" class="headerlink" title="初始化模板"></a>初始化模板</h3><p>用<code>hexo</code>命令初始化一个空文件夹。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init hexo</span><br></pre></td></tr></table></figure></p><p>hexo安装所需的新文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo</span><br><span class="line">hexo $ npm install</span><br></pre></td></tr></table></figure></p><p>改变<code>hexo/</code>文件夹下的<code>_config.yml</code>的一些简单配置包括<code>title</code>,’author’等，之后就可以用以下命令预览。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server <span class="comment"># 默认端口4000</span></span><br></pre></td></tr></table></figure></p><p><strong>Notice:</strong>如果端口<code>4000</code>被占用，或者更换端口预览，或者解除占用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1：更换端口</span></span><br><span class="line">$ hexo server -p 5000</span><br><span class="line"><span class="comment"># 方法2：解除端口占用</span></span><br><span class="line">$ lsof -i:4000</span><br><span class="line">$ <span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure></p><h2 id="更改主题为yelee"><a href="#更改主题为yelee" class="headerlink" title="更改主题为yelee"></a>更改主题为yelee</h2><p>首先要在<a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">hexo-themes</a>中选择一个喜欢的主题，从git上<code>clone</code>到本地<code>themes/</code>文件夹下并命名为<code>yelee</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo/</span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:MOxFIVE/hexo-theme-yelee.git themes/yelee</span><br></pre></td></tr></table></figure></p><p>然后更改<code>hexo/_config.yml</code>中<code>theme: landscape</code>改为<code>theme: yelee</code>，<code>themes/lanscape</code>文件夹可删除。<br>再用<code>hexo server</code>或<code>hexo s</code>就可以预览为新主题了。<br>具体theme中相应主题配置应参考对应theme的官方文档，如<a href="http://moxfive.coding.me/yelee/" target="_blank" rel="noopener">yelee的官方文档</a>。</p><h2 id="部署到网站"><a href="#部署到网站" class="headerlink" title="部署到网站"></a>部署到网站</h2><p><strong>说明:网站的部署其实就是生成静态文件，<code>hexo</code>下所有生成的静态文件会放在<code>public/</code>文件夹中，所谓部署<code>deploy</code>其实就是将<code>public/</code>文件夹中内容上传到git仓库<code>yucicheung.github.io</code>中。</strong><br>要准备将静态文件部署到自己的git主页，首先需要安装一个用于部署的插件<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>，这个插件可以自动将<code>public/</code>文件中内容上传到<code>master</code>下(即用于生成github.io界面的文件)。<br><strong>如果不装插件，也可以手动进行文件复制。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>然后在<code>hexo/_config.yml</code>的<code>deploy</code>部分配置以下语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/yucicheung/yucicheung.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>需要在根据需要修改<code>hexo/</code>和<code>hexo/themes/</code>下的<code>_config.yml</code>文件后，就可以进行生成和部署了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate <span class="comment"># 或hexo g</span></span><br><span class="line">$ hexo deploy <span class="comment"># 或hexo d</span></span><br></pre></td></tr></table></figure></p><p><code>deploy</code>时需要github的账户和密码，自动上传文件完成部署。<br><strong>Tips：</strong>网站再次进行部署时，还需要清理<code>public</code>文件夹内容，重新生成部署，用以下命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean <span class="comment"># 尤其在更换主题后需使用</span></span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></p><h2 id="管理hexo文件"><a href="#管理hexo文件" class="headerlink" title="管理hexo文件"></a>管理hexo文件</h2><p>最好的办法是在<code>username.github.io</code>主页创建两个分支，一个<code>master</code>分支(由deployer管理)，一个<code>hexo</code>分支（我们自己管理）。<br>在把自己的<code>username.github.io</code>仓库克隆到本地后，<code>cd username.github.io</code>，进行以下操作。<br>创建hexo分支并切换到该分支。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hexo</span><br></pre></td></tr></table></figure></p><p>将<code>hexo/</code>文件夹下所有内容拷贝到<code>username.github.io/hexo/</code>下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp -r ~/hexo/ ~/yucicheung.github.io/</span><br></pre></td></tr></table></figure></p><p>将修改加入并push到分支<code>hexo</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"commet"</span></span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure></p><p>这样文件管理就很方便了。</p><h2 id="第三方部署"><a href="#第三方部署" class="headerlink" title="第三方部署"></a>第三方部署</h2><p>因为第三方部署跟主题有很大关系，而<a href="http://moxfive.coding.me/yelee/5.Vendor/" target="_blank" rel="noopener">主题文档</a>中说明得比较清楚，我主要讨论一下文档中说明不清的Google站长认证问题。</p><h3 id="Google站长验证"><a href="#Google站长验证" class="headerlink" title="Google站长验证"></a>Google站长验证</h3><ol><li>如果要按照主题定义的方法操作，需要在验证备用方法中选择<code>html验证</code>。</li><li>Google验证，默认方法是提供给你一个html文件，拷贝至<code>theme</code>下的<code>source</code>文件中，在<code>generate</code>的时候会原样生成。<br><strong>Tips:</strong>同理，如果有每次生成都要保存的html文件，请都放置在此文件夹下。如果是<code>README.md</code>文件要保持不被渲染，请添加到<code>hexo/source/</code>下，并且在<code>hexo/_config.yml</code>中配置<code>skip_render: README.md</code>。<h2 id="文章的发表"><a href="#文章的发表" class="headerlink" title="文章的发表"></a>文章的发表</h2>先生成draft，然后发表。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new draft <span class="string">"title"</span> <span class="comment">#在source/_draft下生成md文件</span></span><br><span class="line">$ hexo publish <span class="string">"title"</span></span><br></pre></td></tr></table></figure></li></ol><p>草稿默认不会显示在页面中，可在配置文件中把render_drafts 参数设为 true 来预览草稿。<br><strong>或</strong>直接生成新文章。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"title"</span> <span class="comment"># 自动生成title.md在_posts下</span></span><br></pre></td></tr></table></figure></p><p>如果要删除文章的话在source下删除文章后，重新生成和部署就可以了</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://hexo.io/zh-cn/docs" target="_blank" rel="noopener">hexo文档</a></li><li><a href="http://moxfive.coding.me/yelee" target="_blank" rel="noopener">yelee主题配置帖</a></li></ol>]]></content>
      
      <categories>
          
          <category> Documenting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
